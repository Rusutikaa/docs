<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Basic Operators — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID61"><span class="enstr">Terminology</span><!--end_enstr-->
<span class="jpstr">
用語
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID62"><span class="enstr">Assignment Operator</span><!--end_enstr-->
<span class="jpstr">
代入演算子
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID63"><span class="enstr">Arithmetic Operators</span><!--end_enstr-->
<span class="jpstr">
算術演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID64"><span class="enstr">Remainder Operator</span><!--end_enstr-->
<span class="jpstr">
剰余演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID67"><span class="enstr">Unary Minus Operator</span><!--end_enstr-->
<span class="jpstr">
単項マイナス演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID68"><span class="enstr">Unary Plus Operator</span><!--end_enstr-->
<span class="jpstr">
単項プラス演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID69"><span class="enstr">Compound Assignment Operators</span><!--end_enstr-->
<span class="jpstr">
複合代入演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID70"><span class="enstr">Comparison Operators</span><!--end_enstr-->
<span class="jpstr">
比較演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID71"><span class="enstr">Ternary Conditional Operator</span><!--end_enstr-->
<span class="jpstr">
三項条件演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID72"><span class="enstr">Nil-Coalescing Operator</span><!--end_enstr-->
<span class="jpstr">
nil合体演算子
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID73"><span class="enstr">Range Operators</span><!--end_enstr-->
<span class="jpstr">
範囲演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID74"><span class="enstr">Closed Range Operator</span><!--end_enstr-->
<span class="jpstr">
完結範囲演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID75"><span class="enstr">Half-Open Range Operator</span><!--end_enstr-->
<span class="jpstr">
半開範囲演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID562"><span class="enstr">One-Sided Ranges</span><!--end_enstr-->
<span class="jpstr">
片側範囲
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID76"><span class="enstr">Logical Operators</span><!--end_enstr-->
<span class="jpstr">
論理演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID77"><span class="enstr">Logical NOT Operator</span><!--end_enstr-->
<span class="jpstr">
論理否定演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID78"><span class="enstr">Logical AND Operator</span><!--end_enstr-->
<span class="jpstr">
論理積演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID79"><span class="enstr">Logical OR Operator</span><!--end_enstr-->
<span class="jpstr">
論理和演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID80"><span class="enstr">Combining Logical Operators</span><!--end_enstr-->
<span class="jpstr">
論理演算子を結合する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID81"><span class="enstr">Explicit Parentheses</span><!--end_enstr-->
<span class="jpstr">
明確な括弧
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="basic-operators">
<h1><span class="enstr">Basic Operators<a class="headerlink" href="#basic-operators" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
基本の演算子<a class="headerlink" href="#basic-operators" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">An <em>operator</em> is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) adds two numbers, as in <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>, and the logical AND operator (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>) combines two Boolean values, as in <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">enteredDoorCode</span> <span class="pre">&amp;&amp;</span> <span class="pre">passedRetinaScan</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>演算子</em>は、あなたがいろいろな値を調べたり、変えたり、結合したりするために使う、特別な記号または語句です。例えば、加算演算子（<code class="docutils literal notranslate"><span class="pre">+</span></code>）は、<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>のように、２つの数を加えてひとつにします、そして論理積演算子（<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>）は、<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">enteredDoorCode</span> <span class="pre">&amp;&amp;</span> <span class="pre">passedRetinaScan</span></code>のように、２つのブール値を組み合わせます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift supports the operators you may already know from languages like C, and improves several capabilities to eliminate common coding errors. The assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) is intended. Arithmetic operators (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code> and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them. You can opt in to value overflow behavior by using Swift’s overflow operators, as described in <a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">Overflow Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、あなたがCのような言語から既に知っているかもしれない演算子をサポートします、そしていくつかの能力を向上させることで一般的なコード記述エラーを排除します。代入演算子（<code class="docutils literal notranslate"><span class="pre">=</span></code>）は値を返しません、同等演算子（<code class="docutils literal notranslate"><span class="pre">==</span></code>）が意図される時にそれが誤って使われるのを防ぐためです。算術演算子（<code class="docutils literal notranslate"><span class="pre">+</span></code>、<code class="docutils literal notranslate"><span class="pre">-</span></code>、<code class="docutils literal notranslate"><span class="pre">*</span></code>、<code class="docutils literal notranslate"><span class="pre">/</span></code>、<code class="docutils literal notranslate"><span class="pre">%</span></code>その他）は、値があふれること（オーバフロー）を検知して承認しません、数を扱うときにそれらを格納する型の許容される値の範囲より大きいか小さくなる予想外の結果を防ぐためです。<a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">オーバフロー演算子</span></a>で記述されるように、あなたは、スウィフトのもつオーバフロー演算子を使うことによって、値オーバフロー挙動を選ぶことが可能です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift also provides range operators that aren’t found in C, such as <code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code> and <code class="docutils literal notranslate"><span class="pre">a...b</span></code>, as a shortcut for expressing a range of values.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはまた、Cでは見られない範囲演算子、例えば<code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code>と<code class="docutils literal notranslate"><span class="pre">a...b</span></code>を、値の範囲を表す近道として提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This chapter describes the common operators in Swift. <a class="reference internal" href="AdvancedOperators.html"><span class="doc">Advanced Operators</span></a> covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</span><!--end_enstr-->
<span class="jpstr">
この章は、スウィフトの通常の演算子を記載します。<a class="reference internal" href="AdvancedOperators.html"><span class="doc">先進の演算子</span></a>では、スウィフトの先進の演算子を取り扱い、加えてあなた独自のあつらえの演算子を定義する方法、そしてあなた独自のあつらえの型のために標準の演算子を実装する方法を解説します。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID61">
<h2><span class="enstr">Terminology<a class="headerlink" href="#ID61" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
用語<a class="headerlink" href="#ID61" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Operators are unary, binary, or ternary:</span><!--end_enstr-->
<span class="jpstr">
演算子には、単項、二項、または三項があります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><em>Unary</em> operators operate on a single target (such as <code class="docutils literal notranslate"><span class="pre">-a</span></code>). Unary <em>prefix</em> operators appear immediately before their target (such as <code class="docutils literal notranslate"><span class="pre">!b</span></code>), and unary <em>postfix</em> operators appear immediately after their target (such as <code class="docutils literal notranslate"><span class="pre">c!</span></code>).</span><!--end_enstr-->
<span class="jpstr">
<em>単項</em>演算子は、１つだけの目標に作用します（例えば<code class="docutils literal notranslate"><span class="pre">-a</span></code>など）。単項<em>接頭辞</em>演算子はそれらの目標の直前に現れます（例えば<code class="docutils literal notranslate"><span class="pre">!b</span></code>のように）、そして単項<em>接尾辞</em>演算子はそれらの目標の直後に現れます（例えば<code class="docutils literal notranslate"><span class="pre">c!</span></code>のように）。
</span><!--end_jpstr-->
</li>
<li>
<span class="enstr"><em>Binary</em> operators operate on two targets (such as <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code>) and are <em>infix</em> because they appear in between their two targets.</span><!--end_enstr-->
<span class="jpstr">
<em>二項</em>演算子は、２つの目標に作用します（例えば<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code>のように）、そしてそれがそれら２つの目標の間に現れるので<em>接中辞</em>です。
</span><!--end_jpstr-->
</li>
<li>
<span class="enstr"><em>Ternary</em> operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>).</span><!--end_enstr-->
<span class="jpstr">
<em>三項</em>演算子は、３つの目標に作用します。Cのように、スウィフトはただ１つの三項演算子、三項条件演算子（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>）だけをもちます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">The values that operators affect are <em>operands</em>. In the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>, the <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol is an infix operator and its two operands are the values <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>.</span><!--end_enstr-->
<span class="jpstr">
演算子が影響を及ぼす値は、<em>演算数</em>です。式<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>において、記号<code class="docutils literal notranslate"><span class="pre">+</span></code>は接中辞演算子です、そしてその２つの演算数は値<code class="docutils literal notranslate"><span class="pre">1</span></code>と<code class="docutils literal notranslate"><span class="pre">2</span></code>です。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID62">
<h2><span class="enstr">Assignment Operator<a class="headerlink" href="#ID62" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
代入演算子<a class="headerlink" href="#ID62" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">The <em>assignment operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>) initializes or updates the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> with the value of <code class="docutils literal notranslate"><span class="pre">b</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<em>代入演算子</em>（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code>)）は、<code class="docutils literal notranslate"><span class="pre">a</span></code>の値を<code class="docutils literal notranslate"><span class="pre">b</span></code>の値で初期化または更新します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">b</span> = <span class="m">10</span>
</li>
<li>
<span class="k">var</span> <span class="nv">a</span> = <span class="m">5</span>
</li>
<li>
<span class="nv">a</span> = <span class="nv">b</span>
</li>
<li>
<span class="c"><span class="enstr">// a is now equal to 10</span><!--end_enstr--><span class="jpstr">（aは今は10と等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</span><!--end_enstr-->
<span class="jpstr">
代入の右側が、複数の値をもつタプルであるならば、その要素は同時に複数の定数または変数に分解されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> (<span class="nv">x</span>, <span class="nv">y</span>) = (<span class="m">1</span>, <span class="m">2</span>)
</li>
<li>
<span class="c"><span class="enstr">// x is equal to 1, and y is equal to 2</span><!--end_enstr--><span class="jpstr">（xは１と等しい、そしてyは２と等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Unlike the assignment operator in C and Objective-C, the assignment operator in Swift doesn’t itself return a value. The following statement isn’t valid:</span><!--end_enstr-->
<span class="jpstr">
CとObjective-Cの代入演算子と違って、スウィフトの代入演算子は、それ自身で値を返しません。以下の文は、有効ではありません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">x</span> = <span class="nv">y</span> {
</li>
<li>    <span class="c"><span class="enstr">// This isn't valid, because x = y doesn't return a value.</span><!--end_enstr--><span class="jpstr">（これは有効ではありません、x = yが値を返さないので。）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This feature prevents the assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>) from being used by accident when the equal to operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) is actually intended. By making <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> invalid, Swift helps you to avoid these kinds of errors in your code.</span><!--end_enstr-->
<span class="jpstr">
この特徴は、実際には同等演算子（<code class="docutils literal notranslate"><span class="pre">==</span></code>）が意図されるときに、偶然に代入演算子（<code class="docutils literal notranslate"><span class="pre">=</span></code>）が使われるのを防止します。<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code>を無効にすることによって、スウィフトはあなたがこれらの種類のエラーをあなたのコードにおいて避けるのを手伝います。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID63">
<h2><span class="enstr">Arithmetic Operators<a class="headerlink" href="#ID63" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
算術演算子<a class="headerlink" href="#ID63" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift supports the four standard <em>arithmetic operators</em> for all number types:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、４つの標準の<em>算術演算子</em>を数の型すべてに対してサポートします：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Addition (<code class="docutils literal notranslate"><span class="pre">+</span></code>)</span><!--end_enstr-->
<span class="jpstr">
加算（<code class="docutils literal notranslate"><span class="pre">+</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Subtraction (<code class="docutils literal notranslate"><span class="pre">-</span></code>)</span><!--end_enstr-->
<span class="jpstr">
減算（<code class="docutils literal notranslate"><span class="pre">-</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Multiplication (<code class="docutils literal notranslate"><span class="pre">*</span></code>)</span><!--end_enstr-->
<span class="jpstr">
乗算（<code class="docutils literal notranslate"><span class="pre">*</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Division (<code class="docutils literal notranslate"><span class="pre">/</span></code>)</span><!--end_enstr-->
<span class="jpstr">
除算（<code class="docutils literal notranslate"><span class="pre">/</span></code>）
</span><!--end_jpstr-->
</li>
</ul>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="m">1</span> + <span class="m">2</span>       <span class="enstr"><span class="c">// equals 3</span></span><!--end_enstr--><span class="jpstr"><span class="c">（３に等しい）</span></span><!--end_jpstr--></li>
<li>
<span class="m">5</span> - <span class="m">3</span>       <span class="enstr"><span class="c">// equals 2</span></span><!--end_enstr--><span class="jpstr"><span class="c">（２に等しい）</span></span><!--end_jpstr--></li>
<li>
<span class="m">2</span> * <span class="m">3</span>       <span class="enstr"><span class="c">// equals 6</span></span><!--end_enstr--><span class="jpstr"><span class="c">（６に等しい）</span></span><!--end_jpstr--></li>
<li>
<span class="m">10.0</span> / <span class="m">2.5</span>  <span class="enstr"><span class="c">// equals 4.0</span></span><!--end_enstr--><span class="jpstr"><span class="c">（4.0に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default. You can opt in to value overflow behavior by using Swift’s overflow operators (such as <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;+</span> <span class="pre">b</span></code>). See <a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">Overflow Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
CとObjective-Cの算術演算子と違って、スウィフトの算術演算子は、値がオーバフローするのを初期状態では許しません。あなたは、スウィフトのオーバフロー演算子を使用することによって、値オーバフロー挙動を選ぶことが可能です（例えば<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;+</span> <span class="pre">b</span></code>のように）。<a class="reference internal" href="AdvancedOperators.html#ID37"><span class="std std-ref">オーバフロー演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The addition operator is also supported for <code class="docutils literal notranslate"><span class="pre">String</span></code> concatenation:</span><!--end_enstr-->
<span class="jpstr">
加算演算子は、また、<code class="docutils literal notranslate"><span class="pre">String</span></code>連結に対してもサポートされます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="s">"hello, "</span> + <span class="s">"world"</span>  <span class="enstr"><span class="c">// equals "hello, world"</span></span><!--end_enstr--><span class="jpstr"><span class="c">（「こんにちは、世界よ」に等しい）</span></span><!--end_jpstr--></li></ol></div></div></div>
<div class="section" id="ID64">
<h3><span class="enstr">Remainder Operator<a class="headerlink" href="#ID64" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
剰余演算子<a class="headerlink" href="#ID64" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>remainder operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>) works out how many multiples of <code class="docutils literal notranslate"><span class="pre">b</span></code> will fit inside <code class="docutils literal notranslate"><span class="pre">a</span></code> and returns the value that’s left over (known as the <em>remainder</em>).</span><!--end_enstr-->
<span class="jpstr">
<em>剰余演算子</em>（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>）は、どのくらい多くの<code class="docutils literal notranslate"><span class="pre">b</span></code>の倍数が<code class="docutils literal notranslate"><span class="pre">a</span></code>の内部に収まるかを計算して、残された値（<em>余り</em>として知られるもの）を返します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The remainder operator (<code class="docutils literal notranslate"><span class="pre">%</span></code>) is also known as a <em>modulo operator</em> in other languages. However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</span><!--end_enstr-->
<span class="jpstr">
剰余演算子（<code class="docutils literal notranslate"><span class="pre">%</span></code>）は、また、他の言語では<em>モジュロ演算子</em>として知られています。しかし、スウィフトでの負数に対するそれの挙動は、それが、厳密に言って、剰余（remainder）であり、モジュロ（modulo）演算でないのを意味します。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Here’s how the remainder operator works. To calculate <code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">%</span> <span class="pre">4</span></code>, you first work out how many <code class="docutils literal notranslate"><span class="pre">4</span></code>s will fit inside <code class="docutils literal notranslate"><span class="pre">9</span></code>:</span><!--end_enstr-->
<span class="jpstr">
ここに剰余演算子が機能する方法があります。<code class="docutils literal notranslate"><span class="pre">9</span> <span class="pre">%</span> <span class="pre">4</span></code>を計算するために、あなたは最初にどれくらい多くの<code class="docutils literal notranslate"><span class="pre">4</span></code>が<code class="docutils literal notranslate"><span class="pre">9</span></code>の中に収まるかを考え出します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/remainderInteger_2x.png" class="align-center" src="../images/remainderInteger_2x.png" style="width: 274px;">
<p><span class="enstr">You can fit two <code class="docutils literal notranslate"><span class="pre">4</span></code>s inside <code class="docutils literal notranslate"><span class="pre">9</span></code>, and the remainder is <code class="docutils literal notranslate"><span class="pre">1</span></code> (shown in orange).</span><!--end_enstr-->
<span class="jpstr">
あなたは２つの<code class="docutils literal notranslate"><span class="pre">4</span></code>を<code class="docutils literal notranslate"><span class="pre">9</span></code>の内部に収めることができます、そして余りは<code class="docutils literal notranslate"><span class="pre">1</span></code>です（オレンジ色で示されます）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In Swift, this would be written as:</span><!--end_enstr-->
<span class="jpstr">
スウィフトでは、これはこのように書かれます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="m">9</span> % <span class="m">4</span>    <span class="enstr"><span class="c">// equals 1</span></span><!--end_enstr--><span class="jpstr"><span class="c">（１に等しい）</span></span><!--end_jpstr--></li></ol></div></div></div>
<p><span class="enstr">To determine the answer for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>, the <code class="docutils literal notranslate"><span class="pre">%</span></code> operator calculates the following equation and returns <code class="docutils literal notranslate"><span class="pre">remainder</span></code> as its output:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>に対する答えを決定するために、<code class="docutils literal notranslate"><span class="pre">%</span></code>演算子は以下の等式を計算します、そしてその出力として<code class="docutils literal notranslate"><span class="pre">余り</span></code>を返します：
</span><!--end_jpstr-->
</p>
<p><code class="docutils literal notranslate"><span class="pre">a</span></code> = (<code class="docutils literal notranslate"><span class="pre">b</span></code> x <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">multiplier</span></code>) + <code class="docutils literal notranslate"><span class="pre">remainder</span></code></p>
<p><span class="enstr">where <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">multiplier</span></code> is the largest number of multiples of <code class="docutils literal notranslate"><span class="pre">b</span></code> that will fit inside <code class="docutils literal notranslate"><span class="pre">a</span></code>.</span><!--end_enstr-->
<span class="jpstr">
ここで<code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">multiplier</span></code>は<code class="docutils literal notranslate"><span class="pre">b</span></code>の倍数で<code class="docutils literal notranslate"><span class="pre">a</span></code>の内部に収まる最も大きな数です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Inserting <code class="docutils literal notranslate"><span class="pre">9</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> into this equation yields:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">9</span></code>と<code class="docutils literal notranslate"><span class="pre">4</span></code>をこの等式に入れることは、以下を生じます：
</span><!--end_jpstr-->
</p>
<p><code class="docutils literal notranslate"><span class="pre">9</span></code> = (<code class="docutils literal notranslate"><span class="pre">4</span></code> x <code class="docutils literal notranslate"><span class="pre">2</span></code>) + <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<p><span class="enstr">The same method is applied when calculating the remainder for a negative value of <code class="docutils literal notranslate"><span class="pre">a</span></code>:</span><!--end_enstr-->
<span class="jpstr">
同じメソッドが、負の値の<code class="docutils literal notranslate"><span class="pre">a</span></code>のための余りを計算するとき適用されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="m">-9</span> % <span class="m">4</span>   <span class="enstr"><span class="c">// equals -1</span></span><!--end_enstr--><span class="jpstr"><span class="c">（-１に等しい）</span></span><!--end_jpstr--></li></ol></div></div></div>
<p><span class="enstr">Inserting <code class="docutils literal notranslate"><span class="pre">-9</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code> into the equation yields:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">-9</span></code>と<code class="docutils literal notranslate"><span class="pre">4</span></code>を等式に入れることは、以下を生じます：
</span><!--end_jpstr-->
</p>
<p><code class="docutils literal notranslate"><span class="pre">-9</span></code> = (<code class="docutils literal notranslate"><span class="pre">4</span></code> x <code class="docutils literal notranslate"><span class="pre">-2</span></code>) + <code class="docutils literal notranslate"><span class="pre">-1</span></code></p>
<p><span class="enstr">giving a remainder value of <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</span><!--end_enstr-->
<span class="jpstr">
そして<code class="docutils literal notranslate"><span class="pre">-1</span></code>の余り値を与えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The sign of <code class="docutils literal notranslate"><span class="pre">b</span></code> is ignored for negative values of <code class="docutils literal notranslate"><span class="pre">b</span></code>. This means that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">-b</span></code> always give the same answer.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">b</span></code>の符号は、負の値の<code class="docutils literal notranslate"><span class="pre">b</span></code>のために無視されます。これは、<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>と<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">-b</span></code>が常に同じ答えを与えることを意味します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID67">
<h3><span class="enstr">Unary Minus Operator<a class="headerlink" href="#ID67" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
単項マイナス演算子<a class="headerlink" href="#ID67" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The sign of a numeric value can be toggled using a prefixed <code class="docutils literal notranslate"><span class="pre">-</span></code>, known as the <em>unary minus operator</em>:</span><!--end_enstr-->
<span class="jpstr">
数の値の符号は、<em>単項マイナス演算子</em>として知られる、接頭辞<code class="docutils literal notranslate"><span class="pre">-</span></code>を使うことによって切り換えられることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">three</span> = <span class="m">3</span>
</li>
<li>
<span class="k">let</span> <span class="nv">minusThree</span> = -<span class="nv">three</span>       <span class="enstr"><span class="c">// minusThree equals -3</span></span><!--end_enstr--><span class="jpstr"><span class="c">（minusThreeは、-3に等しい）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">plusThree</span> = -<span class="nv">minusThree</span>   <span class="enstr"><span class="c">// plusThree equals 3, or "minus minus three"</span></span><!--end_enstr--><span class="jpstr"><span class="c">（plusThreeは、3に、または「マイナス マイナス three」に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">The unary minus operator (<code class="docutils literal notranslate"><span class="pre">-</span></code>) is prepended directly before the value it operates on, without any white space.</span><!--end_enstr-->
<span class="jpstr">
単項マイナス演算子（<code class="docutils literal notranslate"><span class="pre">-</span></code>）は、それが作用する値の前に、全く空白なしで、直接に先頭に追加されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID68">
<h3><span class="enstr">Unary Plus Operator<a class="headerlink" href="#ID68" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
単項プラス演算子<a class="headerlink" href="#ID68" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>unary plus operator</em> (<code class="docutils literal notranslate"><span class="pre">+</span></code>) simply returns the value it operates on, without any change:</span><!--end_enstr-->
<span class="jpstr">
<em>単項プラス演算子</em>（<code class="docutils literal notranslate"><span class="pre">+</span></code>）は、それが作用する値を、どんな変更もせずに、ただ単純に返します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">minusSix</span> = <span class="m">-6</span>
</li>
<li>
<span class="k">let</span> <span class="nv">alsoMinusSix</span> = +<span class="nv">minusSix</span>  <span class="enstr"><span class="c">// alsoMinusSix equals -6</span></span><!--end_enstr--><span class="jpstr"><span class="c">（alsoMinusSixは、-6に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</span><!--end_enstr-->
<span class="jpstr">
単項プラス演算子は実際に何もしないけれども、あなたは、負の数に単項マイナス演算子を使うときに、正の数に対してもまたあなたのコードで釣り合いを取るためにそれを使うことができます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID69">
<h2><span class="enstr">Compound Assignment Operators<a class="headerlink" href="#ID69" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
複合代入演算子<a class="headerlink" href="#ID69" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Like C, Swift provides <em>compound assignment operators</em> that combine assignment (<code class="docutils literal notranslate"><span class="pre">=</span></code>) with another operation. One example is the <em>addition assignment operator</em> (<code class="docutils literal notranslate"><span class="pre">+=</span></code>):</span><!--end_enstr-->
<span class="jpstr">
Cのように、スウィフトは<em>複合代入演算子</em>を提供します、それは、代入（<code class="docutils literal notranslate"><span class="pre">=</span></code>）を別の演算と組み合わせます。１つの例は、<em>加算代入演算子</em>（<code class="docutils literal notranslate"><span class="pre">+=</span></code>）です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">a</span> = <span class="m">1</span>
</li>
<li>
<span class="nv">a</span> += <span class="m">2</span>
</li>
<li>
<span class="c"><span class="enstr">// a is now equal to 3</span><!--end_enstr--><span class="jpstr">（aは現在、３と等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The expression <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> is shorthand for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>. Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</span><!--end_enstr-->
<span class="jpstr">
式<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code>は、<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>の簡略な表現です。実質的に、加算と代入は１つの演算子に結合され、同時に両方の作業を実行します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The compound assignment operators don’t return a value. For example, you can’t write <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code>.</span><!--end_enstr-->
<span class="jpstr">
複合代入演算子は、値を返しません。例えば、あなたは<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code>を書くことができません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">For information about the operators provided by the Swift standard library, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID70">
<h2><span class="enstr">Comparison Operators<a class="headerlink" href="#ID70" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
比較演算子<a class="headerlink" href="#ID70" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift supports the following comparison operators:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、以下の比較演算子をサポートします：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
同等である (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Not equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
同等でない (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Greater than (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
より大きい (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Less than (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
より小さい、未満 (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Greater than or equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
より大きいか等しい、以上 (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Less than or equal to (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
より小さいか等しい、以下 (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code>)
</span><!--end_jpstr-->
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift also provides two <em>identity operators</em> (<code class="docutils literal notranslate"><span class="pre">===</span></code> and <code class="docutils literal notranslate"><span class="pre">!==</span></code>), which you use to test whether two object references both refer to the same object instance. For more information, see <a class="reference internal" href="ClassesAndStructures.html#ID90"><span class="std std-ref">Identity Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはまた、２つの<em>同一性演算子</em>を提供します（<code class="docutils literal notranslate"><span class="pre">===</span></code>と<code class="docutils literal notranslate"><span class="pre">!==</span></code>）、それはあなたが２つのオブジェクト参照が両方とも同じオブジェクト・インスタンスに言及するかどうかについて調べるために使います。更なる情報として、<a class="reference internal" href="ClassesAndStructures.html#ID90"><span class="std std-ref">同一性演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Each of the comparison operators returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value to indicate whether or not the statement is true:</span><!--end_enstr-->
<span class="jpstr">
それぞれの比較演算子は、<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値を返して、その文が真かどうかを指し示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="m">1</span> == <span class="m">1</span>   <span class="enstr"><span class="c">// true because 1 is equal to 1</span></span><!--end_enstr--><span class="jpstr"><span class="c">（１が1と同等なので真）</span></span><!--end_jpstr--></li>
<li>
<span class="m">2</span> != <span class="m">1</span>   <span class="c">// true because 2 isn't equal to 1</span>
</li>
<li>
<span class="m">2</span> &gt; <span class="m">1</span>    <span class="enstr"><span class="c">// true because 2 is greater than 1</span></span><!--end_enstr--><span class="jpstr"><span class="c">（２が１より大きいので真）</span></span><!--end_jpstr--></li>
<li>
<span class="m">1</span> &lt; <span class="m">2</span>    <span class="enstr"><span class="c">// true because 1 is less than 2</span></span><!--end_enstr--><span class="jpstr"><span class="c">（１が２より小さいので真）</span></span><!--end_jpstr--></li>
<li>
<span class="m">1</span> &gt;= <span class="m">1</span>   <span class="enstr"><span class="c">// true because 1 is greater than or equal to 1</span></span><!--end_enstr--><span class="jpstr"><span class="c">（１が１以上なので真）</span></span><!--end_jpstr--></li>
<li>
<span class="m">2</span> &lt;= <span class="m">1</span>   <span class="c">// false because 2 isn't less than or equal to 1</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Comparison operators are often used in conditional statements, such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement:</span><!--end_enstr-->
<span class="jpstr">
比較演算子は、条件文においてしばしば使われます、例えば<code class="docutils literal notranslate"><span class="pre">if</span></code>文など：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">name</span> = <span class="s">"world"</span>
</li>
<li>
<span class="k">if</span> <span class="nv">name</span> == <span class="s">"world"</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"hello, world"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"I'm sorry </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">, but I don't recognize you"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "hello, world", because name is indeed equal to "world".</span><!--end_enstr--><span class="jpstr">（「hello, world」を出力します、nameが確かに「world」と等しいので。）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">For more about the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">if</span></code>文に関する詳細は、<a class="reference internal" href="ControlFlow.html"><span class="doc">制御の流れ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can compare two tuples if they have the same type and the same number of values. Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal. Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison. If all the elements are equal, then the tuples themselves are equal. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたは、２つのタプルを比較することが、それらが同じ型と同じ数の値を持つならば可能です。タプルは、左から右へと、一度に１つの値を、比較が等しくない２つの値を見つけるまで、比較されます。そのような２つの値が比較されます、するとその比較の結果がタプル比較の結果全体を決定します。すべての要素が等しいならば、その時それらのタプル自体が等しいです。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>(<span class="m">1</span>, <span class="s">"zebra"</span>) &lt; (<span class="m">2</span>, <span class="s">"apple"</span>)   <span class="enstr"><span class="c">// true because 1 is less than 2; "zebra" and "apple" aren't compared</span></span><!--end_enstr--><span class="jpstr"><span class="c">// １は２より少ないので真；「zebra」と「apple」は比較されません</span></span><!--end_jpstr--></li>
<li>(<span class="m">3</span>, <span class="s">"apple"</span>) &lt; (<span class="m">3</span>, <span class="s">"bird"</span>)    <span class="enstr"><span class="c">// true because 3 is equal to 3, and "apple" is less than "bird"</span></span><!--end_enstr--><span class="jpstr"><span class="c">（３は３と等しく、「apple」は「bird」より少ないので真）</span></span><!--end_jpstr--></li>
<li>(<span class="m">4</span>, <span class="s">"dog"</span>) == (<span class="m">4</span>, <span class="s">"dog"</span>)      <span class="enstr"><span class="c">// true because 4 is equal to 4, and "dog" is equal to "dog"</span></span><!--end_enstr--><span class="jpstr"><span class="c">（４は４と等しく、「dog」は「dog」と等しいので真）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">In the example above, you can see the left-to-right comparison behavior on the first line. Because <code class="docutils literal notranslate"><span class="pre">1</span></code> is less than <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">"zebra")</span></code> is considered less than <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">"apple")</span></code>, regardless of any other values in the tuples. It doesn’t matter that <code class="docutils literal notranslate"><span class="pre">"zebra"</span></code> isn’t less than <code class="docutils literal notranslate"><span class="pre">"apple"</span></code>, because the comparison is already determined by the tuples’ first elements. However, when the tuples’ first elements are the same, their second elements <em>are</em> compared—this is what happens on the second and third line.</span><!--end_enstr-->
<span class="jpstr">
上の例において、あなたは左から右への比較挙動を最初の行において見ることができます。<code class="docutils literal notranslate"><span class="pre">1</span></code>は<code class="docutils literal notranslate"><span class="pre">2</span></code>より少ないことから、<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">"zebra")</span></code>は<code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">"apple")</span></code>より少ないとみなされます、タプルの中のあらゆる他の値に関係なく。<code class="docutils literal notranslate"><span class="pre">"zebra"</span></code>が<code class="docutils literal notranslate"><span class="pre">"apple"</span></code>より少ないことは問題ではありません、この比較はすでにタプルの最初の要素によって決定されているからです。しかしながら、タプルのもつ最初の要素が同じ場合、２番目の要素は比較<em>されます</em> — これが２番目と３番目の行で起こることです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples. For example, as demonstrated in the code below, you can compare two tuples of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Int)</span></code> because both <code class="docutils literal notranslate"><span class="pre">String</span></code> and <code class="docutils literal notranslate"><span class="pre">Int</span></code> values can be compared using the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator. In contrast, two tuples of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code> can’t be compared with the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator because the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator can’t be applied to <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values.</span><!--end_enstr-->
<span class="jpstr">
タプルは、与えられた演算子で比較されることが、その演算子がそれぞれのタプルの中の値それぞれに適用可能である場合にのみ可能です。例えば、下のコードで実演されるように、あなたは型<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Int)</span></code>の２つのタプルを比較できます、なぜなら<code class="docutils literal notranslate"><span class="pre">String</span></code>と<code class="docutils literal notranslate"><span class="pre">Int</span></code>の値の両方とも<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>演算子を使って比較できるからです。対照的に、型<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code>の２つのタプルは<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>演算子で比較できません、なぜなら<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>演算子は<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値に適用できるからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>(<span class="s">"blue"</span>, <span class="m">-1</span>) &lt; (<span class="s">"purple"</span>, <span class="m">1</span>)        <span class="enstr"><span class="c">// OK, evaluates to true</span></span><!--end_enstr--><span class="jpstr"><span class="c">（OK、trueと評価します）</span></span><!--end_jpstr--></li>
<li>(<span class="s">"blue"</span>, <span class="k">false</span>) &lt; (<span class="s">"purple"</span>, <span class="k">true</span>)  <span class="enstr"><span class="c">// Error because &lt; can't compare Boolean values</span></span><!--end_enstr--><span class="jpstr"><span class="c">（エラー、なぜなら &lt; がブール値を比較できないため）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリは、いくらかのタプル比較演算子を、７要素より少数でのタプルに対して含んでいます。７つまたはそれより多い要素のタプルを比較するには、あなたは比較演算子をあなた自身で実装しなければなりません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID71">
<h2><span class="enstr">Ternary Conditional Operator<a class="headerlink" href="#ID71" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
三項条件演算子<a class="headerlink" href="#ID71" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">The <em>ternary conditional operator</em> is a special operator with three parts, which takes the form <code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">?</span> <span class="pre">answer1</span> <span class="pre">:</span> <span class="pre">answer2</span></code>. It’s a shortcut for evaluating one of two expressions based on whether <code class="docutils literal notranslate"><span class="pre">question</span></code> is true or false. If <code class="docutils literal notranslate"><span class="pre">question</span></code> is true, it evaluates <code class="docutils literal notranslate"><span class="pre">answer1</span></code> and returns its value; otherwise, it evaluates <code class="docutils literal notranslate"><span class="pre">answer2</span></code> and returns its value.</span><!--end_enstr-->
<span class="jpstr">
<em>三項条件演算子</em>は３つの部分をもつ特別な演算子です、それは形式<code class="docutils literal notranslate"><span class="pre">question</span> <span class="pre">?</span> <span class="pre">answer1</span> <span class="pre">:</span> <span class="pre">answer2</span></code>をとります。それは、<code class="docutils literal notranslate"><span class="pre">question</span></code>が真実であるか間違っているかに基づいて、２つの式のうちの１つを評価することに対する近道です。<code class="docutils literal notranslate"><span class="pre">question</span></code>が真実ならば、それは<code class="docutils literal notranslate"><span class="pre">answer1</span></code>を評価して、その値を返します；そうでなければ、それは<code class="docutils literal notranslate"><span class="pre">answer2</span></code>を評価して、その値を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The ternary conditional operator is shorthand for the code below:</span><!--end_enstr-->
<span class="jpstr">
三項条件演算子は、下のコードの短縮形です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">question</span> {
</li>
<li>    <span class="nv">answer1</span>
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">answer2</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Here’s an example, which calculates the height for a table row. The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</span><!--end_enstr-->
<span class="jpstr">
ここにひとつの例があります、それはあるテーブルの列の高さを計算します。列の高さは、列にヘッダがあるならば内容の高さより50ポイント高く、列にヘッダがないならば20ポイント高くなければなりません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">contentHeight</span> = <span class="m">40</span>
</li>
<li>
<span class="k">let</span> <span class="nv">hasHeader</span> = <span class="k">true</span>
</li>
<li>
<span class="k">let</span> <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + (<span class="nv">hasHeader</span> ? <span class="m">50</span> : <span class="m">20</span>)
</li>
<li>
<span class="c"><span class="enstr">// rowHeight is equal to 90</span><!--end_enstr--><span class="jpstr">（rowHeightは、90と等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The example above is shorthand for the code below:</span><!--end_enstr-->
<span class="jpstr">
上の例は、下のコードの短縮形です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">contentHeight</span> = <span class="m">40</span>
</li>
<li>
<span class="k">let</span> <span class="nv">hasHeader</span> = <span class="k">true</span>
</li>
<li>
<span class="k">let</span> <span class="nv">rowHeight</span>: <span class="nc">Int</span>
</li>
<li>
<span class="k">if</span> <span class="nv">hasHeader</span> {
</li>
<li>    <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + <span class="m">50</span>
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">rowHeight</span> = <span class="nv">contentHeight</span> + <span class="m">20</span>
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// rowHeight is equal to 90</span><!--end_enstr--><span class="jpstr">（rowHeightは、90と等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The first example’s use of the ternary conditional operator means that <code class="docutils literal notranslate"><span class="pre">rowHeight</span></code> can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</span><!--end_enstr-->
<span class="jpstr">
最初の例の三項条件演算子の使用は、<code class="docutils literal notranslate"><span class="pre">rowHeight</span></code>がただ１行のコードで正しい値に設定されることができるのを意味します、それは２番目の例において使われるコードより簡潔です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement.</span><!--end_enstr-->
<span class="jpstr">
三項条件演算子は、２つの式のどちらを考慮するべきか決定することについての効果的な短縮形を提供します。しかし、注意して三項条件演算子を使用してください。その簡潔さは、濫用されるならば、読み辛いコードに至る可能性があります。三項条件演算子を使用したもの複数を１つの複合文に結合することを避けてください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID72">
<h2><span class="enstr">Nil-Coalescing Operator<a class="headerlink" href="#ID72" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
nil合体演算子<a class="headerlink" href="#ID72" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">The <em>nil-coalescing operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">??</span> <span class="pre">b</span></code>) unwraps an optional <code class="docutils literal notranslate"><span class="pre">a</span></code> if it contains a value, or returns a default value <code class="docutils literal notranslate"><span class="pre">b</span></code> if <code class="docutils literal notranslate"><span class="pre">a</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">a</span></code> is always of an optional type. The expression <code class="docutils literal notranslate"><span class="pre">b</span></code> must match the type that’s stored inside <code class="docutils literal notranslate"><span class="pre">a</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>nil合体演算子</em>（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">??</span> <span class="pre">b</span></code>）は、それが値を持つならばオプショナルの<code class="docutils literal notranslate"><span class="pre">a</span></code>をアンラップします、または<code class="docutils literal notranslate"><span class="pre">a</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば省略時の値の<code class="docutils literal notranslate"><span class="pre">b</span></code>を返します。<code class="docutils literal notranslate"><span class="pre">a</span></code>の式は常にオプショナル型です。<code class="docutils literal notranslate"><span class="pre">b</span></code>の式は<code class="docutils literal notranslate"><span class="pre">a</span></code>の中に格納される型に合致しなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The nil-coalescing operator is shorthand for the code below:</span><!--end_enstr-->
<span class="jpstr">
nil合体演算子は、以下のコードに対する簡略形です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="nv">a</span> != <span class="k">nil</span> ? <span class="nv">a</span>! : <span class="nv">b</span>
</li></ol></div></div></div>
<p><span class="enstr">The code above uses the ternary conditional operator and forced unwrapping (<code class="docutils literal notranslate"><span class="pre">a!</span></code>) to access the value wrapped inside <code class="docutils literal notranslate"><span class="pre">a</span></code> when <code class="docutils literal notranslate"><span class="pre">a</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and to return <code class="docutils literal notranslate"><span class="pre">b</span></code> otherwise. The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</span><!--end_enstr-->
<span class="jpstr">
上のコードは、三項条件演算子と強制アンラップ（<code class="docutils literal notranslate"><span class="pre">a!</span></code>）を使って、<code class="docutils literal notranslate"><span class="pre">a</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば<code class="docutils literal notranslate"><span class="pre">a</span></code>内部にラップされた値にアクセスします、それ以外では<code class="docutils literal notranslate"><span class="pre">b</span></code>を返します。nil合体演算子は、この条件検査およびアンラップを簡潔で判読しやすい形式にカプセル化するより洗練された方法を提供します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> is non-<code class="docutils literal notranslate"><span class="pre">nil</span></code>, the value of <code class="docutils literal notranslate"><span class="pre">b</span></code> isn’t evaluated. This is known as <em>short-circuit evaluation</em>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">a</span></code>の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば、<code class="docutils literal notranslate"><span class="pre">b</span></code>の値は評価されません。これは<em>短絡評価</em>として知られています。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、nil合体演算子を、省略時の色の名前とオプショナルの利用者定義の色の名前とで選択するために使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">defaultColorName</span> = <span class="s">"red"</span>
</li>
<li>
<span class="k">var</span> <span class="nv">userDefinedColorName</span>: <span class="nc">String</span>?   <span class="c">// defaults to nil</span>
</li>
<li>
</li>
<li>
<span class="k">var</span> <span class="nv">colorNameToUse</span> = <span class="nv">userDefinedColorName</span> ?? <span class="nv">defaultColorName</span>
</li>
<li>
<span class="c"><span class="enstr">// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</span><!--end_enstr--><span class="jpstr">（userDefinedColorNameはnilです、なのでcolorNameToUseは省略時の「赤」に設定されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> variable is defined as an optional <code class="docutils literal notranslate"><span class="pre">String</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Because <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is of an optional type, you can use the nil-coalescing operator to consider its value. In the example above, the operator is used to determine an initial value for a <code class="docutils literal notranslate"><span class="pre">String</span></code> variable called <code class="docutils literal notranslate"><span class="pre">colorNameToUse</span></code>. Because <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span> <span class="pre">??</span> <span class="pre">defaultColorName</span></code> returns the value of <code class="docutils literal notranslate"><span class="pre">defaultColorName</span></code>, or <code class="docutils literal notranslate"><span class="pre">"red"</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code>変数は、省略時の値の<code class="docutils literal notranslate"><span class="pre">nil</span></code>を持つ、あるオプショナルの<code class="docutils literal notranslate"><span class="pre">String</span></code>として定義されます。<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code>がオプショナル型であるため、あなたはその値を考慮するためにnil合体演算子を使うことが出来ます。上の例で、この演算子は<code class="docutils literal notranslate"><span class="pre">colorNameToUse</span></code>と呼ばれるある<code class="docutils literal notranslate"><span class="pre">String</span></code>変数の初期値を確定するために使われます。<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code>は<code class="docutils literal notranslate"><span class="pre">nil</span></code>なので、式<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span> <span class="pre">??</span> <span class="pre">defaultColorName</span></code>は、<code class="docutils literal notranslate"><span class="pre">defaultColorName</span></code>の値、すなわち<code class="docutils literal notranslate"><span class="pre">"red"</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you assign a non-<code class="docutils literal notranslate"><span class="pre">nil</span></code> value to <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> and perform the nil-coalescing operator check again, the value wrapped inside <code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code> is used instead of the default:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">nil</span></code>でない値を<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code>に代入して、nil合体演算子による確認をふたたび実行するならば、<code class="docutils literal notranslate"><span class="pre">userDefinedColorName</span></code>内にラップされた値は省略時のものの代わりに使用されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">userDefinedColorName</span> = <span class="s">"green"</span>
</li>
<li>
<span class="nv">colorNameToUse</span> = <span class="nv">userDefinedColorName</span> ?? <span class="nv">defaultColorName</span>
</li>
<li>
<span class="c"><span class="enstr">// userDefinedColorName isn't nil, so colorNameToUse is set to "green"</span><!--end_enstr--><span class="jpstr">（userDefinedColorNameはnilではありません、それでcolorNameToUseは「緑」に設定されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID73">
<h2><span class="enstr">Range Operators<a class="headerlink" href="#ID73" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
範囲演算子<a class="headerlink" href="#ID73" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift includes several <em>range operators</em>, which are shortcuts for expressing a range of values.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、いくつかの<em>範囲演算子</em>を含みます、それらは値の範囲を表す近道です。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID74">
<h3><span class="enstr">Closed Range Operator<a class="headerlink" href="#ID74" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
完結範囲演算子<a class="headerlink" href="#ID74" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>closed range operator</em> (<code class="docutils literal notranslate"><span class="pre">a...b</span></code>) defines a range that runs from <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>, and includes the values <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. The value of <code class="docutils literal notranslate"><span class="pre">a</span></code> must not be greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>完結範囲演算子</em>（<code class="docutils literal notranslate"><span class="pre">a...b</span></code>）は、<code class="docutils literal notranslate"><span class="pre">a</span></code>から<code class="docutils literal notranslate"><span class="pre">b</span></code>まで続く範囲を定義します、それは<code class="docutils literal notranslate"><span class="pre">a</span></code>と<code class="docutils literal notranslate"><span class="pre">b</span></code>の値を含んでいます。<code class="docutils literal notranslate"><span class="pre">a</span></code>の値は<code class="docutils literal notranslate"><span class="pre">b</span></code>より大きくてはいけません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop:</span><!--end_enstr-->
<span class="jpstr">
完結範囲演算子は、あなたがその値の全てが使われることを望む、ある範囲全体に渡って繰り返すときに役に立ちます、例えば<code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>ループで：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">index</span><span class="p">)</span><span class="s"> times 5 is </span>\<span class="p">(</span><span class="nv">index</span> * <span class="m">5</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// 1 times 5 is 5</span><!--end_enstr--><span class="jpstr">（１かける５は、５です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// 2 times 5 is 10</span><!--end_enstr--><span class="jpstr">（２かける５は、10です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// 3 times 5 is 15</span><!--end_enstr--><span class="jpstr">（３かける５は、15です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// 4 times 5 is 20</span><!--end_enstr--><span class="jpstr">（４かける５は、20です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// 5 times 5 is 25</span><!--end_enstr--><span class="jpstr">（５かける５は、25です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">For more about <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loops, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>ループに関する詳細は、<a class="reference internal" href="ControlFlow.html"><span class="doc">制御の流れ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID75">
<h3><span class="enstr">Half-Open Range Operator<a class="headerlink" href="#ID75" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
半開範囲演算子<a class="headerlink" href="#ID75" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>half-open range operator</em> (<code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code>) defines a range that runs from <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>, but doesn’t include <code class="docutils literal notranslate"><span class="pre">b</span></code>. It’s said to be <em>half-open</em> because it contains its first value, but not its final value. As with the closed range operator, the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> must not be greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>. If the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">b</span></code>, then the resulting range will be empty.</span><!--end_enstr-->
<span class="jpstr">
<em>半開範囲演算子</em>（<code class="docutils literal notranslate"><span class="pre">a..&lt;b</span></code>）は、<code class="docutils literal notranslate"><span class="pre">a</span></code>から<code class="docutils literal notranslate"><span class="pre">b</span></code>まで続く範囲を定義します、しかし<code class="docutils literal notranslate"><span class="pre">b</span></code>の値を含みません。それが<em>半開</em>と言われるのは、それがその最初の値を含むけれども、その最後の値は含まないためです。完結範囲演算子と同じように、<code class="docutils literal notranslate"><span class="pre">a</span></code>の値は<code class="docutils literal notranslate"><span class="pre">b</span></code>より大きくてはいけません。<code class="docutils literal notranslate"><span class="pre">a</span></code>の値が<code class="docutils literal notranslate"><span class="pre">b</span></code>と等しいならば、そのとき結果として生じる範囲は空になります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:</span><!--end_enstr-->
<span class="jpstr">
半開範囲は、あなたが配列のようなゼロに基づくリストを扱うとき特に便利です、そこにおいて、そのリストの長さまで（しかしそれは含まずに）数え上げるのに役に立ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">names</span> = [<span class="s">"Anna"</span>, <span class="s">"Alex"</span>, <span class="s">"Brian"</span>, <span class="s">"Jack"</span>]
</li>
<li>
<span class="k">let</span> <span class="nv">count</span> = <span class="nv">names</span>.<span class="nv">count</span>
</li>
<li>
<span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">count</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Person </span>\<span class="p">(</span><span class="nv">i</span> + <span class="m">1</span><span class="p">)</span><span class="s"> is called </span>\<span class="p">(</span><span class="nv">names</span>[<span class="nv">i</span>]<span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Person 1 is called Anna</span><!--end_enstr--><span class="jpstr">（人物は１、アンナと呼ばれる）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Person 2 is called Alex</span><!--end_enstr--><span class="jpstr">（人物２は、アレックスと呼ばれる）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Person 3 is called Brian</span><!--end_enstr--><span class="jpstr">（人物３は、ブライアンと呼ばれる）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Person 4 is called Jack</span><!--end_enstr--><span class="jpstr">（人物４は、ジャックと呼ばれる）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Note that the array contains four items, but <code class="docutils literal notranslate"><span class="pre">0..&lt;count</span></code> only counts as far as <code class="docutils literal notranslate"><span class="pre">3</span></code> (the index of the last item in the array), because it’s a half-open range. For more about arrays, see <a class="reference internal" href="CollectionTypes.html#ID107"><span class="std std-ref">Arrays</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この配列が４つの項目を含む点に注意してください、しかし<code class="docutils literal notranslate"><span class="pre">0..&lt;count</span></code>は<code class="docutils literal notranslate"><span class="pre">3</span></code>（この配列の最後の項目のインデックス）まで数えるだけです、なぜならそれが半開範囲であるためです。配列に関する詳細は、<a class="reference internal" href="CollectionTypes.html#ID107"><span class="std std-ref">配列</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID562">
<h3><span class="enstr">One-Sided Ranges<a class="headerlink" href="#ID562" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
片側範囲<a class="headerlink" href="#ID562" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a <em>one-sided range</em> because the operator has a value on only one side. For example:</span><!--end_enstr-->
<span class="jpstr">
完結範囲演算子は、一方向に可能な限り続く範囲 — 例えば、インデックス２から配列の最後までの配列のすべての要素を含む範囲、などに対する代替の形式を持ちます。これらの場合、あなたは範囲演算子の１つの側から値を省くことができます。この種類の範囲は、<em>片側範囲</em>と呼ばれます、なぜならこの演算子は一方の側でのみ値を持つからです。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[<span class="m">2</span>...] {
</li>
<li>    <span class="nv">print</span>(<span class="nv">name</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Brian</span>
</li>
<li>
<span class="c">// Jack</span>
</li>
<li>
</li>
<li>
<span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[...<span class="m">2</span>] {
</li>
<li>    <span class="nv">print</span>(<span class="nv">name</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Anna</span>
</li>
<li>
<span class="c">// Alex</span>
</li>
<li>
<span class="c">// Brian</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The half-open range operator also has a one-sided form that’s written with only its final value. Just like when you include a value on both sides, the final value isn’t part of the range. For example:</span><!--end_enstr-->
<span class="jpstr">
半開範囲演算子もまた、それの最後の値のみで記述される、片側形式を持ちます。ちょうどあなたが両方の側で１つの値を含める場合のように、最後の値はその範囲の一部分ではありません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">for</span> <span class="nv">name</span> <span class="k">in</span> <span class="nv">names</span>[..&lt;<span class="m">2</span>] {
</li>
<li>    <span class="nv">print</span>(<span class="nv">name</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Anna</span>
</li>
<li>
<span class="c">// Alex</span>
</li>
</ol></div></div></div>
<p><span class="enstr">One-sided ranges can be used in other contexts, not just in subscripts. You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin. You <em>can</em> iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop. You can also check whether a one-sided range contains a particular value, as shown in the code below.</span><!--end_enstr-->
<span class="jpstr">
片側範囲は、添え字とは違い、他の文脈で使用できます。あなたは、最初の値を省いた片側範囲に対して反復していくことができません、なぜならどこで反復が始まるべきかが明瞭でないからです。あなたは、それの最後の値を省いた片側範囲に対して反復処理<em>できます</em>；しかしながら、範囲があいまいに続いていることから、確実にあなたが明示的な終了条件をそのループに対して加えるようにしてください。あなたはまた、以下のコードで示すように、片側範囲が特定の値を含むかどうか調べることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">range</span> = ...<span class="m">5</span>
</li>
<li>
<span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">7</span>)   <span class="c">// false</span>
</li>
<li>
<span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">4</span>)   <span class="c">// true</span>
</li>
<li>
<span class="nv">range</span>.<span class="nv">contains</span>(<span class="m">-1</span>)  <span class="c">// true</span>
</li>
</ol></div></div></div>
</div>
</div>
<div class="section" id="ID76">
<h2><span class="enstr">Logical Operators<a class="headerlink" href="#ID76" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
論理演算子<a class="headerlink" href="#ID76" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Logical operators</em> modify or combine the Boolean logic values <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>. Swift supports the three standard logical operators found in C-based languages:</span><!--end_enstr-->
<span class="jpstr">
<em>論理演算子</em>は、ブールの論理値<code class="docutils literal notranslate"><span class="pre">true</span></code>および<code class="docutils literal notranslate"><span class="pre">false</span></code>を修正または結合します。スウィフトは、Cに基づく言語で見られる３つの標準の論理演算子をサポートします：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Logical NOT (<code class="docutils literal notranslate"><span class="pre">!a</span></code>)</span><!--end_enstr-->
<span class="jpstr">
論理否定（<code class="docutils literal notranslate"><span class="pre">!a</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Logical AND (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
論理積（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Logical OR (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>)</span><!--end_enstr-->
<span class="jpstr">
論理和（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>）
</span><!--end_jpstr-->
</li>
</ul>
<div class="section" id="ID77">
<h3><span class="enstr">Logical NOT Operator<a class="headerlink" href="#ID77" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
論理否定演算子<a class="headerlink" href="#ID77" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>logical NOT operator</em> (<code class="docutils literal notranslate"><span class="pre">!a</span></code>) inverts a Boolean value so that <code class="docutils literal notranslate"><span class="pre">true</span></code> becomes <code class="docutils literal notranslate"><span class="pre">false</span></code>, and <code class="docutils literal notranslate"><span class="pre">false</span></code> becomes <code class="docutils literal notranslate"><span class="pre">true</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>論理否定演算子</em>（<code class="docutils literal notranslate"><span class="pre">!a</span></code>）は１つのブール値を逆にします、それで<code class="docutils literal notranslate"><span class="pre">true</span></code>は<code class="docutils literal notranslate"><span class="pre">false</span></code>に、<code class="docutils literal notranslate"><span class="pre">false</span></code>は<code class="docutils literal notranslate"><span class="pre">true</span></code>になります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. It can be read as “not <code class="docutils literal notranslate"><span class="pre">a</span></code>”, as seen in the following example:</span><!--end_enstr-->
<span class="jpstr">
論理否定演算子は接頭辞演算子です、そして全く空白なしで、それが作用する値の直前に現れます。それは、「<code class="docutils literal notranslate"><span class="pre">a</span></code>でない」のように読まれることができます、下記の例では見られるように：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">allowedEntry</span> = <span class="k">false</span>
</li>
<li>
<span class="k">if</span> !<span class="nv">allowedEntry</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "ACCESS DENIED"</span><!--end_enstr--><span class="jpstr">（「アクセス拒否」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The phrase <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">!allowedEntry</span></code> can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if <code class="docutils literal notranslate"><span class="pre">allowedEntry</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</span><!--end_enstr-->
<span class="jpstr">
語句<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">!allowedEntry</span></code>は、「許されたエントリでないならば」と読まれることができます。続く行は「許されたエントリでない」が真である場合；すなわち、<code class="docutils literal notranslate"><span class="pre">allowedEntry</span></code>が<code class="docutils literal notranslate"><span class="pre">false</span></code>である場合に実行されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</span><!--end_enstr-->
<span class="jpstr">
この例の場合のように、ブールの定数と変数の名前の慎重な選択はコードを読みやすく簡潔にしておくのを助けることができます、その一方で、二重の否定や、混乱させる論理文を避けてください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID78">
<h3><span class="enstr">Logical AND Operator<a class="headerlink" href="#ID78" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
論理積演算子<a class="headerlink" href="#ID78" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>logical AND operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>) creates logical expressions where both values must be <code class="docutils literal notranslate"><span class="pre">true</span></code> for the overall expression to also be <code class="docutils literal notranslate"><span class="pre">true</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>論理積演算子</em>（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code>）は、論理式をつくります、そこにおいて全体的な式もまた<code class="docutils literal notranslate"><span class="pre">true</span></code>になるためには、両方の値が<code class="docutils literal notranslate"><span class="pre">true</span></code>でなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If either value is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the overall expression will also be <code class="docutils literal notranslate"><span class="pre">false</span></code>. In fact, if the <em>first</em> value is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to <code class="docutils literal notranslate"><span class="pre">true</span></code>. This is known as <em>short-circuit evaluation</em>.</span><!--end_enstr-->
<span class="jpstr">
どちらかの値が<code class="docutils literal notranslate"><span class="pre">false</span></code>ならば、全体的な式もまた<code class="docutils literal notranslate"><span class="pre">false</span></code>になります。実際には、<em>最初の</em>値が<code class="docutils literal notranslate"><span class="pre">false</span></code>ならば、２番目の値は評価されさえしません、なぜならそれがどうやっても式全体を<code class="docutils literal notranslate"><span class="pre">true</span></code>と等しくすることが出来ないためです。これは<em>短絡評価</em>として知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example considers two <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values and only allows access if both values are <code class="docutils literal notranslate"><span class="pre">true</span></code>:</span><!--end_enstr-->
<span class="jpstr">
この例は、２つの<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値を考慮して、両方の値が<code class="docutils literal notranslate"><span class="pre">true</span></code>の場合にのみアクセスを許します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">enteredDoorCode</span> = <span class="k">true</span>
</li>
<li>
<span class="k">let</span> <span class="nv">passedRetinaScan</span> = <span class="k">false</span>
</li>
<li>
<span class="k">if</span> <span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "ACCESS DENIED"</span><!--end_enstr--><span class="jpstr">（「アクセス拒否」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID79">
<h3><span class="enstr">Logical OR Operator<a class="headerlink" href="#ID79" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
論理和演算子<a class="headerlink" href="#ID79" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>logical OR operator</em> (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>) is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only <em>one</em> of the two values has to be <code class="docutils literal notranslate"><span class="pre">true</span></code> for the overall expression to be <code class="docutils literal notranslate"><span class="pre">true</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>論理和演算子</em>（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">||</span> <span class="pre">b</span></code>）は、２つの隣接したパイプ文字から作られる接中辞演算子です。あなたはそれを、全体的な式が<code class="docutils literal notranslate"><span class="pre">true</span></code>になるためには２つの値のうちの<em>１つ</em>だけが<code class="docutils literal notranslate"><span class="pre">true</span></code>であればよい論理式をつくるために使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions. If the left side of a Logical OR expression is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the right side isn’t evaluated, because it can’t change the outcome of the overall expression.</span><!--end_enstr-->
<span class="jpstr">
上の論理積演算子のように、論理和演算子はその式を考慮するために短絡評価を使います。論理和式の左側が<code class="docutils literal notranslate"><span class="pre">true</span></code>ならば、右側は評価されません、なぜならそれが式全体の結論を変えることができないからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In the example below, the first <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value (<code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>) is <code class="docutils literal notranslate"><span class="pre">false</span></code>, but the second value (<code class="docutils literal notranslate"><span class="pre">knowsOverridePassword</span></code>) is <code class="docutils literal notranslate"><span class="pre">true</span></code>. Because one value is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the overall expression also evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, and access is allowed:</span><!--end_enstr-->
<span class="jpstr">
下記の例で、最初の<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値（<code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>）は<code class="docutils literal notranslate"><span class="pre">false</span></code>です、しかし、第二の値（<code class="docutils literal notranslate"><span class="pre">knowsOverridePassword</span></code>）は<code class="docutils literal notranslate"><span class="pre">true</span></code>です。１つの値が<code class="docutils literal notranslate"><span class="pre">true</span></code>なので、式全体もまた<code class="docutils literal notranslate"><span class="pre">true</span></code>です、そしてアクセスは許可されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">hasDoorKey</span> = <span class="k">false</span>
</li>
<li>
<span class="k">let</span> <span class="nv">knowsOverridePassword</span> = <span class="k">true</span>
</li>
<li>
<span class="k">if</span> <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "Welcome!"</span><!--end_enstr--><span class="jpstr">（「歓迎します！」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID80">
<h3><span class="enstr">Combining Logical Operators<a class="headerlink" href="#ID80" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
論理演算子を結合する<a class="headerlink" href="#ID80" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can combine multiple logical operators to create longer compound expressions:</span><!--end_enstr-->
<span class="jpstr">
あなたは、より長く複雑な式をつくるために複数の論理演算子を結合することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span> || <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "Welcome!"</span><!--end_enstr--><span class="jpstr">（「歓迎します！」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">This example uses multiple <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> operators to create a longer compound expression. However, the <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> operators still operate on only two values, so this is actually three smaller expressions chained together. The example can be read as:</span><!--end_enstr-->
<span class="jpstr">
この例は、より長く複雑な式をつくるために複数の<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>と<code class="docutils literal notranslate"><span class="pre">||</span></code>演算子を使用します。しかし、<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>と<code class="docutils literal notranslate"><span class="pre">||</span></code>演算子は依然として２つの値だけに作用します、なのでこれは実際のところ１つに繋がれた３つのより小さい式です。この例は、次のように解釈されることができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</span><!--end_enstr-->
<span class="jpstr">
私達が正しいドア・コードを入力して網膜走査をパスしたならば、または私達が有効なドア・キーを持つならば、または私達が非常用解除パスワードを知っているならば、その時アクセスを許可してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Based on the values of <code class="docutils literal notranslate"><span class="pre">enteredDoorCode</span></code>, <code class="docutils literal notranslate"><span class="pre">passedRetinaScan</span></code>, and <code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>, the first two subexpressions are <code class="docutils literal notranslate"><span class="pre">false</span></code>. However, the emergency override password is known, so the overall compound expression still evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">enteredDoorCode</span></code>、<code class="docutils literal notranslate"><span class="pre">passedRetinaScan</span></code>、そして<code class="docutils literal notranslate"><span class="pre">hasDoorKey</span></code>の値に基づいて、最初の２つの下位の式は<code class="docutils literal notranslate"><span class="pre">false</span></code>です。しかし、非常用解除パスワードは知られているので、複合式全体はなお<code class="docutils literal notranslate"><span class="pre">true</span></code>と評価します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The Swift logical operators <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">||</span></code> are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの論理演算子<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>と<code class="docutils literal notranslate"><span class="pre">||</span></code>は、左結合です、複数の論理演算子を持つ複合式が最も左の下位の式を最初に評価することを意味しています。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID81">
<h3><span class="enstr">Explicit Parentheses<a class="headerlink" href="#ID81" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
明確な括弧<a class="headerlink" href="#ID81" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read. In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:</span><!--end_enstr-->
<span class="jpstr">
複雑な式をより簡単に読めるようにするため、丸括弧をそれらが厳密には必要とされないとき含むことは、時々役に立ちます。上のドア・アクセスの例で、その意図を明確にするために複合式の最初の部分のまわりに丸括弧を加えることは、役に立ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> (<span class="nv">enteredDoorCode</span> &amp;&amp; <span class="nv">passedRetinaScan</span>) || <span class="nv">hasDoorKey</span> || <span class="nv">knowsOverridePassword</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Welcome!"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"ACCESS DENIED"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "Welcome!"</span><!--end_enstr--><span class="jpstr">（「歓迎します！」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic. The output of the compound expression doesn’t change, but the overall intention is clearer to the reader. Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</span><!--end_enstr-->
<span class="jpstr">
丸括弧は、最初の２つの値が全体的な論理の中で１つの隔てられたあり得る状態の部分として考慮されることを明白にします。複合式の出力は変わりません、しかし全体的な意図は読者にとってより明らかです。読みやすさは、常に簡潔さよりも好まれます；それらがあなたの意図を明確にする助けとなるところに丸括弧を使ってください。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
