

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Closures — The Swift Programming Language (Swift 5)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumeration</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID95"><span class="enstr">Closure Expressions</span><!--end_enstr-->
<span class="jpstr">
クロージャ式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID96"><span class="enstr">The Sorted Method</span><!--end_enstr-->
<span class="jpstr">
分類メソッド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID97"><span class="enstr">Closure Expression Syntax</span><!--end_enstr-->
<span class="jpstr">
クロージャ式構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID98"><span class="enstr">Inferring Type From Context</span><!--end_enstr-->
<span class="jpstr">
文脈から型を推論する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID99"><span class="enstr">Implicit Returns from Single-Expression Closures</span><!--end_enstr-->
<span class="jpstr">
単一式のクロージャからの値を暗黙的に返す
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID100"><span class="enstr">Shorthand Argument Names</span><!--end_enstr-->
<span class="jpstr">
短縮形引数名
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID101"><span class="enstr">Operator Methods</span><!--end_enstr-->
<span class="jpstr">
演算子メソッド
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID102"><span class="enstr">Trailing Closures</span><!--end_enstr-->
<span class="jpstr">
後付クロージャ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID103"><span class="enstr">Capturing Values</span><!--end_enstr-->
<span class="jpstr">
値を捕獲する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID104"><span class="enstr">Closures Are Reference Types</span><!--end_enstr-->
<span class="jpstr">
クロージャは参照型です
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID546"><span class="enstr">Escaping Closures</span><!--end_enstr-->
<span class="jpstr">
脱出クロージャ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID543"><span class="enstr">Autoclosures</span><!--end_enstr-->
<span class="jpstr">
自動クロージャ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="closures">
<h1><span class="enstr">Closures<a class="headerlink" href="#closures" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャ<a class="headerlink" href="#closures" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr"><em>Closures</em> are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</span><!--end_enstr-->
<span class="jpstr">
<em>クロージャ</em>は、機能性の完全独立のブロック、かたまりです、それは、あなたのコードにおいてあちこちに渡され使われることができます。スウィフトにおけるクロージャは、CとObjective-Cでのブロックに、そして他のプログラミング言語でのラムダ（lambda）に似ています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as <em>closing over</em> those constants and variables. Swift handles all of the memory management of capturing for you.</span><!--end_enstr-->
<span class="jpstr">
クロージャは、それが定義されている前後関係からのあらゆる定数や変数への参照を捕獲して、格納することができます。これは、そのような定数や変数を<em>すっかりクローズする（閉じ込める）</em>こととして知られています。スウィフトは、キャプチャ（その瞬間の保存）の記憶管理の全てを、あなたのために取り扱います。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Don’t worry if you are not familiar with the concept of capturing. It is explained in detail below in <a class="reference internal" href="#ID103"><span class="std std-ref">Capturing Values</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがキャプチャの概念に馴染みがなくても、心配いりません。それは、下で詳細に<a class="reference internal" href="#ID103"><span class="std std-ref">値を捕獲する（キャプチャする）</span></a>の中で説明されます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Global and nested functions, as introduced in <a class="reference internal" href="Functions.html"><span class="doc">Functions</span></a>, are actually special cases of closures. Closures take one of three forms:</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="Functions.html"><span class="doc">関数</span></a>で紹介される、グローバルおよび入れ子にされた関数は、実際にはクロージャの特別な場合です。クロージャは、３つの書式のうちの１つをとります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Global functions are closures that have a name and do not capture any values.</span><!--end_enstr-->
<span class="jpstr">
グローバルな関数は、名前を持ち、まったく値をキャプチャしない（捕獲しない）クロージャです。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Nested functions are closures that have a name and can capture values from their enclosing function.</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた関数は、名前を持ち、それを囲んでいる関数から値を捕獲することができるクロージャです。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</span><!--end_enstr-->
<span class="jpstr">
クロージャ式は、それの周囲の前後関係から値を捕獲することができる軽快な構文で書かれる無名のクロージャです。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</span><!--end_enstr-->
<span class="jpstr">
スウィフトのクロージャ式は、最適化された、きれいな、明白なスタイルを持ちます、それは、通常さまざまに予想される状況において、簡潔な、混乱のない構文を助長します。これらの最適化は、以下を含みます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Inferring parameter and return value types from context</span><!--end_enstr-->
<span class="jpstr">
前後関係からパラメータおよび戻り値の型を推論する
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Implicit returns from single-expression closures</span><!--end_enstr-->
<span class="jpstr">
単一式のクロージャからの値を暗黙的に返す
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Shorthand argument names</span><!--end_enstr-->
<span class="jpstr">
短縮形引数名
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Trailing closure syntax</span><!--end_enstr-->
<span class="jpstr">
後付クロージャ構文
</span><!--end_jpstr-->
</li>
</ul>
<div class="section" id="ID95">
<h2><span class="enstr">Closure Expressions<a class="headerlink" href="#ID95" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
さまざまなクロージャ式<a class="headerlink" href="#ID95" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Nested functions, as introduced in <a class="reference internal" href="Functions.html#ID178"><span class="std std-ref">Nested Functions</span></a>, are a convenient means of naming and defining self-contained blocks of code as part of a larger function. However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name. This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="Functions.html#ID178"><span class="std std-ref">入れ子にされた関数</span></a>は、入れ子にされた関数の中で紹介されるように、より大きい関数の一部として、いろいろな完全独立のコードの塊を名前をつけて定義する便利な手段です。しかし、まるまる完全な宣言や名前なしに、関数のような構造物のより短いものをいろいろと書くことは、時々役に立ちます。１つ以上のそれの引数として関数をとる関数またはメソッドをあなたが扱うとき、これは特に当てはまります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><em>Closure expressions</em> are a way to write inline closures in a brief, focused syntax. Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent. The closure expression examples below illustrate these optimizations by refining a single example of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method over several iterations, each of which expresses the same functionality in a more succinct way.</span><!--end_enstr-->
<span class="jpstr">
<em>クロージャ式</em>は、簡潔な、焦点のあった構文で、処理の流れに組み込まれた（行内の、インラインの）クロージャを書く方法です。クロージャ式は、いくつかの構文最適化を、ある省略形式で明快さや意図の損失なしでクロージャを書くために提供します。以下のクロージャ式の例は、これらの最適化を１つの例の<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドの改良をいくどか繰り返していくことで解説します、そして、そのそれぞれは同じ機能性をより簡潔な方法で表わします。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID96">
<h3><span class="enstr">The Sorted Method<a class="headerlink" href="#ID96" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
分類メソッド<a class="headerlink" href="#ID96" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Swift’s standard library provides a method called <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>, which sorts an array of values of a known type, based on the output of a sorting closure that you provide. Once it completes the sorting process, the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method returns a new array of the same type and size as the old one, with its elements in the correct sorted order. The original array is not modified by the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの標準ライブラリは<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>と呼ばれるメソッドを提供します、それは、ある既知の型の値からなる配列の分類を、あなたが提供するあるソート（分類）を行うクロージャの出力に基づき行います。一旦それがソート処理を完了するならば、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドは、古いものと同じ型と大きさの新しい配列を返します、そしてその要素は正しく分類された順序を持ちます。元の配列は、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドによって修正されません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The closure expression examples below use the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method to sort an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values in reverse alphabetical order. Here’s the initial array to be sorted:</span><!--end_enstr-->
<span class="jpstr">
下のクロージャ式の例は、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドを使用して<code class="docutils literal notranslate"><span class="pre">String</span></code>値からなる配列を逆アルファベット順に分類します。分類される最初の配列は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">names</span> = [<span class="s">"Chris"</span>, <span class="s">"Alex"</span>, <span class="s">"Ewa"</span>, <span class="s">"Barry"</span>, <span class="s">"Daniella"</span>]
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value to say whether the first value should appear before or after the second value once the values are sorted. The sorting closure needs to return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the first value should appear <em>before</em> the second value, and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドは、配列の内容物と同じ型の２つの引数をとり、そしてひとたび値が分類されるならば最初の値が第２の値の前か後のどちらに現れなければならないのかを伝える<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値を返すクロージャを受け取ります。このソートを行うクロージャは、最初の値が第２の値の<em>前に</em>現れるべきならば<code class="docutils literal notranslate"><span class="pre">true</span></code>を、そうでないならば<code class="docutils literal notranslate"><span class="pre">false</span></code>を返す必要があります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example is sorting an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values, and so the sorting closure needs to be a function of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例は<code class="docutils literal notranslate"><span class="pre">String</span></code>値の配列を分類しています、なのでソート・クロージャは型<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>の関数である必要があります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method:</span><!--end_enstr-->
<span class="jpstr">
ソート・クロージャを提供する１つの方法は、通常の関数を正しい型で記述することです、そしてそれを１つの引数として<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドに渡すことになります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">backward</span>(<span class="k">_</span> <span class="nv">s1</span>: <span class="nc">String</span>, <span class="k">_</span> <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> {
</li><li>    <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: <span class="nv">backward</span>)
</li><li><span class="c"><span class="enstr">// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span><!--end_enstr--><span class="jpstr">（reversedNamesは["Ewa", "Daniella", "Chris", "Barry", "Alex"]に等しい）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">If the first string (<code class="docutils literal notranslate"><span class="pre">s1</span></code>) is greater than the second string (<code class="docutils literal notranslate"><span class="pre">s2</span></code>), the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function will return <code class="docutils literal notranslate"><span class="pre">true</span></code>, indicating that <code class="docutils literal notranslate"><span class="pre">s1</span></code> should appear before <code class="docutils literal notranslate"><span class="pre">s2</span></code> in the sorted array. For characters in strings, “greater than” means “appears later in the alphabet than”. This means that the letter <code class="docutils literal notranslate"><span class="pre">"B"</span></code> is “greater than” the letter <code class="docutils literal notranslate"><span class="pre">"A"</span></code>, and the string <code class="docutils literal notranslate"><span class="pre">"Tom"</span></code> is greater than the string <code class="docutils literal notranslate"><span class="pre">"Tim"</span></code>. This gives a reverse alphabetical sort, with <code class="docutils literal notranslate"><span class="pre">"Barry"</span></code> being placed before <code class="docutils literal notranslate"><span class="pre">"Alex"</span></code>, and so on.</span><!--end_enstr-->
<span class="jpstr">
最初の文字列（<code class="docutils literal notranslate"><span class="pre">s1</span></code>）が第二の文字列（<code class="docutils literal notranslate"><span class="pre">s2</span></code>）より大きいならば、<code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code>関数は、ソートされた配列において<code class="docutils literal notranslate"><span class="pre">s1</span></code>が<code class="docutils literal notranslate"><span class="pre">s2</span></code>の前に現れなければならないことを示す、<code class="docutils literal notranslate"><span class="pre">true</span></code>を返します。文字列の中の文字のために、「より大きい」は「アルファベットにおいてより後に現れる」ことを意味します。これは文字<code class="docutils literal notranslate"><span class="pre">"B"</span></code>は文字<code class="docutils literal notranslate"><span class="pre">"A"</span></code>「より大きい」こと、そして文字列<code class="docutils literal notranslate"><span class="pre">"Tom"</span></code>は文字列<code class="docutils literal notranslate"><span class="pre">"Tim"</span></code>よりも大きいことを意味します。これは、<code class="docutils literal notranslate"><span class="pre">"Barry"</span></code>が<code class="docutils literal notranslate"><span class="pre">"Alex"</span></code>の前に置かれるなどの、逆アルファベット順の分類を提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, this is a rather long-winded way to write what is essentially a single-expression function (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>). In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</span><!--end_enstr-->
<span class="jpstr">
しかし、これは本質的に単一式の関数（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code>）であるものを書くには、相当に長たらしい方法です。この例では、クロージャ式構文を使って、ソート・クロージャを行内に書くことがずっと好ましいです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID97">
<h3><span class="enstr">Closure Expression Syntax<a class="headerlink" href="#ID97" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャ式構文<a class="headerlink" href="#ID97" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Closure expression syntax has the following general form:</span><!--end_enstr-->
<span class="jpstr">
クロージャ式構文は、以下の一般的な形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>{ (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> <span class="k">in</span>
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <em>parameters</em> in closure expression syntax can be in-out parameters, but they can’t have a default value. Variadic parameters can be used if you name the variadic parameter. Tuples can also be used as parameter types and return types.</span><!--end_enstr-->
<span class="jpstr">
クロージャ式構文中の<em>parameters</em>はin-outパラメータであることができます、しかしそれらは省略時の値を持つことはできません。あなたが可変長パラメータに名前をつけるならば、可変長パラメータが使われることができます。タプルもまた、パラメータ型および戻り型として使われることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below shows a closure expression version of the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function from above:</span><!--end_enstr-->
<span class="jpstr">
下記の例は、上の<code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code>関数のクロージャ式版を示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { (<span class="nv">s1</span>: <span class="nc">String</span>, <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> <span class="k">in</span>
</li><li>    <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span>
</li><li>})
</li></ol></div></div></div>
<p><span class="enstr">Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the <code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code> function. In both cases, it is written as <code class="docutils literal notranslate"><span class="pre">(s1:</span> <span class="pre">String,</span> <span class="pre">s2:</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. However, for the inline closure expression, the parameters and return type are written <em>inside</em> the curly braces, not outside of them.</span><!--end_enstr-->
<span class="jpstr">
行内クロージャのためのパラメータと戻り型の宣言が、<code class="docutils literal notranslate"><span class="pre">backward(_:_:)</span></code>関数の宣言と同一であることに注意してください。両方の場合において、それは<code class="docutils literal notranslate"><span class="pre">(s1:</span> <span class="pre">String,</span> <span class="pre">s2:</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>のように書かれます。しかし、行内クロージャ式のために、パラメータと戻り型は、波括弧の<em>内側</em>に書かれます、その外側ではなく。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The start of the closure’s body is introduced by the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword. This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</span><!--end_enstr-->
<span class="jpstr">
クロージャのもつ本文の始まりは、<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードで紹介されます。このキーワードはクロージャのパラメータと戻り型の定義が終わったことを示します、そして、クロージャの本文はまさに開始しようとしています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because the body of the closure is so short, it can even be written on a single line:</span><!--end_enstr-->
<span class="jpstr">
クロージャの本文がたいへん短いので、それは１つの行に書かれさえすることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { (<span class="nv">s1</span>: <span class="nc">String</span>, <span class="nv">s2</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p><span class="enstr">This illustrates that the overall call to the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method has remained the same. A pair of parentheses still wrap the entire argument for the method. However, that argument is now an inline closure.</span><!--end_enstr-->
<span class="jpstr">
これは、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドへの呼び出し全体が、同じもののままだったことを図解します。一対の丸括弧は、依然としてこのメソッドに対する引数をすべて包みます。しかしながら、この引数は今では１つの行内クロージャです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID98">
<h3><span class="enstr">Inferring Type From Context<a class="headerlink" href="#ID98" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
文脈から型を推論する<a class="headerlink" href="#ID98" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns. The <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method is being called on an array of strings, so its argument must be a function of type <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. This means that the <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span></code> and <code class="docutils literal notranslate"><span class="pre">Bool</span></code> types do not need to be written as part of the closure expression’s definition. Because all of the types can be inferred, the return arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) and the parentheses around the names of the parameters can also be omitted:</span><!--end_enstr-->
<span class="jpstr">
ソート（分類）するクロージャが引数としてメソッドに渡されるので、スウィフトは、それのパラメータの型とそれが返す値の型を推論することができます。この<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドは文字列の配列上で呼ばれています、それでそれの引数は型<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>の関数でなければなりません。これは、<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">String)</span></code>および<code class="docutils literal notranslate"><span class="pre">Bool</span></code>型が、クロージャ式の定義の一部として書かれる必要がないことを意味します。型の全てが推論されることができるので、戻り矢印（<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>）と、パラメータの名前のまわりの丸括弧もまた省略することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">s1</span>, <span class="nv">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p><span class="enstr">It is always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</span><!--end_enstr-->
<span class="jpstr">
クロージャを関数やメソッドに行内クロージャ式として渡すとき、パラメータ型と戻り型を推論することは常に可能です。その結果、あなたは、行内クロージャをその最も完全な形式で書くことは、そのクロージャが関数やメソッドの引数として使われる時にまったく必要ありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code. In the case of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method, the purpose of the closure is clear from the fact that sorting is taking place, and it is safe for a reader to assume that the closure is likely to be working with <code class="docutils literal notranslate"><span class="pre">String</span></code> values, because it is assisting with the sorting of an array of strings.</span><!--end_enstr-->
<span class="jpstr">
それでもなお、あなたが望むならば、依然としてあなたは型を明確にすることができます、そして、それがあなたのコードの読者のために曖昧さを避けるならば、そうすることは推奨されます。<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドの場合、クロージャの目的はソートが行われているという事実から明快です、そして、読者がクロージャは<code class="docutils literal notranslate"><span class="pre">String</span></code>値を扱っているようだと仮定しても差し支えありません、なぜならそれがいくつかの文字列からなる配列のソートを手伝っているからです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID99">
<h3><span class="enstr">Implicit Returns from Single-Expression Closures<a class="headerlink" href="#ID99" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
単一式のクロージャからの値を暗黙的に返す<a class="headerlink" href="#ID99" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Single-expression closures can implicitly return the result of their single expression by omitting the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword from their declaration, as in this version of the previous example:</span><!--end_enstr-->
<span class="jpstr">
単一の式のクロージャは、前の例のこの改作のように、<code class="docutils literal notranslate"><span class="pre">return</span></code>キーワードをそれらの宣言から省略することによって、暗黙的にそれのただ１つの式の結果を返すことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">s1</span>, <span class="nv">s2</span> <span class="k">in</span> <span class="nv">s1</span> &gt; <span class="nv">s2</span> } )
</li></ol></div></div></div>
<p><span class="enstr">Here, the function type of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method’s argument makes it clear that a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value must be returned by the closure. Because the closure’s body contains a single expression (<code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">&gt;</span> <span class="pre">s2</span></code>) that returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value, there is no ambiguity, and the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword can be omitted.</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドの引数である関数型は、<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値がクロージャによって返されなければならないことを明白にします。クロージャの本文がある単一の式（<code class="docutils literal notranslate"><span class="pre">s1</span> <span class="pre">&gt;</span> <span class="pre">s2</span></code>）で<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値を返すものを含むので、曖昧さはありません、それで<code class="docutils literal notranslate"><span class="pre">return</span></code>キーワードは省略されることができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID100">
<h3><span class="enstr">Shorthand Argument Names<a class="headerlink" href="#ID100" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
短縮形引数名<a class="headerlink" href="#ID100" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names <code class="docutils literal notranslate"><span class="pre">$0</span></code>, <code class="docutils literal notranslate"><span class="pre">$1</span></code>, <code class="docutils literal notranslate"><span class="pre">$2</span></code>, and so on.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは行内クロージャに自動的に短縮形引数名を提供します、そしてそれは、名前<code class="docutils literal notranslate"><span class="pre">$0</span></code>、<code class="docutils literal notranslate"><span class="pre">$1</span></code>、<code class="docutils literal notranslate"><span class="pre">$2</span></code>、などにでクロージャの引数の値に言及するために使われることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type. The <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword can also be omitted, because the closure expression is made up entirely of its body:</span><!--end_enstr-->
<span class="jpstr">
あなたがこれらの短縮形引数名をあなたのクロージャ式の中で使用するならば、あなたはクロージャの引数リストをその定義から省略することができます、そして、短縮形引数名の数と型は期待される関数型から推論されます。<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードもまた、クロージャ式がもっぱらその本文から成り立つので、省略されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: { <span class="nv">$0</span> &gt; <span class="nv">$1</span> } )
</li></ol></div></div></div>
<p><span class="enstr">Here, <code class="docutils literal notranslate"><span class="pre">$0</span></code> and <code class="docutils literal notranslate"><span class="pre">$1</span></code> refer to the closure’s first and second <code class="docutils literal notranslate"><span class="pre">String</span></code> arguments.</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">$0</span></code>と<code class="docutils literal notranslate"><span class="pre">$1</span></code>は、クロージャの１番目と２番目の<code class="docutils literal notranslate"><span class="pre">String</span></code>引数に言及します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID101">
<h3><span class="enstr">Operator Methods<a class="headerlink" href="#ID101" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
演算子メソッド<a class="headerlink" href="#ID101" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">There’s actually an even <em>shorter</em> way to write the closure expression above. Swift’s <code class="docutils literal notranslate"><span class="pre">String</span></code> type defines its string-specific implementation of the greater-than operator (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) as a method that has two parameters of type <code class="docutils literal notranslate"><span class="pre">String</span></code>, and returns a value of type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. This exactly matches the method type needed by the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</span><!--end_enstr-->
<span class="jpstr">
さらに<em>より短い</em>方法が上のクロージャ式を書くために実際にあります。スウィフトの<code class="docutils literal notranslate"><span class="pre">String</span></code>型は、それの文字列特有の実装の「大なり」演算子（<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>）をメソッドとして定義します、それは型<code class="docutils literal notranslate"><span class="pre">String</span></code>の２つのパラメータを持ち、型<code class="docutils literal notranslate"><span class="pre">Bool</span></code>の値を返します。これは、<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>メソッドによって必要とされるメソッド型に正確に適合します。したがって、あなたはただ単に「大なり」演算子を渡すことができます、そしてスウィフトはあなたがその文字列特有の実装を使いたいのだと推測します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>(<span class="nv">by</span>: &gt;)
</li></ol></div></div></div>
<p><span class="enstr">For more about operator method, see <a class="reference internal" href="AdvancedOperators.html#ID42"><span class="std std-ref">Operator Methods</span></a>.</span><!--end_enstr-->
<span class="jpstr">
演算子メソッドについてさらに、<a class="reference internal" href="AdvancedOperators.html#ID42"><span class="std std-ref">演算子メソッド</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID102">
<h2><span class="enstr">Trailing Closures<a class="headerlink" href="#ID102" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
後付クロージャ<a class="headerlink" href="#ID102" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a <em>trailing closure</em> instead. A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</span><!--end_enstr-->
<span class="jpstr">
あなたが関数の最後の引数としてクロージャ式を関数に渡す必要がある、そして、クロージャ式が長いならば、代わりに<em>後付クロージャ</em>としてそれを書くことは役に立つことがありえます。後付クロージャは、関数呼び出しの丸括弧の後に書かれます、それでもそれはまだその関数に対する引数であるけれども。あなたが後付クロージャ構文を使うとき、あなたは引数ラベルをそのクロージャに対して関数呼び出しの一部として書きません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunctionThatTakesAClosure</span>(<span class="nv">closure</span>: () -&gt; <span class="nc">Void</span>) {
</li><li>    <span class="c"><span class="enstr">// function body goes here</span><!--end_enstr--><span class="jpstr">（関数本文が、ここにきます）</span><!--end_jpstr--></span>
</li><li>}
</li><li>
</li><li><span class="c"><span class="enstr">// Here's how you call this function without using a trailing closure:</span><!--end_enstr--><span class="jpstr">（あなたが後付クロージャを使うことなくどのようにこの関数を呼ぶのかがここにあります：）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">someFunctionThatTakesAClosure</span>(<span class="nv">closure</span>: {
</li><li>    <span class="c"><span class="enstr">// closure's body goes here</span><!--end_enstr--><span class="jpstr">（クロージャの本文がここにきます）</span><!--end_jpstr--></span>
</li><li>})
</li><li>
</li><li><span class="c"><span class="enstr">// Here's how you call this function with a trailing closure instead:</span><!--end_enstr--><span class="jpstr">（あなたが代わりに後付クロージャでどのようにこの関数を呼ぶのかがここにあります：）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">someFunctionThatTakesAClosure</span>() {
</li><li>    <span class="c"><span class="enstr">// trailing closure's body goes here</span><!--end_enstr--><span class="jpstr">（後付クロージャの本文がここにきます）</span><!--end_jpstr--></span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The string-sorting closure from the <a class="reference internal" href="#ID97"><span class="std std-ref">Closure Expression Syntax</span></a> section above can be written outside of the <code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code> method’s parentheses as a trailing closure:</span><!--end_enstr-->
<span class="jpstr">
上の<a class="reference internal" href="#ID97"><span class="std std-ref">クロージャ式構文</span></a>の節の文字列を分類するクロージャは、後付クロージャとして<code class="docutils literal notranslate"><span class="pre">sorted(by:)</span></code>関数の括弧の外側に書かれることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span>() { <span class="nv">$0</span> &gt; <span class="nv">$1</span> }
</li></ol></div></div></div>
<p><span class="enstr">If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> after the function or method’s name when you call the function:</span><!--end_enstr-->
<span class="jpstr">
あるクロージャ式がただ関数やメソッドの引数としてだけ提供され、そしてあなたが後付クロージャとしてその式を提供するならば、あなたがその関数を呼ぶときに、一対の丸括弧<code class="docutils literal notranslate"><span class="pre">()</span></code>を関数やメソッドの名前の後に書く必要はありません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reversedNames</span> = <span class="nv">names</span>.<span class="nv">sorted</span> { <span class="nv">$0</span> &gt; <span class="nv">$1</span> }
</li></ol></div></div></div>
<p><span class="enstr">Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line. As an example, Swift’s <code class="docutils literal notranslate"><span class="pre">Array</span></code> type has a <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method which takes a closure expression as its single argument. The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item. The nature of the mapping and the type of the returned value is left up to the closure to specify.</span><!--end_enstr-->
<span class="jpstr">
クロージャがそれをただ１つの行の行内に書くことが可能でないほど長いとき、後付クロージャは最も役に立ちます。例として、スウィフトの<code class="docutils literal notranslate"><span class="pre">Array</span></code>型は<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドを持ちます、そしてそれは、そのただ１つの引数としてクロージャ式をとります。クロージャは、配列の中の各項目に対して一度だけ呼ばれて、その項目のための代わりの対応付けされた（おそらく何か他の型の）値を返します。マッピング（対応付け）の性質と返される値の型は、指定するクロージャに委ねられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">After applying the provided closure to each array element, the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</span><!--end_enstr-->
<span class="jpstr">
提供されたクロージャを各配列要素に適用した後に、<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドは、新しい対応付けられる値の全てを、もとの配列のそれらの対応する値と同じ順序で含んでいる新しい配列を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how you can use the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method with a trailing closure to convert an array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values into an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values. The array <code class="docutils literal notranslate"><span class="pre">[16,</span> <span class="pre">58,</span> <span class="pre">510]</span></code> is used to create the new array <code class="docutils literal notranslate"><span class="pre">["OneSix",</span> <span class="pre">"FiveEight",</span> <span class="pre">"FiveOneZero"]</span></code>:</span><!--end_enstr-->
<span class="jpstr">
ここに、あなたが<code class="docutils literal notranslate"><span class="pre">Int</span></code>値の配列を<code class="docutils literal notranslate"><span class="pre">String</span></code>値の配列に変えるために後付クロージャとともに<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドをどのように使用できるかがあります。配列<code class="docutils literal notranslate"><span class="pre">[16,</span> <span class="pre">58,</span> <span class="pre">510]</span></code>は、新しい配列<code class="docutils literal notranslate"><span class="pre">["OneSix",</span> <span class="pre">"FiveEight",</span> <span class="pre">"FiveOneZero"]</span></code>をつくるために使われます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">digitNames</span> = [
</li><li>    <span class="m">0</span>: <span class="s">"Zero"</span>, <span class="m">1</span>: <span class="s">"One"</span>, <span class="m">2</span>: <span class="s">"Two"</span>,   <span class="m">3</span>: <span class="s">"Three"</span>, <span class="m">4</span>: <span class="s">"Four"</span>,
</li><li>    <span class="m">5</span>: <span class="s">"Five"</span>, <span class="m">6</span>: <span class="s">"Six"</span>, <span class="m">7</span>: <span class="s">"Seven"</span>, <span class="m">8</span>: <span class="s">"Eight"</span>, <span class="m">9</span>: <span class="s">"Nine"</span>
</li><li>]
</li><li><span class="k">let</span> <span class="nv">numbers</span> = [<span class="m">16</span>, <span class="m">58</span>, <span class="m">510</span>]
</li></ol></div></div></div>
<p><span class="enstr">The code above creates a dictionary of mappings between the integer digits and English-language versions of their names. It also defines an array of integers, ready to be converted into strings.</span><!--end_enstr-->
<span class="jpstr">
上のコードは、整数桁とそれらの名前の英語版の間で対応付けをする辞書を作成します。それはまた、文字列に変換される準備ができている整数の配列も定義します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can now use the <code class="docutils literal notranslate"><span class="pre">numbers</span></code> array to create an array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values, by passing a closure expression to the array’s <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method as a trailing closure:</span><!--end_enstr-->
<span class="jpstr">
あなたは、現在、この<code class="docutils literal notranslate"><span class="pre">numbers</span></code>配列を<code class="docutils literal notranslate"><span class="pre">String</span></code>値の配列をつくるために使うことが、あるクロージャ式を配列の<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドに後付クロージャとして渡すことによって、可能です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">strings</span> = <span class="nv">numbers</span>.<span class="nv">map</span> { (<span class="nv">number</span>) -&gt; <span class="nc">String</span> <span class="k">in</span>
</li><li>    <span class="k">var</span> <span class="nv">number</span> = <span class="nv">number</span>
</li><li>    <span class="k">var</span> <span class="nv">output</span> = <span class="s">""</span>
</li><li>    <span class="k">repeat</span> {
</li><li>        <span class="nv">output</span> = <span class="nv">digitNames</span>[<span class="nv">number</span> % <span class="m">10</span>]! + <span class="nv">output</span>
</li><li>        <span class="nv">number</span> /= <span class="m">10</span>
</li><li>    } <span class="k">while</span> <span class="nv">number</span> &gt; <span class="m">0</span>
</li><li>    <span class="k">return</span> <span class="nv">output</span>
</li><li>}
</li><li><span class="c"><span class="enstr">// strings is inferred to be of type [String]</span><!--end_enstr--><span class="jpstr">（stringsは型[String]と推論されます）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// its value is ["OneSix", "FiveEight", "FiveOneZero"]</span><!--end_enstr--><span class="jpstr">（その値は["OneSix", "FiveEight", "FiveOneZero"]です）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method calls the closure expression once for each item in the array. You do not need to specify the type of the closure’s input parameter, <code class="docutils literal notranslate"><span class="pre">number</span></code>, because the type can be inferred from the values in the array to be mapped.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドは、配列の中の各項目に対して一度だけクロージャ式を呼びます。あなたはクロージャの入力パラメータ、<code class="docutils literal notranslate"><span class="pre">number</span></code>の型を指定する必要がありません、なぜならその型が対応付けされる配列の値から推論されることができるからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this example, the variable <code class="docutils literal notranslate"><span class="pre">number</span></code> is initialized with the value of the closure’s <code class="docutils literal notranslate"><span class="pre">number</span></code> parameter, so that the value can be modified within the closure body. (The parameters to functions and closures are always constants.) The closure expression also specifies a return type of <code class="docutils literal notranslate"><span class="pre">String</span></code>, to indicate the type that will be stored in the mapped output array.</span><!--end_enstr-->
<span class="jpstr">
この例では、変数<code class="docutils literal notranslate"><span class="pre">number</span></code>はこのクロージャの持つ<code class="docutils literal notranslate"><span class="pre">number</span></code>パラメータの値を使って初期化されます、それでその値はクロージャ本体の内部で修正されることができます。（関数およびクロージャに対するパラメータは常に定数です。）クロージャ式はまた、<code class="docutils literal notranslate"><span class="pre">String</span></code>の戻り型を指定します、それによってマップされた出力配列の中に格納されることになる型を指し示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The closure expression builds a string called <code class="docutils literal notranslate"><span class="pre">output</span></code> each time it is called. It calculates the last digit of <code class="docutils literal notranslate"><span class="pre">number</span></code> by using the remainder operator (<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code>), and uses this digit to look up an appropriate string in the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary. The closure can be used to create a string representation of any integer greater than zero.</span><!--end_enstr-->
<span class="jpstr">
クロージャ式は、それが呼ばれるたびに、<code class="docutils literal notranslate"><span class="pre">output</span></code>と呼ばれる文字列をつくります。それは、<code class="docutils literal notranslate"><span class="pre">number</span></code>の最後の桁を剰余演算子を使用することによって計算して（<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code>）、この桁を<code class="docutils literal notranslate"><span class="pre">digitNames</span></code>辞書で適切な文字列を捜すために使います。このクロージャは、ゼロより大きいあらゆる整数の文字列表現を作るために使われることが出来ます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The call to the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary’s subscript is followed by an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist. In the example above, it is guaranteed that <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code> will always be a valid subscript key for the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary, and so an exclamation mark is used to force-unwrap the <code class="docutils literal notranslate"><span class="pre">String</span></code> value stored in the subscript’s optional return value.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">digitNames</span></code>辞書への呼び出しの添え字の後に感嘆符（<code class="docutils literal notranslate"><span class="pre">!</span></code>）が続きます、なぜなら、キーが存在しない場合は辞書検索が失敗し得ることを意味するために、辞書添え字がオプショナルの値を返すからです。上の例で<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code>は常に<code class="docutils literal notranslate"><span class="pre">digitNames</span></code>辞書のための有効な添え字キーであることを求められます、なのでその添え字のオプショナルの戻り値に保管した<code class="docutils literal notranslate"><span class="pre">String</span></code>値を強制アンラップするために感嘆符が使われます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The string retrieved from the <code class="docutils literal notranslate"><span class="pre">digitNames</span></code> dictionary is added to the <em>front</em> of <code class="docutils literal notranslate"><span class="pre">output</span></code>, effectively building a string version of the number in reverse. (The expression <code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code> gives a value of <code class="docutils literal notranslate"><span class="pre">6</span></code> for <code class="docutils literal notranslate"><span class="pre">16</span></code>, <code class="docutils literal notranslate"><span class="pre">8</span></code> for <code class="docutils literal notranslate"><span class="pre">58</span></code>, and <code class="docutils literal notranslate"><span class="pre">0</span></code> for <code class="docutils literal notranslate"><span class="pre">510</span></code>.)</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">digitNames</span></code>辞書から取り出される文字列は<code class="docutils literal notranslate"><span class="pre">output</span></code>の<em>前方</em>に加えられて、うまい具合に数の文字列版を逆の順序で造ります。（式数<code class="docutils literal notranslate"><span class="pre">number</span> <span class="pre">%</span> <span class="pre">10</span></code>は、<code class="docutils literal notranslate"><span class="pre">16</span></code>のために<code class="docutils literal notranslate"><span class="pre">6</span></code>、<code class="docutils literal notranslate"><span class="pre">58</span></code>のために<code class="docutils literal notranslate"><span class="pre">8</span></code>、<code class="docutils literal notranslate"><span class="pre">510</span></code>のために<code class="docutils literal notranslate"><span class="pre">0</span></code>の値を与えます）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">number</span></code> variable is then divided by <code class="docutils literal notranslate"><span class="pre">10</span></code>. Because it is an integer, it is rounded down during the division, so <code class="docutils literal notranslate"><span class="pre">16</span></code> becomes <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">58</span></code> becomes <code class="docutils literal notranslate"><span class="pre">5</span></code>, and <code class="docutils literal notranslate"><span class="pre">510</span></code> becomes <code class="docutils literal notranslate"><span class="pre">51</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">number</span></code>変数は、それから<code class="docutils literal notranslate"><span class="pre">10</span></code>で割られます。それが整数であるので、除算のときに端数を切り捨てられます、それで<code class="docutils literal notranslate"><span class="pre">16</span></code>が<code class="docutils literal notranslate"><span class="pre">1</span></code>に、<code class="docutils literal notranslate"><span class="pre">58</span></code>が<code class="docutils literal notranslate"><span class="pre">5</span></code>に、そして<code class="docutils literal notranslate"><span class="pre">510</span></code>は<code class="docutils literal notranslate"><span class="pre">51</span></code>になります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The process is repeated until <code class="docutils literal notranslate"><span class="pre">number</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>, at which point the <code class="docutils literal notranslate"><span class="pre">output</span></code> string is returned by the closure, and is added to the output array by the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method.</span><!--end_enstr-->
<span class="jpstr">
この処理は<code class="docutils literal notranslate"><span class="pre">number</span></code>が<code class="docutils literal notranslate"><span class="pre">0</span></code>に等しくなるまで繰り返されます、その時点で<code class="docutils literal notranslate"><span class="pre">output</span></code>文字列がクロージャによって返されて、そして<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドによって出力配列に加えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the <code class="docutils literal notranslate"><span class="pre">map(_:)</span></code> method’s outer parentheses.</span><!--end_enstr-->
<span class="jpstr">
上の例での後付クロージャ構文の使用は、クロージャの機能性をクロージャが手助けする関数の直後に手際よく要約していて、クロージャ全体を<code class="docutils literal notranslate"><span class="pre">map(_:)</span></code>メソッドの持つ外側の丸括弧の内部に包む必要はありません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID103">
<h2><span class="enstr">Capturing Values<a class="headerlink" href="#ID103" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
値を捕獲する<a class="headerlink" href="#ID103" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">A closure can <em>capture</em> constants and variables from the surrounding context in which it is defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</span><!--end_enstr-->
<span class="jpstr">
クロージャは、それが定義される周囲の前後関係から、定数と変数を<em>捕獲（キャプチャ）</em>できます。クロージャはそれから、その本文内からそれらの定数と変数の値に言及することや修正することができます、たとえその定数と変数を定義した本来のスコープがもはや存在しないとしてもです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function. A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</span><!--end_enstr-->
<span class="jpstr">
スウィフトにおいて、値をキャプチャできるクロージャの最も単純な形式は、別の関数の本文内に書かれる、入れ子にされた関数です。入れ子にされた関数は、その外側の関数の持つ引数の何でも捕獲することができ、また外側の関数の範囲内で定義されるどんな定数や変数でも捕獲することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example of a function called <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>, which contains a nested function called <code class="docutils literal notranslate"><span class="pre">incrementer</span></code>. The nested <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function captures two values, <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code>, from its surrounding context. After capturing these values, <code class="docutils literal notranslate"><span class="pre">incrementer</span></code> is returned by <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> as a closure that increments <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> by <code class="docutils literal notranslate"><span class="pre">amount</span></code> each time it is called.</span><!--end_enstr-->
<span class="jpstr">
ここに、<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>と呼ばれる関数の例があります、それは<code class="docutils literal notranslate"><span class="pre">incrementer</span></code>と呼ばれる入れ子にされた関数を含みます。入れ子にされた<code class="docutils literal notranslate"><span class="pre">incrementer()</span></code>関数は、それを取り囲む前後関係から２つの値、<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>と<code class="docutils literal notranslate"><span class="pre">amount</span></code>を捕獲します。これらの値を捕獲した後に、<code class="docutils literal notranslate"><span class="pre">incrementer</span></code>は<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>によって、それが呼ばれるたびに<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>を<code class="docutils literal notranslate"><span class="pre">amount</span></code>によって増加させるクロージャとして返されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span> <span class="nv">amount</span>: <span class="nc">Int</span>) -&gt; () -&gt; <span class="nc">Int</span> {
</li><li>    <span class="k">var</span> <span class="nv">runningTotal</span> = <span class="m">0</span>
</li><li>    <span class="k">func</span> <span class="nv">incrementer</span>() -&gt; <span class="nc">Int</span> {
</li><li>        <span class="nv">runningTotal</span> += <span class="nv">amount</span>
</li><li>        <span class="k">return</span> <span class="nv">runningTotal</span>
</li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">incrementer</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The return type of <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> is <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. This means that it returns a <em>function</em>, rather than a simple value. The function it returns has no parameters, and returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value each time it is called. To learn how functions can return other functions, see <a class="reference internal" href="Functions.html#ID177"><span class="std std-ref">Function Types as Return Types</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>の戻り型は、<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>です。これは、それが<em>関数</em>を返すことを意味します、単純なひとつの値ではなく。それが返す関数は、パラメータを持たず、それが呼ばれるたびに<code class="docutils literal notranslate"><span class="pre">Int</span></code>値を返します。関数が他の関数を返すことができる方法を学ぶために、<a class="reference internal" href="Functions.html#ID177"><span class="std std-ref">戻り型としての関数型</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code> function defines an integer variable called <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>, to store the current running total of the incrementer that will be returned. This variable is initialized with a value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code>関数は、返されるincrementerの現時点での合計を格納するために、<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>と呼ばれる整数変数を定義します。この変数は、値<code class="docutils literal notranslate"><span class="pre">0</span></code>で初期化されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code> function has a single <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">forIncrement</span></code>, and a parameter name of <code class="docutils literal notranslate"><span class="pre">amount</span></code>. The argument value passed to this parameter specifies how much <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> should be incremented by each time the returned incrementer function is called. The <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> function defines a nested function called <code class="docutils literal notranslate"><span class="pre">incrementer</span></code>, which performs the actual incrementing. This function simply adds <code class="docutils literal notranslate"><span class="pre">amount</span></code> to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>, and returns the result.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">makeIncrementer(forIncrement:)</span></code>関数は、<code class="docutils literal notranslate"><span class="pre">forIncrement</span></code>の引数ラベル、そして<code class="docutils literal notranslate"><span class="pre">amount</span></code>のパラメータ名を持つ、ただ１つの<code class="docutils literal notranslate"><span class="pre">Int</span></code>パラメータを持ちます。このパラメータに渡された引き数の値は、返されたインクリメンタ関数（漸増器関数）が呼ばれるたびに、どのくらい<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>が増やされなければならないかについて指定します。<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>関数は<code class="docutils literal notranslate"><span class="pre">incrementer</span></code>と呼ばれる入れ子にされた関数を定義します、それは、実際に増やすことを実行します。この関数は、単に<code class="docutils literal notranslate"><span class="pre">amount</span></code>を<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>に加えて、結果を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When considered in isolation, the nested <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function might seem unusual:</span><!--end_enstr-->
<span class="jpstr">
切り離して考えたとき、入れ子にされた<code class="docutils literal notranslate"><span class="pre">incrementer()</span></code>関数は普通でないものに見えるかもしれません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">incrementer</span>() -&gt; <span class="nc">Int</span> {
</li><li>    <span class="nv">runningTotal</span> += <span class="nv">amount</span>
</li><li>    <span class="k">return</span> <span class="nv">runningTotal</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">incrementer()</span></code> function doesn’t have any parameters, and yet it refers to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> from within its function body. It does this by capturing a <em>reference</em> to <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> from the surrounding function and using them within its own function body. Capturing by reference ensures that <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> and <code class="docutils literal notranslate"><span class="pre">amount</span></code> do not disappear when the call to <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> ends, and also ensures that <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> is available the next time the <code class="docutils literal notranslate"><span class="pre">incrementer</span></code> function is called.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">incrementer()</span></code>関数には全くパラメータがありません、それなのに、それはその関数本文内から<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>と<code class="docutils literal notranslate"><span class="pre">amount</span></code>に言及します。それは、それを囲んでいる関数から<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>と<code class="docutils literal notranslate"><span class="pre">amount</span></code>への<em>参照</em>を捕獲して、それらをそれ自身の関数本文内で使うことによってこれを行います。参照を捕獲することは、<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>への呼び出しが終わる時に<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>と<code class="docutils literal notranslate"><span class="pre">amount</span></code>が消えてなくならないことを確かにします、そしてまた<code class="docutils literal notranslate"><span class="pre">incrementer</span></code>関数が呼ばれる次の時に<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>が利用可能であることを確実にもします。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As an optimization, Swift may instead capture and store a <em>copy</em> of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</span><!--end_enstr-->
<span class="jpstr">
ひとつの最適化として、その値がクロージャによって変化させられないならば、そしてその値がクロージャが作成された後に変化されられないならば、スウィフトはそれよりむしろ値の<em>コピー</em>をキャプチャして保管するかもしれません。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift also handles all memory management involved in disposing of variables when they are no longer needed.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはまた、それがもはや必要とされないとき変数を処分することに関わるすべての記憶管理を取り扱います。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Here’s an example of <code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code> in action:</span><!--end_enstr-->
<span class="jpstr">
動作している<code class="docutils literal notranslate"><span class="pre">makeIncrementer</span></code>の例がここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">incrementByTen</span> = <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span>: <span class="m">10</span>)
</li></ol></div></div></div>
<p><span class="enstr">This example sets a constant called <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> to refer to an incrementer function that adds <code class="docutils literal notranslate"><span class="pre">10</span></code> to its <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable each time it is called. Calling the function multiple times shows this behavior in action:</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>と呼ばれる定数を、それが呼ばれるたびに<code class="docutils literal notranslate"><span class="pre">10</span></code>をその<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>変数に加えるあるインクリメンタ関数に言及するように設定します。この関数を複数回呼ぶことは、活動中にこの挙動を示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">incrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 10</span><!--end_enstr--><span class="jpstr">（値10を返す）</span><!--end_jpstr--></span>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 20</span><!--end_enstr--><span class="jpstr">（値20を返す）</span><!--end_jpstr--></span>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 30</span><!--end_enstr--><span class="jpstr">（値30を返す）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">If you create a second incrementer, it will have its own stored reference to a new, separate <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable:</span><!--end_enstr-->
<span class="jpstr">
あなたが第２のインクリメンタをつくるならば、それは、独自に格納された、ある新しい、別個の<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>変数への参照を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">incrementBySeven</span> = <span class="nv">makeIncrementer</span>(<span class="nv">forIncrement</span>: <span class="m">7</span>)
</li><li><span class="nv">incrementBySeven</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 7</span><!--end_enstr--><span class="jpstr">（値7を返す）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Calling the original incrementer (<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>) again continues to increment its own <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variable, and does not affect the variable captured by <code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code>:</span><!--end_enstr-->
<span class="jpstr">
最初のインクリメンタ（<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>）を再び呼ぶことは、それ独自の<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>変数を増加させることを継続します、そして<code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code>によってキャプチャされる変数に影響しません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">incrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 40</span><!--end_enstr--><span class="jpstr">（値40を返す）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses <em>capture lists</em> to break these strong reference cycles. For more information, see <a class="reference internal" href="AutomaticReferenceCounting.html#ID56"><span class="std std-ref">Strong Reference Cycles for Closures</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが、あるクロージャをあるクラスインスタンスのプロパティに代入して、そしてクロージャがそのインスタンスを、インスタンスまたはそのメンバ（属するもの）に言及することによって捕獲するならば、あなたはクロージャとインスタンスの間で強い参照循環をつくります。スウィフトは、これらの強い参照循環を壊すために<em>捕獲リスト</em>を使用します。詳細は、<a class="reference internal" href="AutomaticReferenceCounting.html#ID56"><span class="std std-ref">クロージャのための強い参照循環</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID104">
<h2><span class="enstr">Closures Are Reference Types<a class="headerlink" href="#ID104" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャは参照型です<a class="headerlink" href="#ID104" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">In the example above, <code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code> and <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> are constants, but the closures these constants refer to are still able to increment the <code class="docutils literal notranslate"><span class="pre">runningTotal</span></code> variables that they have captured. This is because functions and closures are <em>reference types</em>.</span><!--end_enstr-->
<span class="jpstr">
上の例で、<code class="docutils literal notranslate"><span class="pre">incrementBySeven</span></code>と<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>は定数です、しかしこれらの定数が言及するクロージャはそれでもなお、それらが捕獲した<code class="docutils literal notranslate"><span class="pre">runningTotal</span></code>変数を増加させることができます。これは、関数とクロージャが<em>参照型</em>であるからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a <em>reference</em> to the function or closure. In the example above, it is the choice of closure that <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code> <em>refers to</em> that is constant, and not the contents of the closure itself.</span><!--end_enstr-->
<span class="jpstr">
あなたが関数やクロージャを定数または変数に代入するときはいつでも、あなたは実際はその定数または変数が関数やクロージャへの<em>参照</em>であると設定しています。上の例では、それは「クロージャの選択」です、それが<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>が<em>参照するもの</em>であり、それは定数であり、そしてクロージャ自身の内容ではありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This also means that if you assign a closure to two different constants or variables, both of those constants or variables refer to the same closure.</span><!--end_enstr-->
<span class="jpstr">
これはまた、あなたがクロージャを２つの異なる定数または変数に代入するならば、それらの定数または変数の両方とも同じクロージャに言及することを意味するでしょう。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">alsoIncrementByTen</span> = <span class="nv">incrementByTen</span>
</li><li><span class="nv">alsoIncrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 50</span><!--end_enstr--><span class="jpstr">（値50を返す）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">incrementByTen</span>()
</li><li><span class="c"><span class="enstr">// returns a value of 60</span><!--end_enstr--><span class="jpstr">（値60を返す）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The example above shows that calling <code class="docutils literal notranslate"><span class="pre">alsoIncrementByTen</span></code> is the same as calling <code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>. Because both of them refer to the same closure, they both increment and return the same running total.</span><!--end_enstr-->
<span class="jpstr">
上の例は、<code class="docutils literal notranslate"><span class="pre">alsoIncrementByTen</span></code>を呼び出すことは<code class="docutils literal notranslate"><span class="pre">incrementByTen</span></code>を呼び出す事と同じであるのを示します。それらの両方ともが同じクロージャを参照することから、それらは両方とも漸増しますそして同じ実行総数を返します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID546">
<h2><span class="enstr">Escaping Closures<a class="headerlink" href="#ID546" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
脱出クロージャ<a class="headerlink" href="#ID546" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">A closure is said to <em>escape</em> a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> before the parameter’s type to indicate that the closure is allowed to escape.</span><!--end_enstr-->
<span class="jpstr">
クロージャが引数として関数に渡される、しかしその関数が戻った後に呼び出されるとき、クロージャは関数を<em>脱出する</em>と言われます。あなたがある関数、それのパラメータの１つとしてクロージャをとるものを宣言する時、あなたは<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>をパラメータの型の前に書くことによって、そのクロージャが脱出を許可されるのを指し示すことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">One way that a closure can escape is by being stored in a variable that is defined outside the function. As an example, many functions that start an asynchronous operation take a closure argument as a completion handler. The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later. For example:</span><!--end_enstr-->
<span class="jpstr">
クロージャが脱出出来る１つの方法は、関数の外側で定義される変数に格納されることです。例として、非同期の演算を開始する多くの関数は、クロージャ引数を完了ハンドラとして取ります。関数は、それが演算を開始した後に戻ります、しかしクロージャはその演算が完了されるまで呼び出されません—このクロージャは脱出する、後で呼び出される、必要があります。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">completionHandlers</span>: [() -&gt; <span class="nc">Void</span>] = []
</li><li><span class="k">func</span> <span class="nv">someFunctionWithEscapingClosure</span>(<span class="nv">completionHandler</span>: <span class="k">@escaping</span> () -&gt; <span class="nc">Void</span>) {
</li><li>    <span class="nv">completionHandlers</span>.<span class="nv">append</span>(<span class="nv">completionHandler</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code> function takes a closure as its argument and adds it to an array that’s declared outside the function. If you didn’t mark the parameter of this function with <code class="docutils literal notranslate"><span class="pre">@escaping</span></code>, you would get a compile-time error.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code>関数は、クロージャをそれの引数として取ります、そしてそれを関数の外側で宣言される配列に加えます。あなたがこの関数のパラメータを<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>で印しないならば、あなたはコンパイル時エラーを得るでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Marking a closure with <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> means you have to refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> explicitly within the closure. For example, in the code below, the closure passed to <code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code> is an escaping closure, which means it needs to refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> explicitly. In contrast, the closure passed to <code class="docutils literal notranslate"><span class="pre">someFunctionWithNonescapingClosure(_:)</span></code> is a nonescaping closure, which means it can refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> implicitly.</span><!--end_enstr-->
<span class="jpstr">
あるクロージャを<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>で印することは、あなたがそのクロージャ内部で<code class="docutils literal notranslate"><span class="pre">self</span></code>を明示的に参照しなければならないのを意味します。例えば、以下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">someFunctionWithEscapingClosure(_:)</span></code>に渡されるクロージャは脱出クロージャです、それは、それが<code class="docutils literal notranslate"><span class="pre">self</span></code>を明示的に参照する必要があるのを意味します。対照的に、<code class="docutils literal notranslate"><span class="pre">someFunctionWithNonescapingClosure(_:)</span></code>に渡されるクロージャは非脱出クロージャです、それは、それが<code class="docutils literal notranslate"><span class="pre">self</span></code>を暗黙的に参照できるのを意味します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunctionWithNonescapingClosure</span>(<span class="nv">closure</span>: () -&gt; <span class="nc">Void</span>) {
</li><li>    <span class="nv">closure</span>()
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">10</span>
</li><li>    <span class="k">func</span> <span class="nv">doSomething</span>() {
</li><li>        <span class="nv">someFunctionWithEscapingClosure</span> { <span class="k">self</span>.<span class="nv">x</span> = <span class="m">100</span> }
</li><li>        <span class="nv">someFunctionWithNonescapingClosure</span> { <span class="nv">x</span> = <span class="m">200</span> }
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">instance</span> = <span class="nv">SomeClass</span>()
</li><li><span class="nv">instance</span>.<span class="nv">doSomething</span>()
</li><li><span class="nv">print</span>(<span class="nv">instance</span>.<span class="nv">x</span>)
</li><li><span class="c">// Prints "200"</span>
</li><li>
</li><li><span class="nv">completionHandlers</span>.<span class="nv">first</span>?()
</li><li><span class="nv">print</span>(<span class="nv">instance</span>.<span class="nv">x</span>)
</li><li><span class="c">// Prints "100"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID543">
<h2><span class="enstr">Autoclosures<a class="headerlink" href="#ID543" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
自動クロージャ<a class="headerlink" href="#ID543" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">An <em>autoclosure</em> is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</span><!--end_enstr-->
<span class="jpstr">
<em>自動クロージャ</em>は、自動的に作成されて、引数として関数に渡されている式を包み込むクロージャです。それは、全く引数を取りません、そしてそれが呼ばれる時、その内部に包み込まれた式の値を返します。この統語上の便宜は、明示的なクロージャの代わりに通常の関数を書くことによって、あなたに関数のパラメータのまわりの波括弧を省略させます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">It’s common to <em>call</em> functions that take autoclosures, but it’s not common to <em>implement</em> that kind of function. For example, the <code class="docutils literal notranslate"><span class="pre">assert(condition:message:file:line:)</span></code> function takes an autoclosure for its <code class="docutils literal notranslate"><span class="pre">condition</span></code> and <code class="docutils literal notranslate"><span class="pre">message</span></code> parameters; its <code class="docutils literal notranslate"><span class="pre">condition</span></code> parameter is evaluated only in debug builds and its <code class="docutils literal notranslate"><span class="pre">message</span></code> parameter is evaluated only if <code class="docutils literal notranslate"><span class="pre">condition</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</span><!--end_enstr-->
<span class="jpstr">
自動クロージャを取る関数を<em>呼び出す</em>のは普通です、しかしそのような関数を<em>実装する</em>のは一般的ではありません。例えば、<code class="docutils literal notranslate"><span class="pre">assert(condition:message:file:line:)</span></code>関数は自動クロージャをそれの<code class="docutils literal notranslate"><span class="pre">condition</span></code>と<code class="docutils literal notranslate"><span class="pre">message</span></code>パラメータとして取ります；それの<code class="docutils literal notranslate"><span class="pre">condition</span></code>パラメータはデバッグビルドにおいてのみ評価されます、そしてそれの<code class="docutils literal notranslate"><span class="pre">message</span></code>パラメータは<code class="docutils literal notranslate"><span class="pre">condition</span></code>が<code class="docutils literal notranslate"><span class="pre">false</span></code>である場合にのみ評価されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure. Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated. The code below shows how a closure delays evaluation.</span><!--end_enstr-->
<span class="jpstr">
自動クロージャは、あなたに評価を延期させます、内部のコードはあなたがそのクロージャを呼び出すまで実行されないからです。評価を遅らせることは、副作用を持つまたは計算的に高くつくコードに対して有用です、なぜならそれがあなたに何時そのコードが評価されるかを制御させるからです。下のコードは、どのようにクロージャが評価を遅らすかを示します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">customersInLine</span> = [<span class="s">"Chris"</span>, <span class="s">"Alex"</span>, <span class="s">"Ewa"</span>, <span class="s">"Barry"</span>, <span class="s">"Daniella"</span>]
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "5"</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">customerProvider</span> = { <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>) }
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "5"</span>
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li><span class="c">// Prints "Now serving Chris!"</span>
</li><li><span class="nv">print</span>(<span class="nv">customersInLine</span>.<span class="nv">count</span>)
</li><li><span class="c">// Prints "4"</span>
</li></ol></div></div></div>
<p><span class="enstr">Even though the first element of the <code class="docutils literal notranslate"><span class="pre">customersInLine</span></code> array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called. If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed. Note that the type of <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> is not <code class="docutils literal notranslate"><span class="pre">String</span></code> but <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>—a function with no parameters that returns a string.</span><!--end_enstr-->
<span class="jpstr">
たとえ<code class="docutils literal notranslate"><span class="pre">customersInLine</span></code>配列の最初の要素がクロージャ内部のコードによって取り除かれるとしても、その配列要素はクロージャが実際に呼び出されるまで実行されません。このクロージャが決して呼び出されないならば、クロージャ内部の式は決して評価されません、それは配列要素が決して取り除かれないことを意味します。注意すべきは、<code class="docutils literal notranslate"><span class="pre">customerProvider</span></code>の型は<code class="docutils literal notranslate"><span class="pre">String</span></code>ではなく<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code> — ある文字列を返すパラメータのない関数 — であることです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</span><!--end_enstr-->
<span class="jpstr">
あなたが同じ挙動の延期した評価を得るのは、あなたがクロージャを引数として関数に渡す時です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c"><span class="enstr">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span><!--end_enstr--><span class="jpstr">（customersInLine（並んでいる顧客）は、["Alex", "Ewa", "Barry", "Daniella"]です）</span><!--end_jpstr--></span>
</li><li><span class="k">func</span> <span class="nv">serve</span>(<span class="nv">customer</span> <span class="nv">customerProvider</span>: () -&gt; <span class="nc">String</span>) {
</li><li>    <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="nv">serve</span>(<span class="nv">customer</span>: { <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>) } )
</li><li><span class="c"><span class="enstr">// Prints "Now serving Alex!"</span><!--end_enstr--><span class="jpstr">（今アレックスに対応中！）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code> function in the listing above takes an explicit closure that returns a customer’s name. The version of <code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code> below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> attribute. Now you can call the function as if it took a <code class="docutils literal notranslate"><span class="pre">String</span></code> argument instead of a closure. The argument is automatically converted to a closure, because the <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> parameter’s type is marked with the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
上で記載される<code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code>関数は、次の顧客の名前を返す、ある明示的なクロージャを取ります。下のバージョンの<code class="docutils literal notranslate"><span class="pre">serve(customer:)</span></code>は同じ演算を実行します、しかし明示的なクロージャを取るのではなく、それは自動クロージャを、それのパラメータの型を<code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code>属性で記することによって取ります。今やあなたはこの関数を、まるでそれがクロージャではなく<code class="docutils literal notranslate"><span class="pre">String</span></code>引数を取るかのように呼び出せます。引数は、自動的にクロージャに変換されます、なぜなら<code class="docutils literal notranslate"><span class="pre">customerProvider</span></code>パラメータの型は<code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code>属性で印されるからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c"><span class="enstr">// customersInLine is ["Ewa", "Barry", "Daniella"]</span><!--end_enstr--><span class="jpstr">（customersInLine（並んでいる顧客）は、["Ewa", "Barry", "Daniella"]です）</span><!--end_jpstr--></span>
</li><li><span class="k">func</span> <span class="nv">serve</span>(<span class="nv">customer</span> <span class="nv">customerProvider</span>: <span class="k">@autoclosure</span> () -&gt; <span class="nc">String</span>) {
</li><li>    <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="nv">serve</span>(<span class="nv">customer</span>: <span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li><span class="c"><span class="enstr">// Prints "Now serving Ewa!"</span><!--end_enstr--><span class="jpstr">（今エヴァに対応中！）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that evaluation is being deferred.</span><!--end_enstr-->
<span class="jpstr">
自動クロージャの使いすぎは、あなたのコードを理解しにくくする可能性があります。文脈と関数名は、評価が猶予されていることを明確にしなければなりません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If you want an autoclosure that is allowed to escape, use both the <code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code> and <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> attributes. The <code class="docutils literal notranslate"><span class="pre">@escaping</span></code> attribute is described above in <a class="reference internal" href="#ID546"><span class="std std-ref">Escaping Closures</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが脱出を許可される自動クロージャを望むならば、<code class="docutils literal notranslate"><span class="pre">@autoclosure</span></code>と<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>属性を両方とも使ってください。<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>属性は、上の<a class="reference internal" href="#ID546"><span class="std std-ref">Escaping Closures</span></a>で解説されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c"><span class="enstr">// customersInLine is ["Barry", "Daniella"]</span><!--end_enstr--><span class="jpstr">（customersInLine（並んでいる顧客）は、["Barry", "Daniella"]です）</span><!--end_jpstr--></span>
</li><li><span class="k">var</span> <span class="nv">customerProviders</span>: [() -&gt; <span class="nc">String</span>] = []
</li><li><span class="k">func</span> <span class="nv">collectCustomerProviders</span>(<span class="k">_</span> <span class="nv">customerProvider</span>: <span class="k">@autoclosure</span> <span class="k">@escaping</span> () -&gt; <span class="nc">String</span>) {
</li><li>    <span class="nv">customerProviders</span>.<span class="nv">append</span>(<span class="nv">customerProvider</span>)
</li><li>}
</li><li><span class="nv">collectCustomerProviders</span>(<span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li><span class="nv">collectCustomerProviders</span>(<span class="nv">customersInLine</span>.<span class="nv">remove</span>(<span class="nv">at</span>: <span class="m">0</span>))
</li><li>
</li><li><span class="nv">print</span>(<span class="s">"Collected </span>\<span class="p">(</span><span class="nv">customerProviders</span>.<span class="nv">count</span><span class="p">)</span><span class="s"> closures."</span>)
</li><li><span class="c"><span class="enstr">// Prints "Collected 2 closures."</span><!--end_enstr--><span class="jpstr">（「２つのクロージャが集められた。」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="k">for</span> <span class="nv">customerProvider</span> <span class="k">in</span> <span class="nv">customerProviders</span> {
</li><li>    <span class="nv">print</span>(<span class="s">"Now serving </span>\<span class="p">(</span><span class="nv">customerProvider</span>()<span class="p">)</span><span class="s">!"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "Now serving Barry!"</span><!--end_enstr--><span class="jpstr">（今バリーに対応中！）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Prints "Now serving Daniella!"</span><!--end_enstr--><span class="jpstr">（今ダニエラに対応中！）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">In the code above, instead of calling the closure passed to it as its <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> argument, the <code class="docutils literal notranslate"><span class="pre">collectCustomerProviders(_:)</span></code> function appends the closure to the <code class="docutils literal notranslate"><span class="pre">customerProviders</span></code> array. The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns. As a result, the value of the <code class="docutils literal notranslate"><span class="pre">customerProvider</span></code> argument must be allowed to escape the function’s scope.</span><!--end_enstr-->
<span class="jpstr">
上のコードにおいて、それの<code class="docutils literal notranslate"><span class="pre">customerProvider</span></code>引数としてそれに渡されるクロージャを呼び出す代わりに、<code class="docutils literal notranslate"><span class="pre">collectCustomerProviders(_:)</span></code>関数は、そのクロージャを<code class="docutils literal notranslate"><span class="pre">customerProviders</span></code>配列に追加します。この配列は関数のスコープの外側で宣言されます、それは配列の中のクロージャが関数が戻った後で実行されることができるのを意味します。その結果、<code class="docutils literal notranslate"><span class="pre">customerProvider</span></code>引数の値は関数のスコープを脱出することを許されなければなりません。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Enumerations.html"><span class="enstr">Enumeration</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          <span class="enstr">This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</span><!--end_enstr-->
<span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->

        </p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
