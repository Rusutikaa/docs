

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Automatic Reference Counting — The Swift Programming Language (Swift 5)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumeration</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID49"><span class="enstr">How ARC Works</span><!--end_enstr-->
<span class="jpstr">
ARCは、どのように働きますか
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID50"><span class="enstr">ARC in Action</span><!--end_enstr-->
<span class="jpstr">
ARCの動作
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID51"><span class="enstr">Strong Reference Cycles Between Class Instances</span><!--end_enstr-->
<span class="jpstr">
クラスインスタンス間の強い参照循環
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID52"><span class="enstr">Resolving Strong Reference Cycles Between Class Instances</span><!--end_enstr-->
<span class="jpstr">
クラスインスタンス間の強い参照循環の解消
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID53"><span class="enstr">Weak References</span><!--end_enstr-->
<span class="jpstr">
弱い参照
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID54"><span class="enstr">Unowned References</span><!--end_enstr-->
<span class="jpstr">
非所有参照
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID55"><span class="enstr">Unowned References and Implicitly Unwrapped Optional Properties</span><!--end_enstr-->
<span class="jpstr">
非所有参照と暗黙的にアンラップされるオプショナルのプロパティ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID56"><span class="enstr">Strong Reference Cycles for Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャのための強い参照循環
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID57"><span class="enstr">Resolving Strong Reference Cycles for Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャのための強い参照循環の解消
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID58"><span class="enstr">Defining a Capture List</span><!--end_enstr-->
<span class="jpstr">
捕獲リストの定義
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID59"><span class="enstr">Weak and Unowned References</span><!--end_enstr-->
<span class="jpstr">
弱いおよび非所有参照
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="automatic-reference-counting">
<h1><span class="enstr">Automatic Reference Counting<a class="headerlink" href="#automatic-reference-counting" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
自動参照カウント<a class="headerlink" href="#automatic-reference-counting" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr">Swift uses <em>Automatic Reference Counting</em> (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、<em>自動参照カウント（ARC）</em>を使います。ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you. This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory. Using ARC in Swift is very similar to the approach described in <a class="reference external" href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a> for using ARC with Objective-C.</span><!--end_enstr-->
<span class="jpstr">
しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。スウィフトでのARCの使用は、Objective-CでARCを使うための<a class="reference external" href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a>で記述される取り組みに非常に似ています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Reference counting applies only to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</span><!--end_enstr-->
<span class="jpstr">
参照カウントが唯一適用されるのは、クラスのインスタンスに対してです。構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID49">
<h2><span class="enstr">How ARC Works<a class="headerlink" href="#ID49" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ARCは、どのように働きますか<a class="headerlink" href="#ID49" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</span><!--end_enstr-->
<span class="jpstr">
あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる格納プロパティの値と共に持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances do not take up space in memory when they are no longer needed.</span><!--end_enstr-->
<span class="jpstr">
その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash.</span><!--end_enstr-->
<span class="jpstr">
しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</span><!--end_enstr-->
<span class="jpstr">
それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance. The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</span><!--end_enstr-->
<span class="jpstr">
これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの<em>強い参照</em>を作ります。この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID50">
<h2><span class="enstr">ARC in Action<a class="headerlink" href="#ID50" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ARCの動作<a class="headerlink" href="#ID50" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Here’s an example of how Automatic Reference Counting works. This example starts with a simple class called <code class="docutils literal notranslate"><span class="pre">Person</span></code>, which defines a stored constant property called <code class="docutils literal notranslate"><span class="pre">name</span></code>:</span><!--end_enstr-->
<span class="jpstr">
自動参照カウントがどのように働くかの例は、ここにあります。この例は、<code class="docutils literal notranslate"><span class="pre">Person</span></code>と呼ばれる単純なクラスから始めます、それは、<code class="docutils literal notranslate"><span class="pre">name</span></code>と呼ばれる格納定数プロパティを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being initialized"</span>)
</li><li>    }
</li><li>    <span class="k">deinit</span> {
</li><li>        <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Person</span></code> class has an initializer that sets the instance’s <code class="docutils literal notranslate"><span class="pre">name</span></code> property and prints a message to indicate that initialization is underway. The <code class="docutils literal notranslate"><span class="pre">Person</span></code> class also has a deinitializer that prints a message when an instance of the class is deallocated.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Person</span></code>クラスは、インスタンスの<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。<code class="docutils literal notranslate"><span class="pre">Person</span></code>クラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The next code snippet defines three variables of type <code class="docutils literal notranslate"><span class="pre">Person?</span></code>, which are used to set up multiple references to a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance in subsequent code snippets. Because these variables are of an optional type (<code class="docutils literal notranslate"><span class="pre">Person?</span></code>, not <code class="docutils literal notranslate"><span class="pre">Person</span></code>), they are automatically initialized with a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and do not currently reference a <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
次のコード断片は、型<code class="docutils literal notranslate"><span class="pre">Person?</span></code>の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの複数の参照を準備するために使われます。これらの変数がオプショナル型（<code class="docutils literal notranslate"><span class="pre">Person</span></code>ではなく、<code class="docutils literal notranslate"><span class="pre">Person?</span></code>）であることから、それらは自動的に<code class="docutils literal notranslate"><span class="pre">nil</span></code>の値で初期化されて、今は<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスに参照をつけません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">reference1</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">reference2</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">reference3</span>: <span class="nc">Person</span>?
</li></ol></div></div></div>
<p><span class="enstr">You can now create a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and assign it to one of these three variables:</span><!--end_enstr-->
<span class="jpstr">
あなたは、いま新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference1</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="c"><span class="enstr">// Prints "John Appleseed is being initialized"</span><!--end_enstr--><span class="jpstr">（「John Appleseedは、初期化された」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Note that the message <code class="docutils literal notranslate"><span class="pre">"John</span> <span class="pre">Appleseed</span> <span class="pre">is</span> <span class="pre">being</span> <span class="pre">initialized"</span></code> is printed at the point that you call the <code class="docutils literal notranslate"><span class="pre">Person</span></code> class’s initializer. This confirms that initialization has taken place.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Person</span></code>クラスのイニシャライザを呼んだ時点で、メッセージ<code class="docutils literal notranslate"><span class="pre">"John</span> <span class="pre">Appleseed</span> <span class="pre">is</span> <span class="pre">being</span> <span class="pre">initialized"</span></code>が出力されるという点に注意してください。これは、初期化が起こったことを確認します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance has been assigned to the <code class="docutils literal notranslate"><span class="pre">reference1</span></code> variable, there is now a strong reference from <code class="docutils literal notranslate"><span class="pre">reference1</span></code> to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. Because there is at least one strong reference, ARC makes sure that this <code class="docutils literal notranslate"><span class="pre">Person</span></code> is kept in memory and is not deallocated.</span><!--end_enstr-->
<span class="jpstr">
新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスが<code class="docutils literal notranslate"><span class="pre">reference1</span></code>変数に代入されたので、強い参照が現在<code class="docutils literal notranslate"><span class="pre">reference1</span></code>から新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスまで存在します。少なくとも１つの強い参照があるので、ARCはこの<code class="docutils literal notranslate"><span class="pre">Person</span></code>がメモリに保たれて割り当て解除されないことを確実にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you assign the same <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance to two more variables, two more strong references to that instance are established:</span><!--end_enstr-->
<span class="jpstr">
あなたが同じ<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference2</span> = <span class="nv">reference1</span>
</li><li><span class="nv">reference3</span> = <span class="nv">reference1</span>
</li></ol></div></div></div>
<p><span class="enstr">There are now <em>three</em> strong references to this single <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
現在この１つの<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの<em>３つ</em>の強い参照があります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you break two of these strong references (including the original reference) by assigning <code class="docutils literal notranslate"><span class="pre">nil</span></code> to two of the variables, a single strong reference remains, and the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance is not deallocated:</span><!--end_enstr-->
<span class="jpstr">
あなたが変数のうちの２つに<code class="docutils literal notranslate"><span class="pre">nil</span></code>を代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そして<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスは割り当て解除されません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference1</span> = <span class="k">nil</span>
</li><li><span class="nv">reference2</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p><span class="enstr">ARC does not deallocate the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
ARCは、<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスの割り当て解除を３番目で最後に残ったの強い参照が壊れるまで行いません、その時点では、あなたがもはや<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスを使っていないことは明白です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">reference3</span> = <span class="k">nil</span>
</li><li><span class="c"><span class="enstr">// Prints "John Appleseed is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID51">
<h2><span class="enstr">Strong Reference Cycles Between Class Instances<a class="headerlink" href="#ID51" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クラスインスタンス間の強い参照循環<a class="headerlink" href="#ID51" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">In the examples above, ARC is able to track the number of references to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance you create and to deallocate that <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance when it’s no longer needed.</span><!--end_enstr-->
<span class="jpstr">
上の例で、ARCはあなたがつくる新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの参照の数を追跡して、その<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスをそれがもはや必要でないとき割り当て解除することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, it’s possible to write code in which an instance of a class <em>never</em> gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a <em>strong reference cycle</em>.</span><!--end_enstr-->
<span class="jpstr">
しかしながら、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが<em>決してない</em>コードを書くことは、可能です。２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。これは、<em>強い参照循環</em>として知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references. This process is described in <a class="reference internal" href="#ID52"><span class="std std-ref">Resolving Strong Reference Cycles Between Class Instances</span></a>. However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.</span><!--end_enstr-->
<span class="jpstr">
あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有参照として定義することによって強い参照循環を解消します。この過程は、<a class="reference internal" href="#ID52"><span class="std std-ref">クラスインスタンス間の強い参照循環の解消</span></a>で記述されます。しかし、あなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example of how a strong reference cycle can be created by accident. This example defines two classes called <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code>, which model a block of apartments and its residents:</span><!--end_enstr-->
<span class="jpstr">
強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。この例は<code class="docutils literal notranslate"><span class="pre">Person</span></code>と<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>と呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span> }
</li><li>    <span class="k">var</span> <span class="nv">apartment</span>: <span class="nc">Apartment</span>?
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Apartment</span> {
</li><li>    <span class="k">let</span> <span class="nv">unit</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">unit</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">unit</span> = <span class="nv">unit</span> }
</li><li>    <span class="k">var</span> <span class="nv">tenant</span>: <span class="nc">Person</span>?
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Apartment </span>\<span class="p">(</span><span class="nv">unit</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Every <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance has a <code class="docutils literal notranslate"><span class="pre">name</span></code> property of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and an optional <code class="docutils literal notranslate"><span class="pre">apartment</span></code> property that is initially <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The <code class="docutils literal notranslate"><span class="pre">apartment</span></code> property is optional, because a person may not always have an apartment.</span><!--end_enstr-->
<span class="jpstr">
あらゆる<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスは、型<code class="docutils literal notranslate"><span class="pre">String</span></code>の<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティと初期時には<code class="docutils literal notranslate"><span class="pre">nil</span></code>であるオプショナルの<code class="docutils literal notranslate"><span class="pre">apartment</span></code>プロパティを持ちます。人は必ずしもアパートを持つわけではないので、<code class="docutils literal notranslate"><span class="pre">apartment</span></code>プロパティはオプショナルです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Similarly, every <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance has a <code class="docutils literal notranslate"><span class="pre">unit</span></code> property of type <code class="docutils literal notranslate"><span class="pre">String</span></code> and has an optional <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property that is initially <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The tenant property is optional because an apartment may not always have a tenant.</span><!--end_enstr-->
<span class="jpstr">
同じように、あらゆる<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスは、型<code class="docutils literal notranslate"><span class="pre">String</span></code>の<code class="docutils literal notranslate"><span class="pre">unit</span></code>プロパティを持って、初期時には<code class="docutils literal notranslate"><span class="pre">nil</span></code>であるオプショナルの<code class="docutils literal notranslate"><span class="pre">tenant</span></code>プロパティを持ちます。アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized. This enables you to see whether instances of <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> are being deallocated as expected.</span><!--end_enstr-->
<span class="jpstr">
これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。これは、あなたに期待されるように<code class="docutils literal notranslate"><span class="pre">Person</span></code>と<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>のインスタンスが割り当て解除されているかどうか知ることを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This next code snippet defines two variables of optional type called <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code>, which will be set to a specific <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> and <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance below. Both of these variables have an initial value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, by virtue of being optional:</span><!--end_enstr-->
<span class="jpstr">
この次のコード断片は<code class="docutils literal notranslate"><span class="pre">john</span></code>と<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>と呼ばれるオプショナルの型の２つの変数を定義します、それは、特定の<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>と<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスに以降で設定されます。オプショナルである利点によって、これらの変数の両方とも、<code class="docutils literal notranslate"><span class="pre">nil</span></code>の初期値を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">unit4A</span>: <span class="nc">Apartment</span>?
</li></ol></div></div></div>
<p><span class="enstr">You can now create a specific <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance and assign these new instances to the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables:</span><!--end_enstr-->
<span class="jpstr">
あなたは、今や特定の<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスと<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスを作成して、それらの新しいインスタンスを<code class="docutils literal notranslate"><span class="pre">john</span></code>および<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>変数に代入することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">unit4A</span> = <span class="nv">Apartment</span>(<span class="nv">unit</span>: <span class="s">"4A"</span>)
</li></ol></div></div></div>
<p><span class="enstr">Here’s how the strong references look after creating and assigning these two instances. The <code class="docutils literal notranslate"><span class="pre">john</span></code> variable now has a strong reference to the new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variable has a strong reference to the new <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。<code class="docutils literal notranslate"><span class="pre">john</span></code>変数は現在新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの強い参照を持ちます、そして<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>変数は新しい<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの強い参照を持ちます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/referenceCycle01_2x.png" class="align-center" src="../images/referenceCycle01_2x.png" style="width: 626px;" />
<p><span class="enstr">You can now link the two instances together so that the person has an apartment, and the apartment has a tenant. Note that an exclamation mark (<code class="docutils literal notranslate"><span class="pre">!</span></code>) is used to unwrap and access the instances stored inside the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> optional variables, so that the properties of those instances can be set:</span><!--end_enstr-->
<span class="jpstr">
あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。感嘆符（<code class="docutils literal notranslate"><span class="pre">!</span></code>）が使われることに注意してください、そうすることでオプショナル変数の<code class="docutils literal notranslate"><span class="pre">john</span></code>と<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>に格納されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span>!.<span class="nv">apartment</span> = <span class="nv">unit4A</span>
</li><li><span class="nv">unit4A</span>!.<span class="nv">tenant</span> = <span class="nv">john</span>
</li></ol></div></div></div>
<p><span class="enstr">Here’s how the strong references look after you link the two instances together:</span><!--end_enstr-->
<span class="jpstr">
あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。
</span><!--end_jpstr-->
</p>
<img alt="../_images/referenceCycle02_2x.png" class="align-center" src="../images/referenceCycle02_2x.png" style="width: 626px;" />
<p><span class="enstr">Unfortunately, linking these two instances creates a strong reference cycle between them. The <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance now has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. Therefore, when you break the strong references held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:</span><!--end_enstr-->
<span class="jpstr">
残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスは現在<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの強い参照を持ちます、そして、<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスは<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの強い参照を持ちます。したがって、あなたが<code class="docutils literal notranslate"><span class="pre">john</span></code>と<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="nv">unit4A</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p><span class="enstr">Note that neither deinitializer was called when you set these two variables to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The strong reference cycle prevents the <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instances from ever being deallocated, causing a memory leak in your app.</span><!--end_enstr-->
<span class="jpstr">
あなたがこれらの２つの変数を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。強い参照循環は<code class="docutils literal notranslate"><span class="pre">Person</span></code>と<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how the strong references look after you set the <code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variables to <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">john</span></code>と<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>変数を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定したあと、強い参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/referenceCycle03_2x.png" class="align-center" src="../images/referenceCycle03_2x.png" style="width: 626px;" />
<p><span class="enstr">The strong references between the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance and the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance remain and cannot be broken.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスと<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスの間の強い参照は、残っていて、壊されることができません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID52">
<h2><span class="enstr">Resolving Strong Reference Cycles Between Class Instances<a class="headerlink" href="#ID52" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クラスインスタンス間の強い参照循環の解消<a class="headerlink" href="#ID52" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</span><!--end_enstr-->
<span class="jpstr">
あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有参照。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Weak and unowned references enable one instance in a reference cycle to refer to the other instance <em>without</em> keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
弱いおよび非所有参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つこと<em>なく</em>可能にします。インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. In the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case. In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</span><!--end_enstr-->
<span class="jpstr">
弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。上の<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>例において、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID53">
<h3><span class="enstr">Weak References<a class="headerlink" href="#ID53" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
弱い参照<a class="headerlink" href="#ID53" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">A <em>weak reference</em> is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the <code class="docutils literal notranslate"><span class="pre">weak</span></code> keyword before a property or variable declaration.</span><!--end_enstr-->
<span class="jpstr">
<em>弱い参照</em>は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。この挙動は、参照が強い参照循環の一部になるのを妨げます。あなたは、プロパティまたは変数の宣言の前に<code class="docutils literal notranslate"><span class="pre">weak</span></code>キーワードを置くことによって弱い参照を示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to <code class="docutils literal notranslate"><span class="pre">nil</span></code> when the instance that it refers to is deallocated. And, because weak references need to allow their value to be changed to <code class="docutils literal notranslate"><span class="pre">nil</span></code> at runtime, they are always declared as variables, rather than constants, of an optional type.</span><!--end_enstr-->
<span class="jpstr">
弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及している間にそのインスタンスが割り当て解除されることは可能です。したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるとき<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定します。そしてまた、弱い参照はそれらの値を実行時に<code class="docutils literal notranslate"><span class="pre">nil</span></code>に変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</span><!--end_enstr-->
<span class="jpstr">
他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Property observers aren’t called when ARC sets a weak reference to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</span><!--end_enstr-->
<span class="jpstr">
プロパティオブザーバーは、ARCが弱い参照を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定するとき呼び出されません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below is identical to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example from above, with one important difference. This time around, the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> type’s <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property is declared as a weak reference:</span><!--end_enstr-->
<span class="jpstr">
下の例は、上記の<code class="docutils literal notranslate"><span class="pre">Person</span></code>と<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>例に同一ですが、１つの重要な違いがあります。今度は、<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>型の<code class="docutils literal notranslate"><span class="pre">tenant</span></code>プロパティは、弱い参照として宣言されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Person</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span> }
</li><li>    <span class="k">var</span> <span class="nv">apartment</span>: <span class="nc">Apartment</span>?
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">Apartment</span> {
</li><li>    <span class="k">let</span> <span class="nv">unit</span>: <span class="nc">String</span>
</li><li>    <span class="k">init</span>(<span class="nv">unit</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">unit</span> = <span class="nv">unit</span> }
</li><li>    <span class="k">weak</span> <span class="k">var</span> <span class="nv">tenant</span>: <span class="nc">Person</span>?
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Apartment </span>\<span class="p">(</span><span class="nv">unit</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The strong references from the two variables (<code class="docutils literal notranslate"><span class="pre">john</span></code> and <code class="docutils literal notranslate"><span class="pre">unit4A</span></code>) and the links between the two instances are created as before:</span><!--end_enstr-->
<span class="jpstr">
２つの変数（<code class="docutils literal notranslate"><span class="pre">john</span></code>と<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Person</span>?
</li><li><span class="k">var</span> <span class="nv">unit4A</span>: <span class="nc">Apartment</span>?
</li><li>
</li><li><span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">unit4A</span> = <span class="nv">Apartment</span>(<span class="nv">unit</span>: <span class="s">"4A"</span>)
</li><li>
</li><li><span class="nv">john</span>!.<span class="nv">apartment</span> = <span class="nv">unit4A</span>
</li><li><span class="nv">unit4A</span>!.<span class="nv">tenant</span> = <span class="nv">john</span>
</li></ol></div></div></div>
<p><span class="enstr">Here’s how the references look now that you’ve linked the two instances together:</span><!--end_enstr-->
<span class="jpstr">
あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/weakReference01_2x.png" class="align-center" src="../images/weakReference01_2x.png" style="width: 626px;" />
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance still has a strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, but the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance now has a <em>weak</em> reference to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance. This means that when you break the strong reference held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable by setting it to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスは依然として<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの強い参照を持ちます、しかし、<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスは現在は<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの<em>弱い</em>参照を持ちます。これは、あなたが<code class="docutils literal notranslate"><span class="pre">john</span></code>変数によって保持される強い参照を、それを<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定することによって壊すとき、<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの強い参照がもうそれ以上ないことを意味します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="c"><span class="enstr">// Prints "John Appleseed is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance, it’s deallocated and the <code class="docutils literal notranslate"><span class="pre">tenant</span></code> property is set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</span><!--end_enstr-->
<span class="jpstr">
もうこれ以上<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスへの強い参照はないことから、それは割り当て解除されます、そして<code class="docutils literal notranslate"><span class="pre">tenant</span></code>特性は<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定されます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/weakReference02_2x.png" class="align-center" src="../images/weakReference02_2x.png" style="width: 626px;" />
<p><span class="enstr">The only remaining strong reference to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance is from the <code class="docutils literal notranslate"><span class="pre">unit4A</span></code> variable. If you break <em>that</em> strong reference, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの唯一の残っている強い参照は、<code class="docutils literal notranslate"><span class="pre">unit4A</span></code>変数からです。あなたが<em>その</em>強い参照を壊すならば、<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの強い参照はもうこれ以上ありません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">unit4A</span> = <span class="k">nil</span>
</li><li><span class="c"><span class="enstr">// Prints "Apartment 4A is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「アパート4Aは、デイニシャライズされた」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> instance, it too is deallocated:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>インスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/weakReference03_2x.png" class="align-center" src="../images/weakReference03_2x.png" style="width: 626px;" />
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection. However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</span><!--end_enstr-->
<span class="jpstr">
ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID54">
<h3><span class="enstr">Unowned References<a class="headerlink" href="#ID54" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
非所有参照<a class="headerlink" href="#ID54" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Like a weak reference, an <em>unowned reference</em> does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime. You indicate an unowned reference by placing the <code class="docutils literal notranslate"><span class="pre">unowned</span></code> keyword before a property or variable declaration.</span><!--end_enstr-->
<span class="jpstr">
弱い参照のように、<em>非所有参照</em>は、それが言及するインスタンスに対する強い支配力を保ちません。しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。あなたは、プロパティまたは変数の宣言の前に<code class="docutils literal notranslate"><span class="pre">unowned</span></code>キーワードを置くことによって非所有参照を示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An unowned reference is expected to always have a value. As a result, ARC never sets an unowned reference’s value to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, which means that unowned references are defined using non-optional types.</span><!--end_enstr-->
<span class="jpstr">
非所有参照は、常にある値を持っていることを期待されます。結果として、ARCは決して非所有参照のもつ値を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定しません、それは非所有参照が非オプショナル型を使って定義されることを意味します。
</span><!--end_jpstr-->
</p>
<div class="admonition important">
<p class="first admonition-title"><span class="enstr">Important</span><!--end_enstr-->
<span class="jpstr">
重要
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use an unowned reference only when you are sure that the reference <em>always</em> refers to an instance that has not been deallocated.</span><!--end_enstr-->
<span class="jpstr">
非所有参照を、その参照が<em>常に</em>デアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</span><!--end_enstr-->
<span class="jpstr">
あなたがある非所有参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The following example defines two classes, <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>, which model a bank customer and a possible credit card for that customer. These two classes each store an instance of the other class as a property. This relationship has the potential to create a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
以下の例は２つのクラス、<code class="docutils literal notranslate"><span class="pre">Customer</span></code>と<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>を定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。この関係は、強い参照循環をつくる可能性を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The relationship between <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> is slightly different from the relationship between <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> and <code class="docutils literal notranslate"><span class="pre">Person</span></code> seen in the weak reference example above. In this data model, a customer may or may not have a credit card, but a credit card will <em>always</em> be associated with a customer. A <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance never outlives the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> that it refers to. To represent this, the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> class has an optional <code class="docutils literal notranslate"><span class="pre">card</span></code> property, but the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> class has an unowned (and non-optional) <code class="docutils literal notranslate"><span class="pre">customer</span></code> property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>と<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>の関係は、上の弱い参照の例で見られる<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>と<code class="docutils literal notranslate"><span class="pre">Person</span></code>の関係と少しばかり異なります。このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは<em>常に</em>ひとりの顧客と結び付けられます。<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスは、それが参照する<code class="docutils literal notranslate"><span class="pre">Customer</span></code>より決して長生きしません。これを表すために、<code class="docutils literal notranslate"><span class="pre">Customer</span></code>クラスはオプショナルの<code class="docutils literal notranslate"><span class="pre">card</span></code>プロパティを持ちます、しかし、<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>クラスは非所有（そして非オプショナル）の<code class="docutils literal notranslate"><span class="pre">customer</span></code>プロパティを持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Furthermore, a new <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance can <em>only</em> be created by passing a <code class="docutils literal notranslate"><span class="pre">number</span></code> value and a <code class="docutils literal notranslate"><span class="pre">customer</span></code> instance to a custom <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> initializer. This ensures that a <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance always has a <code class="docutils literal notranslate"><span class="pre">customer</span></code> instance associated with it when the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance is created.</span><!--end_enstr-->
<span class="jpstr">
さらに、新しい<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスは、<code class="docutils literal notranslate"><span class="pre">number</span></code>値と<code class="docutils literal notranslate"><span class="pre">customer</span></code>インスタンスをあつらえの<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>イニシャライザに渡すことによって<em>のみ</em>作成されることができます。これは、<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスがつくられるとき、<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスが常にそれと結びつけられる<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスを持つことを確実にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because a credit card will always have a customer, you define its <code class="docutils literal notranslate"><span class="pre">customer</span></code> property as an unowned reference, to avoid a strong reference cycle:</span><!--end_enstr-->
<span class="jpstr">
クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはその<code class="docutils literal notranslate"><span class="pre">customer</span></code>プロパティを非所有参照として定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Customer</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">var</span> <span class="nv">card</span>: <span class="nc">CreditCard</span>?
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">CreditCard</span> {
</li><li>    <span class="k">let</span> <span class="nv">number</span>: <span class="nc">UInt64</span>
</li><li>    <span class="k">unowned</span> <span class="k">let</span> <span class="nv">customer</span>: <span class="nc">Customer</span>
</li><li>    <span class="k">init</span>(<span class="nv">number</span>: <span class="nc">UInt64</span>, <span class="nv">customer</span>: <span class="nc">Customer</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">number</span> = <span class="nv">number</span>
</li><li>        <span class="k">self</span>.<span class="nv">customer</span> = <span class="nv">customer</span>
</li><li>    }
</li><li>    <span class="k">deinit</span> { <span class="nv">print</span>(<span class="s">"Card #</span>\<span class="p">(</span><span class="nv">number</span><span class="p">)</span><span class="s"> is being deinitialized"</span>) }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">number</span></code> property of the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> class is defined with a type of <code class="docutils literal notranslate"><span class="pre">UInt64</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Int</span></code>, to ensure that the <code class="docutils literal notranslate"><span class="pre">number</span></code> property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>クラスの<code class="docutils literal notranslate"><span class="pre">number</span></code>プロパティは、<code class="docutils literal notranslate"><span class="pre">UInt64</span></code>の型で定義されます、<code class="docutils literal notranslate"><span class="pre">Int</span></code>ではなく、それによって<code class="docutils literal notranslate"><span class="pre">number</span></code>プロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">This next code snippet defines an optional <code class="docutils literal notranslate"><span class="pre">Customer</span></code> variable called <code class="docutils literal notranslate"><span class="pre">john</span></code>, which will be used to store a reference to a specific customer. This variable has an initial value of nil, by virtue of being optional:</span><!--end_enstr-->
<span class="jpstr">
次のコード断片は、<code class="docutils literal notranslate"><span class="pre">john</span></code>と呼ばれる、オプショナルの<code class="docutils literal notranslate"><span class="pre">Customer</span></code>変数を定義します。それは、特定の顧客への参照を格納するために使われます。オプショナルであるおかげで、この変数はnilの初期値を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">john</span>: <span class="nc">Customer</span>?
</li></ol></div></div></div>
<p><span class="enstr">You can now create a <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance, and use it to initialize and assign a new <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance as that customer’s <code class="docutils literal notranslate"><span class="pre">card</span></code> property:</span><!--end_enstr-->
<span class="jpstr">
あなたは、現在<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスを作成して、それを使って、新しい<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスを、その顧客の<code class="docutils literal notranslate"><span class="pre">card</span></code>プロパティとして初期化して代入することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="nv">Customer</span>(<span class="nv">name</span>: <span class="s">"John Appleseed"</span>)
</li><li><span class="nv">john</span>!.<span class="nv">card</span> = <span class="nv">CreditCard</span>(<span class="nv">number</span>: <span class="m">1234_5678_9012_3456</span>, <span class="nv">customer</span>: <span class="nv">john</span>!)
</li></ol></div></div></div>
<p><span class="enstr">Here’s how the references look, now that you’ve linked the two instances:</span><!--end_enstr-->
<span class="jpstr">
あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/unownedReference01_2x.png" class="align-center" src="../images/unownedReference01_2x.png" style="width: 626px;" />
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance now has a strong reference to the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance, and the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance has an unowned reference to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスは現在<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスへの強い参照を持ちます、そして、<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスは<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスへの非所有参照を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because of the unowned <code class="docutils literal notranslate"><span class="pre">customer</span></code> reference, when you break the strong reference held by the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
非所有<code class="docutils literal notranslate"><span class="pre">customer</span></code>参照であることから、あなたが<code class="docutils literal notranslate"><span class="pre">john</span></code>変数によって保持される強い参照を壊すとき、<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスへの強い参照はもうそれ以上ありません：
</span><!--end_jpstr-->
</p>
<img alt="../_images/unownedReference02_2x.png" class="align-center" src="../images/unownedReference02_2x.png" style="width: 626px;" />
<p><span class="enstr">Because there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance, it’s deallocated. After this happens, there are no more strong references to the <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance, and it too is deallocated:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスへの強い参照はもうないので、それは割り当て解除されます。これが起こったあと、<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">john</span> = <span class="k">nil</span>
</li><li><span class="c"><span class="enstr">// Prints "John Appleseed is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「John Appleseedは、デイニシャライズされた」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Prints "Card #1234567890123456 is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「カード#1234567890123456は、デイニシャライズされた」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The final code snippet above shows that the deinitializers for the <code class="docutils literal notranslate"><span class="pre">Customer</span></code> instance and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> instance both print their “deinitialized” messages after the <code class="docutils literal notranslate"><span class="pre">john</span></code> variable is set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</span><!--end_enstr-->
<span class="jpstr">
上の最後のコード断片は、<code class="docutils literal notranslate"><span class="pre">Customer</span></code>インスタンスと<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>インスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、<code class="docutils literal notranslate"><span class="pre">john</span></code>変数が<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定された後に出力することを示します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The examples above show how to use <em>safe</em> unowned references. Swift also provides <em>unsafe</em> unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons. As with all unsafe operations, you take on the responsibility for checking that code for safety.</span><!--end_enstr-->
<span class="jpstr">
上の例は、どのように<em>safe</em>非所有参照を使うかを示します。スウィフトはまた<em>unsafe</em>非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。すべての安全でない操作と同様に、あなたはコードの安全について検査する責任を持つようになります。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You indicate an unsafe unowned reference by writing <code class="docutils literal notranslate"><span class="pre">unowned(unsafe)</span></code>. If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</span><!--end_enstr-->
<span class="jpstr">
あなたは、安全でない非所有参照を<code class="docutils literal notranslate"><span class="pre">unowned(unsafe)</span></code>を書くことによって指し示します。あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID55">
<h3><span class="enstr">Unowned References and Implicitly Unwrapped Optional Properties<a class="headerlink" href="#ID55" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
非所有参照と暗黙的にアンラップされるオプショナルのプロパティ<a class="headerlink" href="#ID55" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
上の弱いおよび非所有参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Person</span></code> and <code class="docutils literal notranslate"><span class="pre">Apartment</span></code> example shows a situation where two properties, both of which are allowed to be <code class="docutils literal notranslate"><span class="pre">nil</span></code>, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Person</span></code>と<code class="docutils literal notranslate"><span class="pre">Apartment</span></code>の例は、２つのプロパティ、両方とも<code class="docutils literal notranslate"><span class="pre">nil</span></code>であることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。この筋書きは、弱い参照で最もよく解消されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Customer</span></code> and <code class="docutils literal notranslate"><span class="pre">CreditCard</span></code> example shows a situation where one property that is allowed to be <code class="docutils literal notranslate"><span class="pre">nil</span></code> and another property that cannot be <code class="docutils literal notranslate"><span class="pre">nil</span></code> have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Customer</span></code>と<code class="docutils literal notranslate"><span class="pre">CreditCard</span></code>の例は、<code class="docutils literal notranslate"><span class="pre">nil</span></code>であることを許されるあるプロパティと<code class="docutils literal notranslate"><span class="pre">nil</span></code>であることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。この筋書きは、非所有参照で最もよく解消されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, there is a third scenario, in which <em>both</em> properties should always have a value, and neither property should ever be <code class="docutils literal notranslate"><span class="pre">nil</span></code> once initialization is complete. In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</span><!--end_enstr-->
<span class="jpstr">
しかし、第３の筋書きがあります、そこにおいて<em>両方の</em>プロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決して<code class="docutils literal notranslate"><span class="pre">nil</span></code>であってはなりません。この筋書きにおいて、一方のクラス上の非所有プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.</span><!--end_enstr-->
<span class="jpstr">
これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。この節は、あなたにそのような関係を設定する方法を教えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines two classes, <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">City</span></code>, each of which stores an instance of the other class as a property. In this data model, every country must always have a capital city, and every city must always belong to a country. To represent this, the <code class="docutils literal notranslate"><span class="pre">Country</span></code> class has a <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property, and the <code class="docutils literal notranslate"><span class="pre">City</span></code> class has a <code class="docutils literal notranslate"><span class="pre">country</span></code> property:</span><!--end_enstr-->
<span class="jpstr">
下の例は２つのクラス、<code class="docutils literal notranslate"><span class="pre">Country</span></code>と<code class="docutils literal notranslate"><span class="pre">City</span></code>を定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。これを表すために、<code class="docutils literal notranslate"><span class="pre">Country</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティを持ちます、そして、<code class="docutils literal notranslate"><span class="pre">City</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">country</span></code>プロパティを持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Country</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">var</span> <span class="nv">capitalCity</span>: <span class="nc">City</span>!
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">capitalName</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        <span class="k">self</span>.<span class="nv">capitalCity</span> = <span class="nv">City</span>(<span class="nv">name</span>: <span class="nv">capitalName</span>, <span class="nv">country</span>: <span class="k">self</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">City</span> {
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">unowned</span> <span class="k">let</span> <span class="nv">country</span>: <span class="nc">Country</span>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">country</span>: <span class="nc">Country</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        <span class="k">self</span>.<span class="nv">country</span> = <span class="nv">country</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">To set up the interdependency between the two classes, the initializer for <code class="docutils literal notranslate"><span class="pre">City</span></code> takes a <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance, and stores this instance in its <code class="docutils literal notranslate"><span class="pre">country</span></code> property.</span><!--end_enstr-->
<span class="jpstr">
２つのクラスの間で相互依存を設定するために、<code class="docutils literal notranslate"><span class="pre">City</span></code>のためのイニシャライザは、<code class="docutils literal notranslate"><span class="pre">Country</span></code>インスタンスをとって、このインスタンスをそれの<code class="docutils literal notranslate"><span class="pre">country</span></code>プロパティに保管します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The initializer for <code class="docutils literal notranslate"><span class="pre">City</span></code> is called from within the initializer for <code class="docutils literal notranslate"><span class="pre">Country</span></code>. However, the initializer for <code class="docutils literal notranslate"><span class="pre">Country</span></code> cannot pass <code class="docutils literal notranslate"><span class="pre">self</span></code> to the <code class="docutils literal notranslate"><span class="pre">City</span></code> initializer until a new <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance is fully initialized, as described in <a class="reference internal" href="Initialization.html#ID220"><span class="std std-ref">Two-Phase Initialization</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">City</span></code>のためのイニシャライザは、<code class="docutils literal notranslate"><span class="pre">Country</span></code>のためにイニシャライザの内部から呼ばれます。しかし、<code class="docutils literal notranslate"><span class="pre">Country</span></code>のためのイニシャライザは、<code class="docutils literal notranslate"><span class="pre">self</span></code>を<code class="docutils literal notranslate"><span class="pre">City</span></code>イニシャライザに渡すことが、新しい<code class="docutils literal notranslate"><span class="pre">Country</span></code>インスタンスが完全に初期化されるまでできません、<a class="reference internal" href="Initialization.html#ID220"><span class="std std-ref">２段階初期化</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To cope with this requirement, you declare the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property of <code class="docutils literal notranslate"><span class="pre">Country</span></code> as an implicitly unwrapped optional property, indicated by the exclamation mark at the end of its type annotation (<code class="docutils literal notranslate"><span class="pre">City!</span></code>). This means that the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property has a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, like any other optional, but can be accessed without the need to unwrap its value as described in <a class="reference internal" href="TheBasics.html#ID334"><span class="std std-ref">Implicitly Unwrapped Optionals</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この必要条件に対処するために、あなたは<code class="docutils literal notranslate"><span class="pre">Country</span></code>の<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（<code class="docutils literal notranslate"><span class="pre">City!</span></code>）。これは、<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティが、オプショナルの他のものの様に、<code class="docutils literal notranslate"><span class="pre">nil</span></code>の省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します、<a class="reference internal" href="TheBasics.html#ID334"><span class="std std-ref">暗黙的にアンラップされるオプショナル</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> has a default <code class="docutils literal notranslate"><span class="pre">nil</span></code> value, a new <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance is considered fully initialized as soon as the <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance sets its <code class="docutils literal notranslate"><span class="pre">name</span></code> property within its initializer. This means that the <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer can start to reference and pass around the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property as soon as the <code class="docutils literal notranslate"><span class="pre">name</span></code> property is set. The <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer can therefore pass <code class="docutils literal notranslate"><span class="pre">self</span></code> as one of the parameters for the <code class="docutils literal notranslate"><span class="pre">City</span></code> initializer when the <code class="docutils literal notranslate"><span class="pre">Country</span></code> initializer is setting its own <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>が省略時の<code class="docutils literal notranslate"><span class="pre">nil</span></code>値を持つので、新しい<code class="docutils literal notranslate"><span class="pre">Country</span></code>インスタンスは、<code class="docutils literal notranslate"><span class="pre">Country</span></code>インスタンスがそのイニシャライザ内でその<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティを設定するとすぐに、完全に初期化されると見なされます。これは<code class="docutils literal notranslate"><span class="pre">Country</span></code>イニシャライザが、<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティが設定されるとすぐに、暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティに基づいて参照したり渡したりを可能であるのを意味します。<code class="docutils literal notranslate"><span class="pre">Country</span></code>イニシャライザはしたがって、<code class="docutils literal notranslate"><span class="pre">self</span></code>を<code class="docutils literal notranslate"><span class="pre">City</span></code>イニシャライザのパラメータの１つとして渡すことが、<code class="docutils literal notranslate"><span class="pre">Country</span></code>イニシャライザが自身の<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティを設定しているときに可能です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">All of this means that you can create the <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">City</span></code> instances in a single statement, without creating a strong reference cycle, and the <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property can be accessed directly, without needing to use an exclamation mark to unwrap its optional value:</span><!--end_enstr-->
<span class="jpstr">
これの全ては、あなたが<code class="docutils literal notranslate"><span class="pre">Country</span></code>と<code class="docutils literal notranslate"><span class="pre">City</span></code>インスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">country</span> = <span class="nv">Country</span>(<span class="nv">name</span>: <span class="s">"Canada"</span>, <span class="nv">capitalName</span>: <span class="s">"Ottawa"</span>)
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">country</span>.<span class="nv">name</span><span class="p">)</span><span class="s">'s capital city is called </span>\<span class="p">(</span><span class="nv">country</span>.<span class="nv">capitalCity</span>.<span class="nv">name</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c"><span class="enstr">// Prints "Canada's capital city is called Ottawa"</span><!--end_enstr--><span class="jpstr">（「カナダの首都はオタワです」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied. The <code class="docutils literal notranslate"><span class="pre">capitalCity</span></code> property can be used and accessed like a non-optional value once initialization is complete, while still avoiding a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。<code class="docutils literal notranslate"><span class="pre">capitalCity</span></code>プロパティは、一旦初期化が完了すれば、非オプショナルの値のように使用およびアクセスされることが可能です、その一方で依然として強い参照循環を防ぎます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID56">
<h2><span class="enstr">Strong Reference Cycles for Closures<a class="headerlink" href="#ID56" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャのための強い参照循環<a class="headerlink" href="#ID56" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other. You also saw how to use weak and unowned references to break these strong reference cycles.</span><!--end_enstr-->
<span class="jpstr">
あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有参照を使う方法を見ました。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as <code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code>, or because the closure calls a method on the instance, such as <code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code>. In either case, these accesses cause the closure to “capture” <code class="docutils literal notranslate"><span class="pre">self</span></code>, creating a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。この捕獲は、例えば<code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code>のようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えば<code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code>のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくって<code class="docutils literal notranslate"><span class="pre">self</span></code>を「捕獲する」ことを引き起こします
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This strong reference cycle occurs because closures, like classes, are <em>reference types</em>. When you assign a closure to a property, you are assigning a <em>reference</em> to that closure. In essence, it’s the same problem as above—two strong references are keeping each other alive. However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</span><!--end_enstr-->
<span class="jpstr">
この強い参照循環は、クロージャが、クラスの様に<em>参照型</em>であるために起こります。あなたがクロージャをプロパティに代入するとき、あなたは<em>参照</em>をそのクロージャに代入しています。本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides an elegant solution to this problem, known as a <em>closure capture list</em>. However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはこの問題の洗練された解答、<em>クロージャ捕獲リスト</em>として知られるものを提供します。しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below shows how you can create a strong reference cycle when using a closure that references <code class="docutils literal notranslate"><span class="pre">self</span></code>. This example defines a class called <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>, which provides a simple model for an individual element within an HTML document:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">self</span></code>に参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。この例は<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>と呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">HTMLElement</span> {
</li><li>
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>?
</li><li>
</li><li>    <span class="k">lazy</span> <span class="k">var</span> <span class="nv">asHTML</span>: () -&gt; <span class="nc">String</span> = {
</li><li>        <span class="k">if</span> <span class="k">let</span> <span class="nv">text</span> = <span class="k">self</span>.<span class="nv">text</span> {
</li><li>            <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">text</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>        } <span class="k">else</span> {
</li><li>            <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s"> /&gt;"</span>
</li><li>        }
</li><li>    }
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">text</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">deinit</span> {
</li><li>        <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class defines a <code class="docutils literal notranslate"><span class="pre">name</span></code> property, which indicates the name of the element, such as <code class="docutils literal notranslate"><span class="pre">"h1"</span></code> for a heading element, <code class="docutils literal notranslate"><span class="pre">"p"</span></code> for a paragraph element, or <code class="docutils literal notranslate"><span class="pre">"br"</span></code> for a line break element. <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> also defines an optional <code class="docutils literal notranslate"><span class="pre">text</span></code> property, which you can set to a string that represents the text to be rendered within that HTML element.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の<code class="docutils literal notranslate"><span class="pre">"h1"</span></code>、段落要素のための<code class="docutils literal notranslate"><span class="pre">"p"</span></code>、またはあるいは、改行のための<code class="docutils literal notranslate"><span class="pre">"br"</span></code>要素など。<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>はまた、オプショナルの<code class="docutils literal notranslate"><span class="pre">text</span></code>プロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition to these two simple properties, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class defines a lazy property called <code class="docutils literal notranslate"><span class="pre">asHTML</span></code>. This property references a closure that combines <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">text</span></code> into an HTML string fragment. The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is of type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>, or “a function that takes no parameters, and returns a <code class="docutils literal notranslate"><span class="pre">String</span></code> value”.</span><!--end_enstr-->
<span class="jpstr">
これらの２つの単純なプロパティに加えて、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスは、<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>と呼ばれる遅延プロパティを定義します。このプロパティは、<code class="docutils literal notranslate"><span class="pre">name</span></code>と<code class="docutils literal notranslate"><span class="pre">text</span></code>をHTML文字列断片に結合するクロージャに参照をつけます。<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは型<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>です、あるいは「パラメータをとらなくて、<code class="docutils literal notranslate"><span class="pre">String</span></code>値を返す関数」。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">By default, the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional <code class="docutils literal notranslate"><span class="pre">text</span></code> value if it exists, or no text content if <code class="docutils literal notranslate"><span class="pre">text</span></code> does not exist. For a paragraph element, the closure would return <code class="docutils literal notranslate"><span class="pre">"&lt;p&gt;some</span> <span class="pre">text&lt;/p&gt;"</span></code> or <code class="docutils literal notranslate"><span class="pre">"&lt;p</span> <span class="pre">/&gt;"</span></code>, depending on whether the <code class="docutils literal notranslate"><span class="pre">text</span></code> property equals <code class="docutils literal notranslate"><span class="pre">"some</span> <span class="pre">text"</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</span><!--end_enstr-->
<span class="jpstr">
特に何もしなければ、<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。このタグは、それが存在するならばオプショナルの<code class="docutils literal notranslate"><span class="pre">text</span></code>値を、あるいは<code class="docutils literal notranslate"><span class="pre">text</span></code>が存在しないならば、無いテキスト内容を含みます。段落要素のために、このクロージャは、<code class="docutils literal notranslate"><span class="pre">"&lt;p&gt;some</span> <span class="pre">text&lt;/p&gt;"</span></code>または<code class="docutils literal notranslate"><span class="pre">"&lt;p</span> <span class="pre">/&gt;"</span></code>を返します、<code class="docutils literal notranslate"><span class="pre">text</span></code>プロパティが<code class="docutils literal notranslate"><span class="pre">"some</span> <span class="pre">text"</span></code>に等しいまたは<code class="docutils literal notranslate"><span class="pre">nil</span></code>かどうかに従って。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is named and used somewhat like an instance method. However, because <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> is a closure property rather than an instance method, you can replace the default value of the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。しかし、<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>はインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャで<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティの省略時の値を置き替えることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property could be set to a closure that defaults to some text if the <code class="docutils literal notranslate"><span class="pre">text</span></code> property is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, in order to prevent the representation from returning an empty HTML tag:</span><!--end_enstr-->
<span class="jpstr">
例えば、<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは、あるクロージャに設定されることができます、それは<code class="docutils literal notranslate"><span class="pre">text</span></code>プロパティが<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">heading</span> = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"h1"</span>)
</li><li><span class="k">let</span> <span class="nv">defaultText</span> = <span class="s">"some default text"</span>
</li><li><span class="nv">heading</span>.<span class="nv">asHTML</span> = {
</li><li>    <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">text</span> ?? <span class="nv">defaultText</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="nv">heading</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">heading</span>.<span class="nv">asHTML</span>())
</li><li><span class="c"><span class="enstr">// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</span><!--end_enstr--><span class="jpstr">（「&lt;h1&gt;some default text&lt;/h1&gt;」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> is a lazy property means that you can refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> within the default closure, because the lazy property will not be accessed until after initialization has been completed and <code class="docutils literal notranslate"><span class="pre">self</span></code> is known to exist.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>が遅延プロパティだという事実は、あなたが省略時のクロージャ内で<code class="docutils literal notranslate"><span class="pre">self</span></code>に言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまって<code class="docutils literal notranslate"><span class="pre">self</span></code>が存在することを知られる後までアクセスされることはないからです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class provides a single initializer, which takes a <code class="docutils literal notranslate"><span class="pre">name</span></code> argument and (if desired) a <code class="docutils literal notranslate"><span class="pre">text</span></code> argument to initialize a new element. The class also defines a deinitializer, which prints a message to show when an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is deallocated.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスは１つのイニシャライザを提供します、それは、<code class="docutils literal notranslate"><span class="pre">name</span></code>引数と（希望する場合には）<code class="docutils literal notranslate"><span class="pre">text</span></code>引数をとって新しい要素を初期化します。クラスもデイニシャライザを定義します、それは、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスが割り当て解除される場合に示すメッセージを出力します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how you use the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class to create and print a new instance:</span><!--end_enstr-->
<span class="jpstr">
あなたが新しいインスタンスを作成して出力するために<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスを使用する方法は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">paragraph</span>: <span class="nc">HTMLElement</span>? = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"p"</span>, <span class="nv">text</span>: <span class="s">"hello, world"</span>)
</li><li><span class="nv">print</span>(<span class="nv">paragraph</span>!.<span class="nv">asHTML</span>())
</li><li><span class="c"><span class="enstr">// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</span><!--end_enstr--><span class="jpstr">（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable above is defined as an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>, so that it can be set to <code class="docutils literal notranslate"><span class="pre">nil</span></code> below to demonstrate the presence of a strong reference cycle.</span><!--end_enstr-->
<span class="jpstr">
上記の<code class="docutils literal notranslate"><span class="pre">paragraph</span></code>変数は、<em>オプショナル</em>の<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>として定義されます、それでそれは下で強い参照循環の存在を例示するために<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定されることができます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Unfortunately, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class, as written above, creates a strong reference cycle between an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance and the closure used for its default <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> value. Here’s how the cycle looks:</span><!--end_enstr-->
<span class="jpstr">
残念なことに、この<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスは、上で書かれるように、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスとその省略時の<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>値のために使われるクロージャとの間に強い参照循環をつくります。循環がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/closureReferenceCycle01_2x.png" class="align-center" src="../images/closureReferenceCycle01_2x.png" style="width: 626px;" />
<p><span class="enstr">The instance’s <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> property holds a strong reference to its closure. However, because the closure refers to <code class="docutils literal notranslate"><span class="pre">self</span></code> within its body (as a way to reference <code class="docutils literal notranslate"><span class="pre">self.name</span></code> and <code class="docutils literal notranslate"><span class="pre">self.text</span></code>), the closure <em>captures</em> self, which means that it holds a strong reference back to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance. A strong reference cycle is created between the two. (For more information about capturing values in a closure, see <a class="reference internal" href="Closures.html#ID103"><span class="std std-ref">Capturing Values</span></a>.)</span><!--end_enstr-->
<span class="jpstr">
このインスタンスの<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>プロパティは、それのクロージャに対する強い参照を保持します。しかし、クロージャがその本文内で<code class="docutils literal notranslate"><span class="pre">self</span></code>に言及する（<code class="docutils literal notranslate"><span class="pre">self.name</span></code>と<code class="docutils literal notranslate"><span class="pre">self.text</span></code>を参照する方法として）ので、クロージャはselfを<em>捕獲</em>します、それは、今度は逆にそれが<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスへの強い参照を保持することを意味します。強い参照循環は、２つ作られます。（クロージャにおいて値を捕獲することに関する詳細は、<a class="reference internal" href="Closures.html#ID103"><span class="std std-ref">値を捕獲する</span></a>を見てください。）
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Even though the closure refers to <code class="docutils literal notranslate"><span class="pre">self</span></code> multiple times, it only captures one strong reference to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
たとえクロージャが複数回<code class="docutils literal notranslate"><span class="pre">self</span></code>に言及するとしても、それはその<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスへの１つの強い参照を捕獲するだけです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If you set the <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable to <code class="docutils literal notranslate"><span class="pre">nil</span></code> and break its strong reference to the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance, neither the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance nor its closure are deallocated, because of the strong reference cycle:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">paragraph</span></code>変数を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定して、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>へのそれの強い参照を壊すならば、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">paragraph</span> = <span class="k">nil</span>
</li></ol></div></div></div>
<p><span class="enstr">Note that the message in the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> deinitializer is not printed, which shows that the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is not deallocated.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>デイニシャライザにおけるメッセージが出力されないことに注意してください、それは、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスが割り当て解除されないことを示します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID57">
<h2><span class="enstr">Resolving Strong Reference Cycles for Closures<a class="headerlink" href="#ID57" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャのための強い参照循環の解消<a class="headerlink" href="#ID57" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You resolve a strong reference cycle between a closure and a class instance by defining a <em>capture list</em> as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</span><!--end_enstr-->
<span class="jpstr">
あなたは、クロージャの定義の一部として<em>捕獲リスト</em>を定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。捕獲リストは、クロージャの本文内で１つ以上の参照型を捕獲するとき使用する規則を定義します。２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有参照であると宣言します。弱いまたは非所有の適切な選択は、あなたのコードの異なる部分間の関係に依存します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift requires you to write <code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code> or <code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code> (rather than just <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> or <code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>) whenever you refer to a member of <code class="docutils literal notranslate"><span class="pre">self</span></code> within a closure. This helps you remember that it’s possible to capture <code class="docutils literal notranslate"><span class="pre">self</span></code> by accident.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはあなたに<code class="docutils literal notranslate"><span class="pre">self.someProperty</span></code>または<code class="docutils literal notranslate"><span class="pre">self.someMethod()</span></code>（ただ単に<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>または<code class="docutils literal notranslate"><span class="pre">someMethod()</span></code>ではなく）を書くことを、あなたがクロージャ内で<code class="docutils literal notranslate"><span class="pre">self</span></code>のメンバーに言及するときはいつでも、要求します。これは、偶然に<code class="docutils literal notranslate"><span class="pre">self</span></code>を捕らえることは可能であるのをあなたが忘れないことを手助けします。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID58">
<h3><span class="enstr">Defining a Capture List<a class="headerlink" href="#ID58" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
捕獲リストの定義<a class="headerlink" href="#ID58" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Each item in a capture list is a pairing of the <code class="docutils literal notranslate"><span class="pre">weak</span></code> or <code class="docutils literal notranslate"><span class="pre">unowned</span></code> keyword with a reference to a class instance (such as <code class="docutils literal notranslate"><span class="pre">self</span></code>) or a variable initialized with some value (such as <code class="docutils literal notranslate"><span class="pre">delegate</span> <span class="pre">=</span> <span class="pre">self.delegate!</span></code>). These pairings are written within a pair of square braces, separated by commas.</span><!--end_enstr-->
<span class="jpstr">
捕獲リストの各項目は、<code class="docutils literal notranslate"><span class="pre">weak</span></code>または<code class="docutils literal notranslate"><span class="pre">unowned</span></code>キーワードと、クラスインスタンスへの参照（例えば<code class="docutils literal notranslate"><span class="pre">self</span></code>）またはなんらかの値で初期化された変数（例えば<code class="docutils literal notranslate"><span class="pre">delegate</span> <span class="pre">=</span> <span class="pre">self.delegate!</span></code>）を対にしたものです。これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Place the capture list before a closure’s parameter list and return type if they are provided:</span><!--end_enstr-->
<span class="jpstr">
それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">lazy</span> <span class="k">var</span> <span class="nv">someClosure</span>: (<span class="nc">Int</span>, <span class="nc">String</span>) -&gt; <span class="nc">String</span> = {
</li><li>    [<span class="nv">unowned</span> <span class="k">self</span>, <span class="nv">weak</span> <span class="nv">delegate</span> = <span class="k">self</span>.<span class="nv">delegate</span>!] (<span class="nv">index</span>: <span class="nc">Int</span>, <span class="nv">stringToProcess</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> <span class="k">in</span>
</li><li>    <span class="c"><span class="enstr">// closure body goes here</span><!--end_enstr--><span class="jpstr">（クロージャ本文が、ここにきます）</span><!--end_jpstr--></span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword:</span><!--end_enstr-->
<span class="jpstr">
クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードに続けて置いてください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">lazy</span> <span class="k">var</span> <span class="nv">someClosure</span>: () -&gt; <span class="nc">String</span> = {
</li><li>    [<span class="nv">unowned</span> <span class="k">self</span>, <span class="nv">weak</span> <span class="nv">delegate</span> = <span class="k">self</span>.<span class="nv">delegate</span>!] <span class="k">in</span>
</li><li>    <span class="c"><span class="enstr">// closure body goes here</span><!--end_enstr--><span class="jpstr">（クロージャ本文が、ここにきます）</span><!--end_jpstr--></span>
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID59">
<h3><span class="enstr">Weak and Unowned References<a class="headerlink" href="#ID59" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
弱いおよび非所有参照<a class="headerlink" href="#ID59" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</span><!--end_enstr-->
<span class="jpstr">
それが捕らえるクロージャとインスタンスが常にお互いに言及して、常に同時に割り当て解除されるときは、クロージャにおいて捕獲を非所有参照として定義してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Conversely, define a capture as a weak reference when the captured reference may become <code class="docutils literal notranslate"><span class="pre">nil</span></code> at some point in the future. Weak references are always of an optional type, and automatically become <code class="docutils literal notranslate"><span class="pre">nil</span></code> when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</span><!--end_enstr-->
<span class="jpstr">
逆に、捕らえられた参照が将来どこかの時点で<code class="docutils literal notranslate"><span class="pre">nil</span></code>になるかもしれないときは、捕獲を弱い参照として定義してください。弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的に<code class="docutils literal notranslate"><span class="pre">nil</span></code>になります。これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If the captured reference will never become <code class="docutils literal notranslate"><span class="pre">nil</span></code>, it should always be captured as an unowned reference, rather than a weak reference.</span><!--end_enstr-->
<span class="jpstr">
捕獲された参照が決して<code class="docutils literal notranslate"><span class="pre">nil</span></code>にならないならば、それは常に、非所有参照として捕らえられなければなりません、弱い参照ではなくて。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> example from <a class="reference internal" href="#ID56"><span class="std std-ref">Strong Reference Cycles for Closures</span></a> above. Here’s how you write the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> class to avoid the cycle:</span><!--end_enstr-->
<span class="jpstr">
非所有参照は、上の<a class="reference internal" href="#ID56"><span class="std std-ref">クロージャのための強い参照循環</span></a>の<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。ここに、あなたが<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>クラスを循環を避けるように書く方法があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">HTMLElement</span> {
</li><li>
</li><li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>    <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>?
</li><li>
</li><li>    <span class="k">lazy</span> <span class="k">var</span> <span class="nv">asHTML</span>: () -&gt; <span class="nc">String</span> = {
</li><li>        [<span class="nv">unowned</span> <span class="k">self</span>] <span class="k">in</span>
</li><li>        <span class="k">if</span> <span class="k">let</span> <span class="nv">text</span> = <span class="k">self</span>.<span class="nv">text</span> {
</li><li>            <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;</span>\<span class="p">(</span><span class="nv">text</span><span class="p">)</span><span class="s">&lt;/</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s">&gt;"</span>
</li><li>        } <span class="k">else</span> {
</li><li>            <span class="k">return</span> <span class="s">"&lt;</span>\<span class="p">(</span><span class="k">self</span>.<span class="nv">name</span><span class="p">)</span><span class="s"> /&gt;"</span>
</li><li>        }
</li><li>    }
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">text</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>        <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">deinit</span> {
</li><li>        <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s"> is being deinitialized"</span>)
</li><li>    }
</li><li>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">This implementation of <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> is identical to the previous implementation, apart from the addition of a capture list within the <code class="docutils literal notranslate"><span class="pre">asHTML</span></code> closure. In this case, the capture list is <code class="docutils literal notranslate"><span class="pre">[unowned</span> <span class="pre">self]</span></code>, which means “capture self as an unowned reference rather than a strong reference”.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>のこの実装は、<code class="docutils literal notranslate"><span class="pre">asHTML</span></code>クロージャ内の捕獲リストの追加は別として、前の実装と同一です。この場合、捕獲リストは<code class="docutils literal notranslate"><span class="pre">[unowned</span> <span class="pre">self]</span></code>です、それは、「selfを強い参照ではなく非所有参照として捕獲する」ことを意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can create and print an <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance as before:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスを前の通り作成して出力することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">paragraph</span>: <span class="nc">HTMLElement</span>? = <span class="nv">HTMLElement</span>(<span class="nv">name</span>: <span class="s">"p"</span>, <span class="nv">text</span>: <span class="s">"hello, world"</span>)
</li><li><span class="nv">print</span>(<span class="nv">paragraph</span>!.<span class="nv">asHTML</span>())
</li><li><span class="c"><span class="enstr">// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</span><!--end_enstr--><span class="jpstr">（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Here’s how the references look with the capture list in place:</span><!--end_enstr-->
<span class="jpstr">
捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/closureReferenceCycle02_2x.png" class="align-center" src="../images/closureReferenceCycle02_2x.png" style="width: 626px;" />
<p><span class="enstr">This time, the capture of <code class="docutils literal notranslate"><span class="pre">self</span></code> by the closure is an unowned reference, and does not keep a strong hold on the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance it has captured. If you set the strong reference from the <code class="docutils literal notranslate"><span class="pre">paragraph</span></code> variable to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the <code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code> instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</span><!--end_enstr-->
<span class="jpstr">
今度は、クロージャによる<code class="docutils literal notranslate"><span class="pre">self</span></code>の捕獲は非所有参照であって、それが捕獲している<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスに対する強い支配力を保ちません。あなたが強い参照である<code class="docutils literal notranslate"><span class="pre">paragraph</span></code>変数を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定するならば、その<code class="docutils literal notranslate"><span class="pre">HTMLElement</span></code>インスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">paragraph</span> = <span class="k">nil</span>
</li><li><span class="c"><span class="enstr">// Prints "p is being deinitialized"</span><!--end_enstr--><span class="jpstr">（「pは、デイニシャライズされている」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">For more information about capture lists, see <a class="reference internal" href="../ReferenceManual/Expressions.html#ID544"><span class="std std-ref">Capture Lists</span></a>.</span><!--end_enstr-->
<span class="jpstr">
キャプチャリストについての更なる情報として、<a class="reference internal" href="../ReferenceManual/Expressions.html#ID544"><span class="std std-ref">キャプチャリスト</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          <span class="enstr">This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</span><!--end_enstr-->
<span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->

        </p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
