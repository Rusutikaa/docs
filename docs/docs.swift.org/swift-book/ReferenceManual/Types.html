

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Types &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="AboutTheLanguageReference.html">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="LexicalStructure.html">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Expressions.html">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Statements.html">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Declarations.html">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Attributes.html">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Patterns.html">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="GenericParametersAndArguments.html">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="zzSummaryOfTheGrammar.html">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="https://swift.org/">← Return to Swift.org</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID446">Type Annotation<br><span class="jpstr">
型注釈
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID447">Type Identifier<br><span class="jpstr">
型識別子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID448">Tuple Type<br><span class="jpstr">
タプル型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID449">Function Type<br><span class="jpstr">
関数型
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID572">Restrictions for Nonescaping Closures<br><span class="jpstr">
非脱出クロージャに対する規制
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID450">Array Type<br><span class="jpstr">
配列型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID451">Dictionary Type<br><span class="jpstr">
辞書型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID452">Optional Type<br><span class="jpstr">
オプショナル型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID453">Implicitly Unwrapped Optional Type<br><span class="jpstr">
暗黙的にアンラップされるオプショナルの型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID454">Protocol Composition Type<br><span class="jpstr">
プロトコル合成型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID455">Metatype Type<br><span class="jpstr">
メタタイプ型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID456">Type Inheritance Clause<br><span class="jpstr">
型継承節
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID457">Type Inference<br><span class="jpstr">
型推論
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="types">
<h1>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a><br><span class="jpstr">
型<a class="headerlink" href="#types" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p>In Swift, there are two kinds of types: named types and compound types. A <em>named type</em> is a type that can be given a particular name when it’s defined. Named types include classes, structures, enumerations, and protocols. For example, instances of a user-defined class named <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> have the type <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.<br><span class="jpstr">
スウィフトには、２つの種類の型：名前付きの型と複合の型があります。<em>名前付きの型</em>は、それが定義される時に特定の名前を与えられることができる型です。名前付きの型は、クラス、構造体、列挙、そしてプロトコルを含みます。例えば、<code class="docutils literal notranslate"><span class="pre">MyClass</span></code>という名前をつけられるユーザー定義のクラスのインスタンスは、型<code class="docutils literal notranslate"><span class="pre">MyClass</span></code>を持ちます。ユーザー定義の名前付きの型に加えて、スウィフト標準ライブラリは、配列、辞書、そしてオプショナル値を表すものたちを含む、多くの一般に使われる名前付きの型を定義します。
</span><!--end_jpstr-->
</p>
<p>Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures. Because they’re named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in <a class="reference internal" href="../LanguageGuide/Extensions.html"><span class="doc">Extensions</span></a> and <a class="reference internal" href="Declarations.html#ID378"><span class="std std-ref">Extension Declaration</span></a>.<br><span class="jpstr">
他の言語で通常は基本的またはプリミティブであるとみなされるデータ型 ― 例えば数、文字、そして文字列を表す型 ― これらは実際に名前付きの型で、構造体を使用してスウィフト標準ライブラリにおいて定義および実装されます。それらが名前付きの型であるので、あなたはそれらの挙動を、<a class="reference internal" href="../LanguageGuide/Extensions.html"><span class="doc">拡張</span></a>および<a class="reference internal" href="Declarations.html#ID378"><span class="std std-ref">拡張宣言</span></a>で議論される拡張宣言を使って、あなたのプログラムの必要に応じて拡張することができます。
</span><!--end_jpstr-->
</p>
<p>A <em>compound type</em> is a type without a name, defined in the Swift language itself. There are two compound types: function types and tuple types. A compound type may contain named types and other compound types. For instance, the tuple type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">(Int,</span> <span class="pre">Int))</span></code> contains two elements: The first is the named type <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and the second is another compound type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>.<br><span class="jpstr">
<em>複合の型</em>は名前のない型です、そしてスウィフト言語自身によって定義されます。２つの複合の型：関数型とタプル型があります。ひとつの複合の型は、名前付きの型や他の複合の型を含むかもしれません。たとえば、タプル型<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">(Int,</span> <span class="pre">Int))</span></code>は、２つの要素を含みます：第一は名前付きの型<code class="docutils literal notranslate"><span class="pre">Int</span></code>です、そして第二は別の複合の型<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>です。
</span><!--end_jpstr-->
</p>
<p>You can put parentheses around a named type or a compound type. However, adding parentheses around a type doesn’t have any effect. For example, <code class="docutils literal notranslate"><span class="pre">(Int)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">Int</span></code>.<br><span class="jpstr">
あなたは、名前付きの型や複合の型の周りに丸括弧を置くことができます。けれども、ある型の周りに丸括弧を加えることは全く影響はありません。例えば、<code class="docutils literal notranslate"><span class="pre">(Int)</span></code>は<code class="docutils literal notranslate"><span class="pre">Int</span></code>に等しいです。
</span><!--end_jpstr-->
</p>
<p>This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.<br><span class="jpstr">
この章は、スウィフト言語それ自身によって定義される型を議論して、スウィフトの型推論挙動を記載します。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type<br><span class="jpstr">
型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_array-type">array-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1206"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_dictionary-type">dictionary-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1207"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type">function-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1208"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1209"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type">tuple-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1210"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_optional-type">optional-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1211"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_implicitly-unwrapped-optional-type">implicitly-unwrapped-optional-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1212"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_protocol-composition-type">protocol-composition-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1213"></a>type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_metatype-type">metatype-type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1214"></a>type</span><span class="arrow"> → </span> <code>Any</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1215"></a>type</span><span class="arrow"> → </span> <code>Self</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type_1216"></a>type</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>)</code></p></div></div><div class="section" id="ID446">
<h2>Type Annotation<a class="headerlink" href="#ID446" title="Permalink to this headline">¶</a><br><span class="jpstr">
型注釈<a class="headerlink" href="#ID446" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>type annotation</em> explicitly specifies the type of a variable or expression. Type annotations begin with a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>) and end with a type, as the following examples show:<br><span class="jpstr">
ある<em>型注釈</em>は、明確に変数または式の型を指定します。型注釈は、以下の例が示すように、コロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で始まりひとつの型で終わります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someTuple</span>: (<span class="nc">Double</span>, <span class="nc">Double</span>) = (<span class="m">3.14159</span>, <span class="m">2.71828</span>)
</li><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">a</span>: <span class="nc">Int</span>) { <span class="c">/* ... */</span> }
</li></ol></div></div></div>
<p>In the first example, the expression <code class="docutils literal notranslate"><span class="pre">someTuple</span></code> is specified to have the tuple type <code class="docutils literal notranslate"><span class="pre">(Double,</span> <span class="pre">Double)</span></code>. In the second example, the parameter <code class="docutils literal notranslate"><span class="pre">a</span></code> to the function <code class="docutils literal notranslate"><span class="pre">someFunction</span></code> is specified to have the type <code class="docutils literal notranslate"><span class="pre">Int</span></code>.<br><span class="jpstr">
最初の例で、式<code class="docutils literal notranslate"><span class="pre">someTuple</span></code>は、タプル型<code class="docutils literal notranslate"><span class="pre">(Double,</span> <span class="pre">Double)</span></code>を持つと指定されます。第二の例で関数<code class="docutils literal notranslate"><span class="pre">someFunction</span></code>のためのパラメータ<code class="docutils literal notranslate"><span class="pre">a</span></code>は、型<code class="docutils literal notranslate"><span class="pre">Int</span></code>を持つ指定されます。
</span><!--end_jpstr-->
</p>
<p>Type annotations can contain an optional list of type attributes before the type.<br><span class="jpstr">
型注釈は、型の前に任意の型属性のリストを含むことができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type annotation<br><span class="jpstr">
型注釈の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-annotation"></a>type-annotation</span><span class="arrow"> → </span> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>inout</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p></div></div></div>
<div class="section" id="ID447">
<h2>Type Identifier<a class="headerlink" href="#ID447" title="Permalink to this headline">¶</a><br><span class="jpstr">
型識別子<a class="headerlink" href="#ID447" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A type identifier refers to either a named type or a type alias of a named or compound type.<br><span class="jpstr">
型識別子は、名前付きの型か、名前付きまたは複合の型の型エイリアスに言及します。
</span><!--end_jpstr-->
</p>
<p>Most of the time, a type identifier directly refers to a named type with the same name as the identifier. For example, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is a type identifier that directly refers to the named type <code class="docutils literal notranslate"><span class="pre">Int</span></code>, and the type identifier <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code> directly refers to the named type <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code>.<br><span class="jpstr">
ほとんどの場合、型識別子は、名前付きの型に、その識別子と同じ名前で直接に言及します。例えば、<code class="docutils literal notranslate"><span class="pre">Int</span></code>は、直接に名前付きの型<code class="docutils literal notranslate"><span class="pre">Int</span></code>に言及する型識別子です、そして型識別子<code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code>は、直接に名前付きの型<code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code>に言及します。
</span><!--end_jpstr-->
</p>
<p>There are two cases in which a type identifier doesn’t refer to a type with the same name. In the first case, a type identifier refers to a type alias of a named or compound type. For instance, in the example below, the use of <code class="docutils literal notranslate"><span class="pre">Point</span></code> in the type annotation refers to the tuple type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>.<br><span class="jpstr">
ある型識別子がある型に同じ名前で言及しない２つの場合があります。第一の場合には、型識別子は、名前付きまたは複合の型の型エイリアスに言及します。たとえば、下記の例で、型注釈において<code class="docutils literal notranslate"><span class="pre">Point</span></code>を使うことは、タプル型<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>に言及します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">Point</span> = (<span class="nc">Int</span>, <span class="nc">Int</span>)
</li><li><span class="k">let</span> <span class="nv">origin</span>: <span class="nc">Point</span> = (<span class="m">0</span>, <span class="m">0</span>)
</li></ol></div></div></div>
<p>In the second case, a type identifier uses dot (<code class="docutils literal notranslate"><span class="pre">.</span></code>) syntax to refer to named types declared in other modules or nested within other types. For example, the type identifier in the following code references the named type <code class="docutils literal notranslate"><span class="pre">MyType</span></code> that is declared in the <code class="docutils literal notranslate"><span class="pre">ExampleModule</span></code> module.<br><span class="jpstr">
第二の場合には、型識別子は、他のモジュールで宣言される、または他の型の内部で入れ子にされる名前付きの型を参照するためにドット（<code class="docutils literal notranslate"><span class="pre">.</span></code>）構文を使用します。例えば、以下のコードの型識別子は、<code class="docutils literal notranslate"><span class="pre">ExampleModule</span></code>モジュールで宣言される名前付きの型<code class="docutils literal notranslate"><span class="pre">MyType</span></code>を参照します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someValue</span>: <span class="nc">ExampleModule</span>.<span class="nc">MyType</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type identifier<br><span class="jpstr">
型識別子の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-identifier"></a>type-identifier</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-name">type-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-name">type-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-name"></a>type-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div></div>
<div class="section" id="ID448">
<h2>Tuple Type<a class="headerlink" href="#ID448" title="Permalink to this headline">¶</a></h2>
<p>A tuple type is a comma-separated list of types, enclosed in parentheses.<br><span class="jpstr">
タプル型は、丸括弧で囲まれた、コンマ区切りのいくらかの型のリストです。
</span><!--end_jpstr-->
</p>
<p>You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values. You can also name the elements of a tuple type and use those names to refer to the values of the individual elements. An element name consists of an identifier followed immediately by a colon (:). For an example that demonstrates both of these features, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID164"><span class="std std-ref">Functions with Multiple Return Values</span></a>.<br><span class="jpstr">
あなたは、関数の戻り型としてタプル型を使って、その関数に複数の値を含んでいる一つのタプルを返すのを可能にすることができます。あなたは、また、タプル型の要素に名をつけることができて、それらの名前を個々の要素の値に言及するために使用することができます。要素名は、識別子に直ちにコロン（：）が続くものから成ります。これらの特徴の両方を示す例のために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID164"><span class="std std-ref">複数の戻り値をもつ関数</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>When an element of a tuple type has a name, that name is part of the type.<br><span class="jpstr">
あるタプル型の要素が名前を持つ場合、その名前は型の一部です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">someTuple</span> = (<span class="nv">top</span>: <span class="m">10</span>, <span class="nv">bottom</span>: <span class="m">12</span>)  <span class="c">// someTuple is of type (top: Int, bottom: Int)&nbsp;<span class="jpstr"><span class="c">（someTupleは型 (top: Int, bottom: Int) です）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">someTuple</span> = (<span class="nv">top</span>: <span class="m">4</span>, <span class="nv">bottom</span>: <span class="m">42</span>) <span class="c">// OK: names match&nbsp;<span class="jpstr"><span class="c">（OK: 名前が一致）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">someTuple</span> = (<span class="m">9</span>, <span class="m">99</span>)              <span class="c">// OK: names are inferred&nbsp;<span class="jpstr"><span class="c">（OK: 名前は推論されます）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">someTuple</span> = (<span class="nv">left</span>: <span class="m">5</span>, <span class="nv">right</span>: <span class="m">5</span>)  <span class="c">// Error: names don&#39;t match&nbsp;<span class="jpstr"><span class="c">（エラー: 名前が一致しない）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p>All tuple types contain two or more types, except for <code class="docutils literal notranslate"><span class="pre">Void</span></code> which is a type alias for the empty tuple type, <code class="docutils literal notranslate"><span class="pre">()</span></code>.<br><span class="jpstr">
すべてのタプル型は２つまたはそれ以上の型を含みます、しかし空のタプル型、<code class="docutils literal notranslate"><span class="pre">()</span></code>に対する型エイリアスである<code class="docutils literal notranslate"><span class="pre">Void</span></code>を除きます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a tuple type<br><span class="jpstr">
タプル型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-type"></a>tuple-type</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type-element">tuple-type-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type-element-list">tuple-type-element-list</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-type-element-list"></a>tuple-type-element-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type-element">tuple-type-element</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type-element">tuple-type-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type-element-list">tuple-type-element-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-type-element"></a>tuple-type-element</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_element-name">element-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_element-name"></a>element-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div></div>
<div class="section" id="ID449">
<h2>Function Type<a class="headerlink" href="#ID449" title="Permalink to this headline">¶</a></h2>
<p>A function type represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>):<br><span class="jpstr">
関数型は、ある関数、メソッド、またはクロージャの型を表して、矢印（<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>）で区切られるパラメータと戻り型から成ります：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="gi">parameter type</span>) -&gt; <span class="gi">return type</span>
</li></ol></div></div></div>
<p>The <em>parameter type</em> is comma-separated list of types. Because the <em>return type</em> can be a tuple type, function types support functions and methods that return multiple values.<br><span class="jpstr">
<em>parameter type</em>コンマ区切りの型のリストです。<em>return type</em>はタプル型であることが可能なので、関数型は複数の値を返す関数およびメソッドをサポートします。
</span><!--end_jpstr-->
</p>
<p>A parameter of the function type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code> (where <code class="docutils literal notranslate"><span class="pre">T</span></code> is any type) can apply the <code class="docutils literal notranslate"><span class="pre">autoclosure</span></code> attribute to implicitly create a closure at its call sites. This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function. For an example of an autoclosure function type parameter, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID543"><span class="std std-ref">Autoclosures</span></a>.<br><span class="jpstr">
関数型<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>（ここで<code class="docutils literal notranslate"><span class="pre">T</span></code>はどんな型でも）のあるパラメータは、<code class="docutils literal notranslate"><span class="pre">autoclosure</span></code>属性を適用することによって、あるクロージャを暗黙的にそれの呼び出し領域で作成することができます。これは、あなたがその関数を呼び出す時に明示的なクロージャを書く必要なしに、ある式の評価を延期する統語的に便利な方法を提供します。自動クロージャ関数型パラメータの例として、<a class="reference internal" href="../LanguageGuide/Closures.html#ID543"><span class="std std-ref">自動クロージャ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>A function type can have a variadic parameter in its <em>parameter type</em>. Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (<code class="docutils literal notranslate"><span class="pre">...</span></code>), as in <code class="docutils literal notranslate"><span class="pre">Int...</span></code>. A variadic parameter is treated as an array that contains elements of the base type name. For instance, the variadic parameter <code class="docutils literal notranslate"><span class="pre">Int...</span></code> is treated as <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>. For an example that uses a variadic parameter, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID171"><span class="std std-ref">Variadic Parameters</span></a>.<br><span class="jpstr">
関数型は、その<em>パラメータ型</em>において可変長パラメータを持つことができます。統語的には、可変長パラメータは、<code class="docutils literal notranslate"><span class="pre">Int...</span></code>のように、基となる型名に直ちに３つの点（<code class="docutils literal notranslate"><span class="pre">...</span></code>）が続くものから成ります。可変長パラメータは、基本の型の名前の要素たちが入っている配列とみなされます。たとえば、可変長パラメータ<code class="docutils literal notranslate"><span class="pre">Int...</span></code>は<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>とみなされます。可変長パラメータを使う例のために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID171"><span class="std std-ref">可変長パラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>To specify an in-out parameter, prefix the parameter type with the <code class="docutils literal notranslate"><span class="pre">inout</span></code> keyword. You can’t mark a variadic parameter or a return type with the <code class="docutils literal notranslate"><span class="pre">inout</span></code> keyword. In-out parameters are discussed in <a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Out Parameters</span></a>.<br><span class="jpstr">
in-outパラメータを指定するために、<code class="docutils literal notranslate"><span class="pre">inout</span></code>キーワードをそのパラメータ型の前に置いてください。あなたは、可変長パラメータまたは戻り型に<code class="docutils literal notranslate"><span class="pre">inout</span></code>キーワードで印をつけることができません。in-outパラメータは、<a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">in-outパラメータ</span></a>で議論されます。
</span><!--end_jpstr-->
</p>
<p>If a function type has only one parameter and that parameter’s type is a tuple type, then the tuple type must be parenthesized when writing the function’s type. For example, <code class="docutils literal notranslate"><span class="pre">((Int,</span> <span class="pre">Int))</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code> is the type of a function that takes a single parameter of the tuple type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code> and doesn’t return any value. In contrast, without parentheses, <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code> is the type of a function that takes two <code class="docutils literal notranslate"><span class="pre">Int</span></code> parameters and doesn’t return any value. Likewise, because <code class="docutils literal notranslate"><span class="pre">Void</span></code> is a type alias for <code class="docutils literal notranslate"><span class="pre">()</span></code>, the function type <code class="docutils literal notranslate"><span class="pre">(Void)</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">(())</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code>—a function that takes a single argument that is an empty tuple. These types are not the same as <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code>—a function that takes no arguments.<br><span class="jpstr">
ある関数型がただ１つだけのパラメータを持ちそしてそのパラメータの型がタプル型であるならば、その場合そのタプル型は関数の型を記述する時に丸括弧に入れられなければなりません。例えば、<code class="docutils literal notranslate"><span class="pre">((Int,</span> <span class="pre">Int))</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>は、タプル型<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span></code>の単一のパラメータを取り、何ら値を返さない関数の型です対して、丸括弧なしで、<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>は、２つの<code class="docutils literal notranslate"><span class="pre">Int</span></code>パラメータを取り、何ら値を返さない関数の型です。同様に、<code class="docutils literal notranslate"><span class="pre">Void</span></code>が<code class="docutils literal notranslate"><span class="pre">()</span></code>に対する型エイリアスであることから、関数型<code class="docutils literal notranslate"><span class="pre">(Void)</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>は<code class="docutils literal notranslate"><span class="pre">(())</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code> — ただ１つの引数を取りそれが空のタプルである関数、と同じです。これらの型は、<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code> — 引数を取らない関数、と同じではありません。
</span><!--end_jpstr-->
</p>
<p>Argument names in functions and methods are not part of the corresponding function type. For example:<br><span class="jpstr">
関数やメソッドの引数名は、対応する関数型の一部ではありません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">left</span>: <span class="nc">Int</span>, <span class="nv">right</span>: <span class="nc">Int</span>) {}
</li><li><span class="k">func</span> <span class="nv">anotherFunction</span>(<span class="nv">left</span>: <span class="nc">Int</span>, <span class="nv">right</span>: <span class="nc">Int</span>) {}
</li><li><span class="k">func</span> <span class="nv">functionWithDifferentLabels</span>(<span class="nv">top</span>: <span class="nc">Int</span>, <span class="nv">bottom</span>: <span class="nc">Int</span>) {}
</li><li>
</li><li><span class="k">var</span> <span class="nv">f</span> = <span class="nv">someFunction</span> <span class="c">// The type of f is (Int, Int) -&gt; Void, not (left: Int, right: Int) -&gt; Void.</span>
</li><li><span class="nv">f</span> = <span class="nv">anotherFunction</span>              <span class="c">// OK</span>
</li><li><span class="nv">f</span> = <span class="nv">functionWithDifferentLabels</span>  <span class="c">// OK</span>
</li><li>
</li><li><span class="k">func</span> <span class="nv">functionWithDifferentArgumentTypes</span>(<span class="nv">left</span>: <span class="nc">Int</span>, <span class="nv">right</span>: <span class="nc">String</span>) {}
</li><li><span class="nv">f</span> = <span class="nv">functionWithDifferentArgumentTypes</span>     <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li><li>
</li><li><span class="k">func</span> <span class="nv">functionWithDifferentNumberOfArguments</span>(<span class="nv">left</span>: <span class="nc">Int</span>, <span class="nv">right</span>: <span class="nc">Int</span>, <span class="nv">top</span>: <span class="nc">Int</span>) {}
</li><li><span class="nv">f</span> = <span class="nv">functionWithDifferentNumberOfArguments</span> <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p>Because argument labels are not part of a function’s type, you omit them when writing a function type.<br><span class="jpstr">
引数ラベルは関数の型の一部ではないことから、あなたはそれらを関数型を書く時に省略します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">operation</span>: (<span class="nv">lhs</span>: <span class="nc">Int</span>, <span class="nv">rhs</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span>     <span class="c">// Error</span>
</li><li><span class="k">var</span> <span class="nv">operation</span>: (<span class="k">_</span> <span class="nv">lhs</span>: <span class="nc">Int</span>, <span class="k">_</span> <span class="nv">rhs</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> <span class="c">// OK</span>
</li><li><span class="k">var</span> <span class="nv">operation</span>: (<span class="nc">Int</span>, <span class="nc">Int</span>) -&gt; <span class="nc">Int</span>               <span class="c">// OK</span>
</li></ol></div></div></div>
<p>If a function type includes more than a single arrow (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>), the function types are grouped from right to left. For example, the function type <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> is understood as <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">((Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code>—that is, a function that takes an <code class="docutils literal notranslate"><span class="pre">Int</span></code> and returns another function that takes and returns an <code class="docutils literal notranslate"><span class="pre">Int</span></code>.<br><span class="jpstr">
ある関数型がただ１つだけの矢印（<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>）ではなくもっと多く含むならば、その関数型は右から左にグループにされます。例えば、関数型<code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>は、<code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">((Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code>として理解されます ― すなわち、ひとつの<code class="docutils literal notranslate"><span class="pre">Int</span></code>を取って、ひとつの<code class="docutils literal notranslate"><span class="pre">Int</span></code>を取りそして返す別の関数を返す関数。
</span><!--end_jpstr-->
</p>
<p>Function types that can throw an error must be marked with the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword, and function types that can rethrow an error must be marked with the <code class="docutils literal notranslate"><span class="pre">rethrows</span></code> keyword. The <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions. As a result, you can use a nonthrowing function in the same places as a throwing one. Throwing and rethrowing functions are described in <a class="reference internal" href="Declarations.html#ID530"><span class="std std-ref">Throwing Functions and Methods</span></a> and <a class="reference internal" href="Declarations.html#ID531"><span class="std std-ref">Rethrowing Functions and Methods</span></a>.<br><span class="jpstr">
エラーを投げ掛けること（スロー）ができる関数型は、<code class="docutils literal notranslate"><span class="pre">throws</span></code>キーワードで印されなければなりません、そしてエラーを再度投げ掛けること（再スロー）ができる関数型は、<code class="docutils literal notranslate"><span class="pre">rethrows</span></code>キーワードで印されなければなりません。<code class="docutils literal notranslate"><span class="pre">throws</span></code>キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。スローおよび再スロー関数は、<a class="reference internal" href="Declarations.html#ID530"><span class="std std-ref">スロー関数とメソッド</span></a>と<a class="reference internal" href="Declarations.html#ID531"><span class="std std-ref">再スロー関数とメソッド</span></a>において記述されます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID572">
<h3>Restrictions for Nonescaping Closures<a class="headerlink" href="#ID572" title="Permalink to this headline">¶</a><br><span class="jpstr">
非脱出クロージャに対する規制<a class="headerlink" href="#ID572" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A parameter that’s a nonescaping function can’t be stored in a property, variable, or constant of type <code class="docutils literal notranslate"><span class="pre">Any</span></code>, because that might allow the value to escape.<br><span class="jpstr">
非脱出関数であるパラメータは、型<code class="docutils literal notranslate"><span class="pre">Any</span></code>のプロパティ、変数、または定数に格納できません、なぜならそれは値を脱出させることを許可するかもしれないからです。
</span><!--end_jpstr-->
</p>
<p>A parameter that’s a nonescaping function can’t be passed as an argument to another nonescaping function parameter. This restriction helps Swift perform more of its checks for conflicting access to memory at compile time instead of at runtime. For example:<br><span class="jpstr">
非脱出関数であるパラメータは、別の非脱出関数パラメータに引数として渡されることはできません。この規制は、スウィフトが実行時ではなくコンパイル時にメモリへのアクセスの衝突についてより多くのそれの検査を実行する助けとなります。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">external</span>: (() -&gt; <span class="nc">Void</span>) -&gt; <span class="nc">Void</span> = { <span class="k">_</span> <span class="k">in</span> () }
</li><li><span class="k">func</span> <span class="nv">takesTwoFunctions</span>(<span class="nv">first</span>: (() -&gt; <span class="nc">Void</span>) -&gt; <span class="nc">Void</span>, <span class="nv">second</span>: (() -&gt; <span class="nc">Void</span>) -&gt; <span class="nc">Void</span>) {
</li><li>    <span class="nv">first</span> { <span class="nv">first</span> {} }       <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li><li>    <span class="nv">second</span> { <span class="nv">second</span> {}  }    <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li><li>
</li><li>    <span class="nv">first</span> { <span class="nv">second</span> {} }      <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li><li>    <span class="nv">second</span> { <span class="nv">first</span> {} }      <span class="c">// Error&nbsp;<span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></span>
</li><li>
</li><li>    <span class="nv">first</span> { <span class="nv">external</span> {} }    <span class="c">// OK</span>
</li><li>    <span class="nv">external</span> { <span class="nv">first</span> {} }    <span class="c">// OK</span>
</li><li>}
</li></ol></div></div></div>
<p>In the code above, both of the parameters to <code class="docutils literal notranslate"><span class="pre">takesTwoFunctions(first:second:)</span></code> are functions. Neither parameter is marked <code class="docutils literal notranslate"><span class="pre">&#64;escaping</span></code>, so they’re both nonescaping as a result.<br><span class="jpstr">
上のコードにおいて、<code class="docutils literal notranslate"><span class="pre">takesTwoFunctions(first:second:)</span></code>へのパラメータは両方とも関数です。どちらのものも<code class="docutils literal notranslate"><span class="pre">@escaping</span></code>と印されません、それでそれらは両方とも非脱出です。
</span><!--end_jpstr-->
</p>
<p>The four function calls marked “Error” in the example above cause compiler errors. Because the <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">second</span></code> parameters are nonescaping functions, they can’t be passed as arguments to another nonescaping function parameter. In contrast, the two function calls marked “OK” don’t cause a compiler error. These function calls don’t violate the restriction because <code class="docutils literal notranslate"><span class="pre">external</span></code> isn’t one of the parameters of <code class="docutils literal notranslate"><span class="pre">takesTwoFunctions(first:second:)</span></code>.<br><span class="jpstr">
上の例において「Error」と記される４つの関数呼び出しは、コンパイラエラーを引き起こします。<code class="docutils literal notranslate"><span class="pre">first</span></code>および<code class="docutils literal notranslate"><span class="pre">second</span></code>パラメータは非脱出関数であることから、それらは引数として別の非脱出関数パラメータとして渡されることができません。対照的に、「OK」と記される２つの関数呼び出しは、コンパイラエラーを引き起こしません。これらの関数呼び出しは制約に違反しません、なぜなら<code class="docutils literal notranslate"><span class="pre">external</span></code>は<code class="docutils literal notranslate"><span class="pre">takesTwoFunctions(first:second:)</span></code>のパラメータの１つだからです。
</span><!--end_jpstr-->
</p>
<p>If you need to avoid this restriction, mark one of the parameters as escaping, or temporarily convert one of the nonescaping function parameters to an escaping function by using the <code class="docutils literal notranslate"><span class="pre">withoutActuallyEscaping(_:do:)</span></code> function. For information about avoiding conflicting access to memory, see <a class="reference internal" href="../LanguageGuide/MemorySafety.html"><span class="doc">Memory Safety</span></a>.<br><span class="jpstr">
あなたがこの規制を回避する必要があるならば、パラメータの１つを脱出すると印してください、または一時的に非脱出関数パラメータの１つを脱出関数へと<code class="docutils literal notranslate"><span class="pre">withoutActuallyEscaping(_:do:)</span></code>関数を使うことによって変換してください。メモリへのアクセスの衝突の回避についての情報として、<a class="reference internal" href="../LanguageGuide/MemorySafety.html"><span class="doc">メモリ安全</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a function type<br><span class="jpstr">
関数型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type"></a>function-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument-clause">function-type-argument-clause</a></span>  <code>throws</code><sub>opt</sub> <code>-&gt;</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type_1217"></a>function-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument-clause">function-type-argument-clause</a></span>  <code>rethrows</code> <code>-&gt;</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type-argument-clause"></a>function-type-argument-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type-argument-clause_1218"></a>function-type-argument-clause</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument-list">function-type-argument-list</a></span>  <code>...</code><sub>opt</sub> <code>)</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type-argument-list"></a>function-type-argument-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument">function-type-argument</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument">function-type-argument</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_function-type-argument-list">function-type-argument-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-type-argument"></a>function-type-argument</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>inout</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_argument-label">argument-label</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_argument-label"></a>argument-label</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div></div>
</div>
<div class="section" id="ID450">
<h2>Array Type<a class="headerlink" href="#ID450" title="Permalink to this headline">¶</a><br><span class="jpstr">
配列型<a class="headerlink" href="#ID450" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>The Swift language provides the following syntactic sugar for the Swift standard library <code class="docutils literal notranslate"><span class="pre">Array&lt;Element&gt;</span></code> type:<br><span class="jpstr">
スウィフト言語は、スウィフト標準ライブラリの<code class="docutils literal notranslate"><span class="pre">Array&lt;Element&gt;</span></code>型のために以下の構文糖衣を提供します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">type</span>]
</li></ol></div></div></div>
<p>In other words, the following two declarations are equivalent:<br><span class="jpstr">
言い換えると、以下の２つの宣言は、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someArray</span>: <span class="nc">Array</span>&lt;<span class="nc">String</span>&gt; = [<span class="s">&quot;Alex&quot;</span>, <span class="s">&quot;Brian&quot;</span>, <span class="s">&quot;Dave&quot;</span>]
</li><li><span class="k">let</span> <span class="nv">someArray</span>: [<span class="nc">String</span>] = [<span class="s">&quot;Alex&quot;</span>, <span class="s">&quot;Brian&quot;</span>, <span class="s">&quot;Dave&quot;</span>]
</li></ol></div></div></div>
<p>In both cases, the constant <code class="docutils literal notranslate"><span class="pre">someArray</span></code> is declared as an array of strings. The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: <code class="docutils literal notranslate"><span class="pre">someArray[0]</span></code> refers to the element at index 0, <code class="docutils literal notranslate"><span class="pre">&quot;Alex&quot;</span></code>.<br><span class="jpstr">
両方の場合で、定数の<code class="docutils literal notranslate"><span class="pre">someArray</span></code>は、文字列の配列として宣言されます。配列の要素は、角括弧の中に有効なインデックス値を指定することによる添え字指定を通してアクセスされることができます：<code class="docutils literal notranslate"><span class="pre">someArray[0]]</span></code>は、インデックス0での要素、<code class="docutils literal notranslate"><span class="pre">"Alex"</span></code>に言及します。
</span><!--end_jpstr-->
</p>
<p>You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets. For example, you can create a three-dimensional array of integers using three sets of square brackets:<br><span class="jpstr">
あなたは、角括弧の対を入れにすることによって多次元配列をつくることができます、そこで要素の基本型の名前は最も内側の角括弧の対の中に含まれます。例えば、あなたは３つ固めた角括弧を使って整数の三次元配列をつくることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">array3D</span>: [[[<span class="nc">Int</span>]]] = [[[<span class="m">1</span>, <span class="m">2</span>], [<span class="m">3</span>, <span class="m">4</span>]], [[<span class="m">5</span>, <span class="m">6</span>], [<span class="m">7</span>, <span class="m">8</span>]]]
</li></ol></div></div></div>
<p>When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array. The next subscript index to the right refers to the element at that index in the array that’s nested one level in. And so on. This means that in the example above, <code class="docutils literal notranslate"><span class="pre">array3D[0]</span></code> refers to <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]]</span></code>, <code class="docutils literal notranslate"><span class="pre">array3D[0][1]</span></code> refers to <code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">4]</span></code>, and <code class="docutils literal notranslate"><span class="pre">array3D[0][1][1]</span></code> refers to the value 4.<br><span class="jpstr">
多次元配列の要素にアクセスするとき、最も左の添え字インデックスは、最も外側の配列の中のそのインデックスでの要素に言及します。次の右の添え字インデックスは、１段階内側の入れ子にされた配列の中のそのインデックスでの要素に言及します。などなど。これは、上の例で、<code class="docutils literal notranslate"><span class="pre">array3D[0]</span></code>は<code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]]</span></code>に言及し、<code class="docutils literal notranslate"><span class="pre">array3D[0][1]</span></code>は<code class="docutils literal notranslate"><span class="pre">[3,</span> <span class="pre">4]</span></code>に言及し、そして<code class="docutils literal notranslate"><span class="pre">array3D[0][1][1]</span></code>は値４に言及することを意味します。
</span><!--end_jpstr-->
</p>
<p>For a detailed discussion of the Swift standard library <code class="docutils literal notranslate"><span class="pre">Array</span></code> type, see <a class="reference internal" href="../LanguageGuide/CollectionTypes.html#ID107"><span class="std std-ref">Arrays</span></a>.<br><span class="jpstr">
スウィフト標準ライブラリ<code class="docutils literal notranslate"><span class="pre">Array</span></code>型の詳細な議論のために、<a class="reference internal" href="../LanguageGuide/CollectionTypes.html#ID107"><span class="std std-ref">配列</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an array type<br><span class="jpstr">
配列型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-type"></a>array-type</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>]</code></p></div></div></div>
<div class="section" id="ID451">
<h2>Dictionary Type<a class="headerlink" href="#ID451" title="Permalink to this headline">¶</a><br><span class="jpstr">
辞書型<a class="headerlink" href="#ID451" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>The Swift language provides the following syntactic sugar for the Swift standard library <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;Key,</span> <span class="pre">Value&gt;</span></code> type:<br><span class="jpstr">
スウィフト言語は、以下の構文糖衣をスウィフト標準ライブラリ<code class="docutils literal notranslate"><span class="pre">Dictionary&lt;Key,</span> <span class="pre">Value&gt;</span></code>型に提供します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">key type</span>: <span class="gi">value type</span>]
</li></ol></div></div></div>
<p>In other words, the following two declarations are equivalent:<br><span class="jpstr">
言い換えると、以下の２つの宣言は、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">someDictionary</span>: [<span class="nc">String</span>: <span class="nc">Int</span>] = [<span class="s">&quot;Alex&quot;</span>: <span class="m">31</span>, <span class="s">&quot;Paul&quot;</span>: <span class="m">39</span>]
</li><li><span class="k">let</span> <span class="nv">someDictionary</span>: <span class="nc">Dictionary</span>&lt;<span class="nc">String</span>, <span class="nc">Int</span>&gt; = [<span class="s">&quot;Alex&quot;</span>: <span class="m">31</span>, <span class="s">&quot;Paul&quot;</span>: <span class="m">39</span>]
</li></ol></div></div></div>
<p>In both cases, the constant <code class="docutils literal notranslate"><span class="pre">someDictionary</span></code> is declared as a dictionary with strings as keys and integers as values.<br><span class="jpstr">
両方の場合で、定数<code class="docutils literal notranslate"><span class="pre">someDictionary</span></code>は、キーとして文字列そして値として整数を持つ辞書として宣言されます。
</span><!--end_jpstr-->
</p>
<p>The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: <code class="docutils literal notranslate"><span class="pre">someDictionary[&quot;Alex&quot;]</span></code> refers to the value associated with the key <code class="docutils literal notranslate"><span class="pre">&quot;Alex&quot;</span></code>. The subscript returns an optional value of the dictionary’s value type. If the specified key isn’t contained in the dictionary, the subscript returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>.<br><span class="jpstr">
辞書の値は、角括弧の中に対応するキーを指定することによる添え字指定を通してアクセスされることができます：<code class="docutils literal notranslate"><span class="pre">someDictionary["Alex"]</span></code>はキー<code class="docutils literal notranslate"><span class="pre">"Alex"</span></code>と結び付けられた値に言及します。添え字は辞書のもつ値型のオプショナルの値を返します。指定されたキーがその辞書に含まれないならば、添え字は<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p>The key type of a dictionary must conform to the Swift standard library <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol.<br><span class="jpstr">
ある辞書のキーの型は、スウィフト標準ライブラリ<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>プロトコルに準拠しなければなりません。
</span><!--end_jpstr-->
</p>
<p>For a detailed discussion of the Swift standard library <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code> type, see <a class="reference internal" href="../LanguageGuide/CollectionTypes.html#ID113"><span class="std std-ref">Dictionaries</span></a>.<br><span class="jpstr">
スウィフト標準ライブラリ<code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>型の詳細な議論として、<a class="reference internal" href="../LanguageGuide/CollectionTypes.html#ID113"><span class="std std-ref">辞書</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a dictionary type<br><span class="jpstr">
辞書型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-type"></a>dictionary-type</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>]</code></p></div></div></div>
<div class="section" id="ID452">
<h2>Optional Type<a class="headerlink" href="#ID452" title="Permalink to this headline">¶</a><br><span class="jpstr">
オプショナル型<a class="headerlink" href="#ID452" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>The Swift language defines the postfix <code class="docutils literal notranslate"><span class="pre">?</span></code> as syntactic sugar for the named type <code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>, which is defined in the Swift standard library. In other words, the following two declarations are equivalent:<br><span class="jpstr">
スウィフト言語は、接尾辞<code class="docutils literal notranslate"><span class="pre">?</span></code>を構文糖衣として名前付きの型<code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>に対して定義します、それは、スウィフト標準ライブラリで定義されます。言い換えると、以下の２つの宣言は、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">optionalInteger</span>: <span class="nc">Int</span>?
</li><li><span class="k">var</span> <span class="nv">optionalInteger</span>: <span class="nc">Optional</span>&lt;<span class="nc">Int</span>&gt;
</li></ol></div></div></div>
<p>In both cases, the variable <code class="docutils literal notranslate"><span class="pre">optionalInteger</span></code> is declared to have the type of an optional integer. Note that no whitespace may appear between the type and the <code class="docutils literal notranslate"><span class="pre">?</span></code>.<br><span class="jpstr">
両方の場合には、変数<code class="docutils literal notranslate"><span class="pre">optionalInteger</span></code>は、オプショナル整数の型を持つと宣言されます。空白が型と<code class="docutils literal notranslate"><span class="pre">?</span></code>の間に現れないことに注意してください。
</span><!--end_jpstr-->
</p>
<p>The type <code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code> is an enumeration with two cases, <code class="docutils literal notranslate"><span class="pre">none</span></code> and <code class="docutils literal notranslate"><span class="pre">some(Wrapped)</span></code>, which are used to represent values that may or may not be present. Any type can be explicitly declared to be (or implicitly converted to) an optional type. If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.<br><span class="jpstr">
型<code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>は、<code class="docutils literal notranslate"><span class="pre">none</span></code>と<code class="docutils literal notranslate"><span class="pre">some(Wrapped)</span></code>、２つのケース節をもつ列挙です、それは、存在しているかもしれないししていないかもしれない値を表わすために使われます。あらゆる型は、オプショナル型であるとして明示的に宣言される（または暗黙的に変換される）ことができます。オプショナルの変数またはプロパティを宣言する時にあなたが最初の値を提供しないならば、その値は自動的に省略時の<code class="docutils literal notranslate"><span class="pre">nil</span></code>になります。
</span><!--end_jpstr-->
</p>
<p>If an instance of an optional type contains a value, you can access that value using the postfix operator <code class="docutils literal notranslate"><span class="pre">!</span></code>, as shown below:<br><span class="jpstr">
オプショナル型のインスタンスが値を含むならば、あなたが接尾辞演算子<code class="docutils literal notranslate"><span class="pre">!</span></code>を使用してその値にアクセスすることができます、以下に示すように：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">optionalInteger</span> = <span class="m">42</span>
</li><li><span class="nv">optionalInteger</span>! <span class="c">// 42</span>
</li></ol></div></div></div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">!</span></code> operator to unwrap an optional that has a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code> results in a runtime error.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">!</span></code>演算子を使って<code class="docutils literal notranslate"><span class="pre">nil</span></code>の値を持つあるオプショナルをアンラップすることは、実行時エラーの結果になります。
</span><!--end_jpstr-->
</p>
<p>You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression. If the value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, no operation is performed and therefore no runtime error is produced.<br><span class="jpstr">
あなたはまたオプショナル連鎖とオプショナル束縛を使って、あるオプショナルの式に関して演算を条件付きで実行することができます。その値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、演算は実行されません、したがって、実行時エラーは生じません。
</span><!--end_jpstr-->
</p>
<p>For more information and to see examples that show how to use optional types, see <a class="reference internal" href="../LanguageGuide/TheBasics.html#ID330"><span class="std std-ref">Optionals</span></a>.<br><span class="jpstr">
より多くの情報のために、そしてオプショナル型を使う方法を示す例を見るために、<a class="reference internal" href="../LanguageGuide/TheBasics.html#ID330"><span class="std std-ref">オプショナル</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an optional type<br><span class="jpstr">
オプショナル型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_optional-type"></a>optional-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>?</code></p></div></div></div>
<div class="section" id="ID453">
<h2>Implicitly Unwrapped Optional Type<a class="headerlink" href="#ID453" title="Permalink to this headline">¶</a><br><span class="jpstr">
暗黙的にアンラップされるオプショナルの型<a class="headerlink" href="#ID453" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>The Swift language defines the postfix <code class="docutils literal notranslate"><span class="pre">!</span></code> as syntactic sugar for the named type <code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>, which is defined in the Swift standard library, with the additional behavior that it’s automatically unwrapped when it’s accessed. If you try to use an implicitly unwrapped optional that has a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, you’ll get a runtime error. With the exception of the implicit unwrapping behavior, the following two declarations are equivalent:<br><span class="jpstr">
スウィフト言語は、接尾辞<code class="docutils literal notranslate"><span class="pre">!</span></code>を構文糖衣としてスウィフト標準ライブラリで定義される名前付きの型<code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>に対して定義します、それはそれがアクセスされるとき自動的にアンラップされるという追加の挙動を含みます。あなたが<code class="docutils literal notranslate"><span class="pre">nil</span></code>の値を持つ暗黙的にアンラップされるオプショナルを使うことを試みるならば、あなたは実行時エラーを得るでしょう。暗黙的にアンラップされる挙動を除けば、以下の２つの宣言は等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">implicitlyUnwrappedString</span>: <span class="nc">String</span>!
</li><li><span class="k">var</span> <span class="nv">explicitlyUnwrappedString</span>: <span class="nc">Optional</span>&lt;<span class="nc">String</span>&gt;
</li></ol></div></div></div>
<p>Note that no whitespace may appear between the type and the <code class="docutils literal notranslate"><span class="pre">!</span></code>.<br><span class="jpstr">
空白が型と<code class="docutils literal notranslate"><span class="pre">!</span></code>の間に現れないことに注意してください。
</span><!--end_jpstr-->
</p>
<p>Because implicit unwrapping changes the meaning of the declaration that contains that type, optional types that are nested inside a tuple type or a generic type—such as the element types of a dictionary or array—can’t be marked as implicitly unwrapped. For example:<br><span class="jpstr">
暗黙的にアンラップされることがその型を含む宣言の意味することを変えることから、タプル型や総称体型の内部に入れ子にされたオプショナル型—例えば辞書や配列に属する要素型など—は、暗黙的にアンラップされるように印されることはできません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">tupleOfImplicitlyUnwrappedElements</span>: (<span class="nc">Int</span>!, <span class="nc">Int</span>!)  <span class="c">// Error</span>
</li><li><span class="k">let</span> <span class="nv">implicitlyUnwrappedTuple</span>: (<span class="nc">Int</span>, <span class="nc">Int</span>)!             <span class="c">// OK</span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">arrayOfImplicitlyUnwrappedElements</span>: [<span class="nc">Int</span>!]        <span class="c">// Error</span>
</li><li><span class="k">let</span> <span class="nv">implicitlyUnwrappedArray</span>: [<span class="nc">Int</span>]!                  <span class="c">// OK</span>
</li></ol></div></div></div>
<p>Because implicitly unwrapped optionals have the same <code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code> type as optional values, you can use implicitly unwrapped optionals in all the same places in your code that you can use optionals. For instance, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.<br><span class="jpstr">
暗黙的にアンラップされるオプショナルがオプショナル値と同じ<code class="docutils literal notranslate"><span class="pre">Optional&lt;Wrapped&gt;</span></code>型を持つことから、あなたは、あなたのコードにおいてあなたがオプショナルを使うことができるのと同じ場所すべてで暗黙的にアンラップされるオプショナルを使うことができます。たとえば、あなたは暗黙的にアンラップされるオプショナルの値を、オプショナルの変数、定数、そしてプロパティに代入することができます、その逆もまたできます。
</span><!--end_jpstr-->
</p>
<p>As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to <code class="docutils literal notranslate"><span class="pre">nil</span></code>.<br><span class="jpstr">
オプショナルと同様に、あなたが暗黙的にアンラップされるオプショナルの変数やプロパティに初期値を提供しないならば、その値は自動的に省略時の<code class="docutils literal notranslate"><span class="pre">nil</span></code>になります。
</span><!--end_jpstr-->
</p>
<p>Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression. If the value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, no operation is performed and therefore no runtime error is produced.<br><span class="jpstr">
ある暗黙的にアンラップされるオプショナルの式に関して演算を条件付きで実行するために、オプショナル連鎖を使ってください。その値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、演算は実行されません、したがって、実行時エラーは生じません。
</span><!--end_jpstr-->
</p>
<p>For more information about implicitly unwrapped optional types, see <a class="reference internal" href="../LanguageGuide/TheBasics.html#ID334"><span class="std std-ref">Implicitly Unwrapped Optionals</span></a>.<br><span class="jpstr">
暗黙的にアンラップされるオプショナル型の詳細については、<a class="reference internal" href="../LanguageGuide/TheBasics.html#ID334"><span class="std std-ref">暗黙的にアンラップされるオプショナル</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an implicitly unwrapped optional type<br><span class="jpstr">
暗黙的にアンラップされるオプショナル型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_implicitly-unwrapped-optional-type"></a>implicitly-unwrapped-optional-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>!</code></p></div></div></div>
<div class="section" id="ID454">
<h2>Protocol Composition Type<a class="headerlink" href="#ID454" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコル合成型<a class="headerlink" href="#ID454" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A protocol composition type defines a type that conforms to each protocol in a list of specified protocols, or a type that is a subclass of a given class and conforms to each protocol in a list of specified protocols. Protocol composition types may be used only when specifying a type in type annotations, in generic parameter clauses, and in generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses.<br><span class="jpstr">
プロトコル合成型が定義するのは、指定されたプロトコルのリストの各プロトコルに準拠する型、または指定されたクラスのサブクラスでそして指定されたプロトコルのリストの各プロトコルに準拠する型です。プロトコル合成型は、型注釈において、総称体パラメータ節において、そして総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節において型を指定する場合にのみ使われるでしょう。
</span><!--end_jpstr-->
</p>
<p>Protocol composition types have the following form:<br><span class="jpstr">
プロトコル合成型は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">Protocol 1</span> &amp; <span class="gi">Protocol 2</span>
</li></ol></div></div></div>
<p>A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without explicitly defining a new, named protocol that inherits from each protocol you want the type to conform to. For example, you can use the protocol composition type <code class="docutils literal notranslate"><span class="pre">ProtocolA</span> <span class="pre">&amp;</span> <span class="pre">ProtocolB</span> <span class="pre">&amp;</span> <span class="pre">ProtocolC</span></code> instead of declaring a new protocol that inherits from <code class="docutils literal notranslate"><span class="pre">ProtocolA</span></code>, <code class="docutils literal notranslate"><span class="pre">ProtocolB</span></code>, and <code class="docutils literal notranslate"><span class="pre">ProtocolC</span></code>. Likewise, you can use <code class="docutils literal notranslate"><span class="pre">SuperClass</span> <span class="pre">&amp;</span> <span class="pre">ProtocolA</span></code> instead of declaring a new protocol that is a subclass of <code class="docutils literal notranslate"><span class="pre">SuperClass</span></code> and conforms to <code class="docutils literal notranslate"><span class="pre">ProtocolA</span></code>.<br><span class="jpstr">
プロトコル合成型は、あなたにそれの型が複数のプロトコルに属する要件に準拠するある値を、あなたがその型に準拠して欲しいプロトコル各々から継承する名前をつけられたある新しいプロトコルを明示的に定義する必要なしに指定させます。例えば、プロトコル合成型<code class="docutils literal notranslate"><span class="pre">ProtocolA</span> <span class="pre">&amp;</span> <span class="pre">ProtocolB</span> <span class="pre">&amp;</span> <span class="pre">ProtocolC</span></code>を使うことが、<code class="docutils literal notranslate"><span class="pre">ProtocolA</span></code>、<code class="docutils literal notranslate"><span class="pre">ProtocolB</span></code>、そして<code class="docutils literal notranslate"><span class="pre">ProtocolC</span></code>から継承する新しいプロトコルを宣言する代わりに行えます。同様に、あなたは<code class="docutils literal notranslate"><span class="pre">SuperClass</span> <span class="pre">&amp;</span> <span class="pre">ProtocolA</span></code>を使うことが、<code class="docutils literal notranslate"><span class="pre">SuperClass</span></code>のサブクラスで<code class="docutils literal notranslate"><span class="pre">ProtocolA</span></code>に準拠する新しいプロトコルを宣言する代わりに行えます。
</span><!--end_jpstr-->
</p>
<p>Each item in a protocol composition list is one of the following; the list can contain at most one class:<br><span class="jpstr">
プロトコル合成リストの各項目は以下のうちの１つです；リストは最大１つのクラスを含むことができます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>The name of a class<br><span class="jpstr">
あるクラスの名前
</span><!--end_jpstr-->
</li>
<li>The name of a protocol<br><span class="jpstr">
あるプロトコルの名前
</span><!--end_jpstr-->
</li>
<li>A type alias whose underlying type is a protocol composition type, a protocol, or a class.<br><span class="jpstr">
それの基礎をなす型がプロトコル合成型、プロトコル、またはクラスである型エイリアス。
</span><!--end_jpstr-->
</li>
</ul>
<p>When a protocol composition type contains type aliases, it’s possible for the same protocol to appear more than once in the definitions—duplicates are ignored. For example, the definition of <code class="docutils literal notranslate"><span class="pre">PQR</span></code> in the code below is equivalent to <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&amp;</span> <span class="pre">Q</span> <span class="pre">&amp;</span> <span class="pre">R</span></code>.<br><span class="jpstr">
あるプロトコル合成型が型エイリアスを含む場合、同じプロトコルが複数回定義の中に現れることが可能です — 重複は無視されます。例えば、以下のコードでの<code class="docutils literal notranslate"><span class="pre">PQR</span></code>の定義は、<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">&amp;</span> <span class="pre">Q</span> <span class="pre">&amp;</span> <span class="pre">R</span></code>と同等です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">PQ</span> = <span class="nc">P</span> &amp; <span class="nc">Q</span>
</li><li><span class="k">typealias</span> <span class="nv">PQR</span> = <span class="nc">PQ</span> &amp; <span class="nc">Q</span> &amp; <span class="nc">R</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol composition type<br><span class="jpstr">
プロトコル構成型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-composition-type"></a>protocol-composition-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span>  <code>&amp;</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_protocol-composition-continuation">protocol-composition-continuation</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-composition-continuation"></a>protocol-composition-continuation</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_protocol-composition-type">protocol-composition-type</a></span> </p></div></div></div>
<div class="section" id="ID455">
<h2>Metatype Type<a class="headerlink" href="#ID455" title="Permalink to this headline">¶</a><br><span class="jpstr">
メタタイプ型<a class="headerlink" href="#ID455" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.<br><span class="jpstr">
あるメタタイプ型は、いろいろなクラス型、構造体型、列挙型、そしていろいろなプロトコル型の内で、ある何らかの型のその型に言及します。
</span><!--end_jpstr-->
</p>
<p>The metatype of a class, structure, or enumeration type is the name of that type followed by <code class="docutils literal notranslate"><span class="pre">.Type</span></code>. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by <code class="docutils literal notranslate"><span class="pre">.Protocol</span></code>. For example, the metatype of the class type <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> is <code class="docutils literal notranslate"><span class="pre">SomeClass.Type</span></code> and the metatype of the protocol <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code> is <code class="docutils literal notranslate"><span class="pre">SomeProtocol.Protocol</span></code>.<br><span class="jpstr">
あるクラス、構造体、または列挙型のメタタイプは、その型の名前に<code class="docutils literal notranslate"><span class="pre">.Type</span></code>が続くものです。あるプロトコル型 ― 実行時にそのプロトコルに準拠する具象型ではない ― のメタタイプは、そのプロトコルの名前に<code class="docutils literal notranslate"><span class="pre">.Protocol</span></code>が続くものです。例えば、クラス型<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>のメタタイプは<code class="docutils literal notranslate"><span class="pre">SomeClass.Type</span></code>です、そして、プロトコル<code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code>のメタタイプは<code class="docutils literal notranslate"><span class="pre">SomeProtocol.Protocol</span></code>です。
</span><!--end_jpstr-->
</p>
<p>You can use the postfix <code class="docutils literal notranslate"><span class="pre">self</span></code> expression to access a type as a value. For example, <code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code> returns <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> itself, not an instance of <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>. And <code class="docutils literal notranslate"><span class="pre">SomeProtocol.self</span></code> returns <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code> itself, not an instance of a type that conforms to <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code> at runtime. You can call the <code class="docutils literal notranslate"><span class="pre">type(of:)</span></code> function with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:<br><span class="jpstr">
あなたは、接尾辞<code class="docutils literal notranslate"><span class="pre">self</span></code>式を使って、ある型に値としてアクセスすることができます。例えば、<code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code>は、<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>自身を返します、<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>のインスタンスではなく。そして、<code class="docutils literal notranslate"><span class="pre">SomeProtocol.self</span></code>は、<code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code>自身を返します、実行時に<code class="docutils literal notranslate"><span class="pre">SomeProtocol</span></code>に準拠するある型のインスタンスではなく。あなたは、ある型のインスタンスを使って<code class="docutils literal notranslate"><span class="pre">type(of:)</span></code>関数を呼び出して、そのインスタンスの持つ動的な、実行時の型にひとつの値としてアクセスできます、以下の例で示すように：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeBaseClass</span> {
</li><li>    <span class="k">class</span> <span class="k">func</span> <span class="nv">printClassName</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;SomeBaseClass&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">class</span> <span class="nv">SomeSubClass</span>: <span class="nc">SomeBaseClass</span> {
</li><li>    <span class="k">override</span> <span class="k">class</span> <span class="k">func</span> <span class="nv">printClassName</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;SomeSubClass&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">someInstance</span>: <span class="nc">SomeBaseClass</span> = <span class="nv">SomeSubClass</span>()
</li><li><span class="c">// The compile-time type of someInstance is SomeBaseClass,&nbsp;<span class="jpstr">（someInstanceのコンパイル時での型は、SomeBaseClassです、）</span><!--end_jpstr-->
</span>
</li><li><span class="c">// and the runtime type of someInstance is SomeSubClass&nbsp;<span class="jpstr">（そしてsomeInstanceの実行時での型は、SomeSubClassです）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">someInstance</span>).<span class="nv">printClassName</span>()
</li><li><span class="c">// Prints &quot;SomeSubClass&quot;&nbsp;<span class="jpstr">（「 SomeSubClass 」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>For more information, see <a class="reference external" href="https://developer.apple.com/documentation/swift/2885064-type"><code class="docutils literal notranslate"><span class="pre">type(of:)</span></code></a> in the Swift standard library.<br><span class="jpstr">
詳細は、<a class="reference external" href="https://developer.apple.com/documentation/swift/2885064-type"><code class="docutils literal notranslate"><span class="pre">type(of:)</span></code></a>をスウィフト標準ライブラリで見てください。
</span><!--end_jpstr-->
</p>
<p>Use an initializer expression to construct an instance of a type from that type’s metatype value. For class instances, the initializer that’s called must be marked with the <code class="docutils literal notranslate"><span class="pre">required</span></code> keyword or the entire class marked with the <code class="docutils literal notranslate"><span class="pre">final</span></code> keyword.<br><span class="jpstr">
イニシャライザ式を使って、ある型のインスタンスをその型のメタタイプ値から組み立ててください。クラスインスタンスに対しては、呼び出されるイニシャライザが<code class="docutils literal notranslate"><span class="pre">required</span></code>キーワードで印されるか、クラス全体が<code class="docutils literal notranslate"><span class="pre">final</span></code>キーワードで印されなければなりません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">AnotherSubClass</span>: <span class="nc">SomeBaseClass</span> {
</li><li>    <span class="k">let</span> <span class="nv">string</span>: <span class="nc">String</span>
</li><li>    <span class="k">required</span> <span class="k">init</span>(<span class="nv">string</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">string</span> = <span class="nv">string</span>
</li><li>    }
</li><li>    <span class="k">override</span> <span class="k">class</span> <span class="k">func</span> <span class="nv">printClassName</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;AnotherSubClass&quot;</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">metatype</span>: <span class="nc">AnotherSubClass</span>.<span class="nv">Type</span> = <span class="nv">AnotherSubClass</span>.<span class="k">self</span>
</li><li><span class="k">let</span> <span class="nv">anotherInstance</span> = <span class="nv">metatype</span>.<span class="nv">init</span>(<span class="nv">string</span>: <span class="s">&quot;some string&quot;</span>)
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a metatype type<br><span class="jpstr">
メタタイプ型の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_metatype-type"></a>metatype-type</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>.</code> <code>Type</code> |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span>  <code>.</code> <code>Protocol</code></p></div></div></div>
<div class="section" id="ID456">
<h2>Type Inheritance Clause<a class="headerlink" href="#ID456" title="Permalink to this headline">¶</a><br><span class="jpstr">
型継承節<a class="headerlink" href="#ID456" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to. A type inheritance clause begins with a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>), followed by a list of type identifiers.<br><span class="jpstr">
ある型継承節は、ある名前付きの型が継承するのはどのクラスからか、およびある名前付きの型が準拠するのはどのプロトコルに対してかを指定するために使われます。型継承節はコロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で始まり、型識別子のリストが続きます。
</span><!--end_jpstr-->
</p>
<p>Class types can inherit from a single superclass and conform to any number of protocols. When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to. If the class doesn’t inherit from another class, the list can begin with a protocol instead. For an extended discussion and several examples of class inheritance, see <a class="reference internal" href="../LanguageGuide/Inheritance.html"><span class="doc">Inheritance</span></a>.<br><span class="jpstr">
クラス型は、１つのスーパークラスから継承することができ、任意の数のプロトコルに準拠することができます。クラスを定義するとき、スーパークラスの名前は型識別子のリストにおいて最初に現れなければなりません、そしてそのクラスが準拠しなければならないいくらかのプロトコルが続きます。クラスが別のクラスから継承しないならば、このリストは代わりにプロトコルで始まることが出来ます。クラス継承の広範囲にわたる議論といくつかの例のために、<a class="reference internal" href="../LanguageGuide/Inheritance.html"><span class="doc">継承</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>Other named types can only inherit from or conform to a list of protocols. Protocol types can inherit from any number of other protocols. When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements.<br><span class="jpstr">
他の名前付きの型は、プロトコルのリストから継承し準拠することだけができます。プロトコル型は、いくらかの他のプロトコルから継承することができます。プロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件ひとそろいは一緒にまとめられます、そして、現在のプロトコルから継承するどんな型でもそれらの要件の全てに準拠しなければなりません。
</span><!--end_jpstr-->
</p>
<p>A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values. For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see <a class="reference internal" href="../LanguageGuide/Enumerations.html#ID149"><span class="std std-ref">Raw Values</span></a>.<br><span class="jpstr">
列挙定義における型継承節は、プロトコルのリスト、または生の値をそれのケース節に割り当てる列挙のケース節においては、それらの生の値を指定する単一の名前付き型、このどちらかであることができます。その生の値の型を指定するために型継承節を使う列挙定義の例のために、<a class="reference internal" href="../LanguageGuide/Enumerations.html#ID149"><span class="std std-ref">生の値</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type inheritance clause<br><span class="jpstr">
型継承節の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-inheritance-clause"></a>type-inheritance-clause</span><span class="arrow"> → </span> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-list">type-inheritance-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-inheritance-list"></a>type-inheritance-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-list">type-inheritance-list</a></span> </p></div></div></div>
<div class="section" id="ID457">
<h2>Type Inference<a class="headerlink" href="#ID457" title="Permalink to this headline">¶</a><br><span class="jpstr">
型推論<a class="headerlink" href="#ID457" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code. For example, instead of writing <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0</span></code>, you can write <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code>, omitting the type completely—the compiler correctly infers that <code class="docutils literal notranslate"><span class="pre">x</span></code> names a value of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Similarly, you can omit part of a type when the full type can be inferred from context. For instance, if you write <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">dict:</span> <span class="pre">Dictionary</span> <span class="pre">=</span> <span class="pre">[&quot;A&quot;:</span> <span class="pre">1]</span></code>, the compiler infers that <code class="docutils literal notranslate"><span class="pre">dict</span></code> has the type <code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code>.<br><span class="jpstr">
スウィフトは広く型推論を使います、そして、あなたのコードにおいて型、または多くの変数および式の型の一部を省略できるようにします。例えば、<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0</span></code>を書く代わりに、あなたは型を完全に省略して<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code>と書くことができます ― コンパイラは、<code class="docutils literal notranslate"><span class="pre">x</span></code>が型<code class="docutils literal notranslate"><span class="pre">Int</span></code>の値に名をつけると正しく推測します。同じように、前後関係から完全に型が推論されることができるとき、あなたはある型の一部を省略することができます。たとえば、あなたが<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">dict:</span> <span class="pre">Dictionary</span> <span class="pre">=</span> <span class="pre">["A":</span> <span class="pre">1]</span></code>を書くならば、コンパイラは<code class="docutils literal notranslate"><span class="pre">dict</span></code>が型<code class="docutils literal notranslate"><span class="pre">Dictionary&lt;String,</span> <span class="pre">Int&gt;</span></code>を持つと推測します。
</span><!--end_jpstr-->
</p>
<p>In both of the examples above, the type information is passed up from the leaves of the expression tree to its root. That is, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0</span></code> is inferred by first checking the type of <code class="docutils literal notranslate"><span class="pre">0</span></code> and then passing this type information up to the root (the variable <code class="docutils literal notranslate"><span class="pre">x</span></code>).<br><span class="jpstr">
上の例の両方とも、型情報は、式ツリーの葉っぱから、その根までさかのぼって渡されます。すなわち、<code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">Int</span> <span class="pre">=</span> <span class="pre">0</span></code>の中の<code class="docutils literal notranslate"><span class="pre">x</span></code>の型は、最初に<code class="docutils literal notranslate"><span class="pre">0</span></code>の型を調べて、それからこの型情報を根（変数<code class="docutils literal notranslate"><span class="pre">x</span></code>）までさかのぼって渡すことによって推論されます。
</span><!--end_jpstr-->
</p>
<p>In Swift, type information can also flow in the opposite direction—from the root down to the leaves. In the following example, for instance, the explicit type annotation (<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">Float</span></code>) on the constant <code class="docutils literal notranslate"><span class="pre">eFloat</span></code> causes the numeric literal <code class="docutils literal notranslate"><span class="pre">2.71828</span></code> to have an inferred type of <code class="docutils literal notranslate"><span class="pre">Float</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Double</span></code>.<br><span class="jpstr">
スウィフトでは、型情報は逆方向にも流れます ― 根から下って葉っぱまで。例えば、以下の例において、定数<code class="docutils literal notranslate"><span class="pre">eFloat</span></code>での明示的な型注釈（<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">Float</span></code>）は、数値リテラル<code class="docutils literal notranslate"><span class="pre">2.71828</span></code>を<code class="docutils literal notranslate"><span class="pre">Float</span></code>の推論される型を持つようにします、<code class="docutils literal notranslate"><span class="pre">Double</span></code>ではなく。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">e</span> = <span class="m">2.71828</span> <span class="c">// The type of e is inferred to be Double.&nbsp;<span class="jpstr"><span class="c">（eの型は、Doubleであると推測されます。</span>）</span><!--end_jpstr--></span>
</li><li><span class="k">let</span> <span class="nv">eFloat</span>: <span class="nc">Float</span> = <span class="m">2.71828</span> <span class="c">// The type of eFloat is Float.</span>
</li></ol></div></div></div>
<p>Type inference in Swift operates at the level of a single expression or statement. This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.<br><span class="jpstr">
スウィフトの型推論は、単一の式や文の水準で働きます。これは、ある式における省略される型や型の一部分を推論するために必要とされる情報のすべては、型を調べているその式またはそれの下位式の１つからアクセス可能でなければならないことを意味します。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="LexicalStructure.html">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Expressions.html">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../_static/javascripts/application.js"></script>
  </body>
</html>
