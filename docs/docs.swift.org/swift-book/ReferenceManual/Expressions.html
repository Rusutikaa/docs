<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Expressions — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="AboutTheLanguageReference.html"><span class="enstr">About the Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="LexicalStructure.html"><span class="enstr">Lexical Structure</span><!--end_enstr-->
<span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html"><span class="enstr">Types</span><!--end_enstr-->
<span class="jpstr">
型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Expressions</span><!--end_enstr-->
<span class="jpstr">
式
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Statements.html"><span class="enstr">Statements</span><!--end_enstr-->
<span class="jpstr">
文
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Declarations.html"><span class="enstr">Declarations</span><!--end_enstr-->
<span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Attributes.html"><span class="enstr">Attributes</span><!--end_enstr-->
<span class="jpstr">
属性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Patterns.html"><span class="enstr">Patterns</span><!--end_enstr-->
<span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="GenericParametersAndArguments.html"><span class="enstr">Generic Parameters and Arguments</span><!--end_enstr-->
<span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="zzSummaryOfTheGrammar.html"><span class="enstr">Summary of the Grammar</span><!--end_enstr-->
<span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Expressions</span><!--end_enstr-->
<span class="jpstr">
式
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID384"><span class="enstr">Prefix Expressions</span><!--end_enstr-->
<span class="jpstr">
接頭辞式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID631"><span class="enstr">In-Out Expression</span><!--end_enstr-->
<span class="jpstr">
in-out式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID516"><span class="enstr">Try Operator</span><!--end_enstr-->
<span class="jpstr">
try演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID646"><span class="enstr">Await Operator</span><!--end_enstr-->
<span class="jpstr">
await演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID385"><span class="enstr">Infix Expressions</span><!--end_enstr-->
<span class="jpstr">
接中辞式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID386"><span class="enstr">Assignment Operator</span><!--end_enstr-->
<span class="jpstr">
代入演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID387"><span class="enstr">Ternary Conditional Operator</span><!--end_enstr-->
<span class="jpstr">
三項条件演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID388"><span class="enstr">Type-Casting Operators</span><!--end_enstr-->
<span class="jpstr">
型キャスト演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID389"><span class="enstr">Primary Expressions</span><!--end_enstr-->
<span class="jpstr">
基本式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID390"><span class="enstr">Literal Expression</span><!--end_enstr-->
<span class="jpstr">
リテラル式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID391"><span class="enstr">Self Expression</span><!--end_enstr-->
<span class="jpstr">
self式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID392"><span class="enstr">Superclass Expression</span><!--end_enstr-->
<span class="jpstr">
スーパークラス式
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID393"><span class="enstr">Closure Expression</span><!--end_enstr-->
<span class="jpstr">
クロージャ式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID544"><span class="enstr">Capture Lists</span><!--end_enstr-->
<span class="jpstr">
キャプチャリスト
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID394"><span class="enstr">Implicit Member Expression</span><!--end_enstr-->
<span class="jpstr">
暗黙的メンバー式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID395"><span class="enstr">Parenthesized Expression</span><!--end_enstr-->
<span class="jpstr">
括弧に入れられた式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID552"><span class="enstr">Tuple Expression</span><!--end_enstr-->
<span class="jpstr">
タプル式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID396"><span class="enstr">Wildcard Expression</span><!--end_enstr-->
<span class="jpstr">
ワイルドカード式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID563"><span class="enstr">Key-Path Expression</span><!--end_enstr-->
<span class="jpstr">
キーパス式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID547"><span class="enstr">Selector Expression</span><!--end_enstr-->
<span class="jpstr">
セレクタ式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID549"><span class="enstr">Key-Path String Expression</span><!--end_enstr-->
<span class="jpstr">
キーパス文字列式
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID397"><span class="enstr">Postfix Expressions</span><!--end_enstr-->
<span class="jpstr">
接尾辞式
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID398"><span class="enstr">Function Call Expression</span><!--end_enstr-->
<span class="jpstr">
関数呼び出し式
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID632"><span class="enstr">Implicit Conversion to a Pointer Type</span><!--end_enstr-->
<span class="jpstr">
ポインター型への暗黙的変換
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID399"><span class="enstr">Initializer Expression</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID400"><span class="enstr">Explicit Member Expression</span><!--end_enstr-->
<span class="jpstr">
明示的メンバー式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID401"><span class="enstr">Postfix Self Expression</span><!--end_enstr-->
<span class="jpstr">
接尾辞self式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID403"><span class="enstr">Subscript Expression</span><!--end_enstr-->
<span class="jpstr">
添え字式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID404"><span class="enstr">Forced-Value Expression</span><!--end_enstr-->
<span class="jpstr">
強制された値式
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID405"><span class="enstr">Optional-Chaining Expression</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖式
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="expressions">
<h1><span class="enstr">Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
式<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">In Swift, there are four kinds of expressions: prefix expressions, infix expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.</span><!--end_enstr-->
<span class="jpstr">
スウィフトには、４種類の式があります：接頭辞式、接中辞式、基本式、そして接尾辞式。ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Prefix and infix expressions let you apply operators to smaller expressions. Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values. Postfix expressions, like prefix and infix expressions, let you build up more complex expressions using postfixes such as function calls and member access. Each kind of expression is described in detail in the sections below.</span><!--end_enstr-->
<span class="jpstr">
接頭辞と接中辞式は、あなたに演算子をより小さい式に適用させます。基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。接尾辞式は、接頭辞や接中辞の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。各種類の式は、以下の節において詳細に記述されます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an expression</span><!--end_enstr-->
<span class="jpstr">
式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_expression"></a>expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_await-operator">await-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_infix-expressions">infix-expressions</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_expression-list"></a>expression-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression-list">expression-list</a></span> </p>
</div>
</div>
<div class="section" id="ID384">
<h2><span class="enstr">Prefix Expressions<a class="headerlink" href="#ID384" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
接頭辞式<a class="headerlink" href="#ID384" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Prefix expressions</em> combine an optional prefix operator with an expression. Prefix operators take one argument, the expression that follows them.</span><!--end_enstr-->
<span class="jpstr">
<em>接頭辞式</em>では、ある任意の接頭辞演算子をひとつの式と組み合わせます。接頭辞演算子は、１つの引数（それらの後に続く式）をとります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the operators provided by the Swift standard library, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a prefix expression</span><!--end_enstr-->
<span class="jpstr">
接頭辞式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_prefix-expression"></a>prefix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_prefix-operator">prefix-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_prefix-expression_1060"></a>prefix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_in-out-expression">in-out-expression</a></span> </p>
</div>
</div>
<div class="section" id="ID631">
<h3><span class="enstr">In-Out Expression<a class="headerlink" href="#ID631" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
in-out式<a class="headerlink" href="#ID631" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>in-out expression</em> marks a variable that’s being passed as an in-out argument to a function call expression.</span><!--end_enstr-->
<span class="jpstr">
<em>in-out expression</em>は、in-out引数として関数呼び出し式に渡されている変数を印します。
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>&amp;<span class="gi">expression</span>
</li></ol></div></div></div>
<p><span class="enstr">For more information about in-out parameters and to see an example, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Out Parameters</span></a>.</span><!--end_enstr-->
<span class="jpstr">
In-Outパラメータについてのより多くの情報のために、そして例を見るために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Outパラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In-out expressions are also used when providing a non-pointer argument in a context where a pointer is needed, as described in <a class="reference internal" href="#ID632"><span class="std std-ref">Implicit Conversion to a Pointer Type</span></a>.</span><!--end_enstr-->
<span class="jpstr">
in-out式はまた、ポインタが必要とされる文脈において非ポインタ引数を提供する時に使われます、<a class="reference internal" href="#ID632"><span class="std std-ref">ポインタ型への暗黙的変換</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an in-out expression</span><!--end_enstr-->
<span class="jpstr">
in-out式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_in-out-expression"></a>in-out-expression</span><span class="arrow"> → </span> <code>&amp;</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div>
</div>
</div>
<div class="section" id="ID516">
<h3><span class="enstr">Try Operator<a class="headerlink" href="#ID516" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
try演算子<a class="headerlink" href="#ID516" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try</span></code> operator followed by an expression that can throw an error. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>try式</em>は、<code class="docutils literal notranslate"><span class="pre">try</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">try</span> <span class="gi">expression</span>
</li></ol></div></div></div>
<p><span class="enstr">The value of a <code class="docutils literal notranslate"><span class="pre">try</span></code> expression is the value of the <em>expression</em>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">try</span></code>式の値は、<em>expression</em>の値です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An <em>optional-try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try?</span></code> operator followed by an expression that can throw an error. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>オプショナルtry式</em>は、<code class="docutils literal notranslate"><span class="pre">try?</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">try</span>? <span class="gi">expression</span>
</li></ol></div></div></div>
<p><span class="enstr">If the <em>expression</em> doesn’t throw an error, the value of the optional-try expression is an optional containing the value of the <em>expression</em>. Otherwise, the value of the optional-try expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この<em>expression（式）</em>がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、その<em>expression（式）</em>の値を含んでいます。そうでなければ、オプショナルtry式の値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A <em>forced-try expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">try!</span></code> operator followed by an expression that can throw an error. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>強制try式</em>は、<code class="docutils literal notranslate"><span class="pre">try!</span></code>演算子と後につづくエラーをスローできる１つの式から成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">try</span>! <span class="gi">expression</span>
</li></ol></div></div></div>
<p><span class="enstr">The value of a forced-try expression is the value of the <em>expression</em>. If the <em>expression</em> throws an error, a runtime error is produced.</span><!--end_enstr-->
<span class="jpstr">
強制try式の値は、<em>expression</em>の値です。この<em>expression</em>がエラーをスローするならば、実行時エラーが生み出されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When the expression on the left-hand side of an infix operator is marked with <code class="docutils literal notranslate"><span class="pre">try</span></code>, <code class="docutils literal notranslate"><span class="pre">try?</span></code>, or <code class="docutils literal notranslate"><span class="pre">try!</span></code>, that operator applies to the whole infix expression. That said, you can use parentheses to be explicit about the scope of the operator’s application.</span><!--end_enstr-->
<span class="jpstr">
ある接中辞演算子の左手側での式が<code class="docutils literal notranslate"><span class="pre">try</span></code>、<code class="docutils literal notranslate"><span class="pre">try?</span></code>、または<code class="docutils literal notranslate"><span class="pre">try!</span></code>で印される場合、その演算子は接中辞式全体に適用されます。とは言うものの、あなたは丸括弧を使って演算子の作用域について明確にすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// try applies to both function calls</span><!--end_enstr--><span class="jpstr">（tryは、両方の関数呼び出しに適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = <span class="k">try</span> <span class="nv">someThrowingFunction</span>() + <span class="nv">anotherThrowingFunction</span>()
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// try applies to both function calls</span><!--end_enstr--><span class="jpstr">（tryは、両方の関数呼び出しに適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = <span class="k">try</span> (<span class="nv">someThrowingFunction</span>() + <span class="nv">anotherThrowingFunction</span>())
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Error: try applies only to the first function call</span><!--end_enstr--><span class="jpstr">（エラー：tryは、最初の関数呼び出しにだけ適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = (<span class="k">try</span> <span class="nv">someThrowingFunction</span>()) + <span class="nv">anotherThrowingFunction</span>()
</li>
</ol></div></div></div>
<p><span class="enstr">A <code class="docutils literal notranslate"><span class="pre">try</span></code> expression can’t appear on the right-hand side of an infix operator, unless the infix operator is the assignment operator or the <code class="docutils literal notranslate"><span class="pre">try</span></code> expression is enclosed in parentheses.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">try</span></code>式が接中辞演算子の右手側に現れることは、その接中辞演算子が代入演算子であるか<code class="docutils literal notranslate"><span class="pre">try</span></code>式が丸括弧の中に入れられるかしない限りはできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If an expression includes both the <code class="docutils literal notranslate"><span class="pre">try</span></code> and <code class="docutils literal notranslate"><span class="pre">await</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">try</span></code> operator must appear first.</span><!--end_enstr-->
<span class="jpstr">
ある式が<code class="docutils literal notranslate"><span class="pre">try</span></code>と<code class="docutils literal notranslate"><span class="pre">await</span></code>演算子の両方を含むならば、<code class="docutils literal notranslate"><span class="pre">try</span></code>演算子は最初に現れなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more information and to see examples of how to use <code class="docutils literal notranslate"><span class="pre">try</span></code>, <code class="docutils literal notranslate"><span class="pre">try?</span></code>, and <code class="docutils literal notranslate"><span class="pre">try!</span></code>, see <a class="reference internal" href="../LanguageGuide/ErrorHandling.html"><span class="doc">Error Handling</span></a>.</span><!--end_enstr-->
<span class="jpstr">
より多くの情報のために、そして<code class="docutils literal notranslate"><span class="pre">try</span></code>、<code class="docutils literal notranslate"><span class="pre">try?</span></code>、そして<code class="docutils literal notranslate"><span class="pre">try!</span></code>文を使う方法の例を見るために、<a class="reference internal" href="../LanguageGuide/ErrorHandling.html"><span class="doc">エラーを処理する</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a try expression</span><!--end_enstr-->
<span class="jpstr">
try式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_try-operator"></a>try-operator</span><span class="arrow"> → </span> <code>try</code> |  <code>try</code> <code>?</code> |  <code>try</code> <code>!</code></p></div>
</div>
</div>
<div class="section" id="ID646">
<h3><span class="enstr">Await Operator<a class="headerlink" href="#ID646" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
await演算子<a class="headerlink" href="#ID646" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>await expression</em> consists of the <code class="docutils literal notranslate"><span class="pre">await</span></code> operator followed by an expression that uses the result of an asynchronous operation. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>await式</em>は、<code class="docutils literal notranslate"><span class="pre">await</span></code>演算子と、非同期演算の結果を使うある式が続くものから成ります。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="nv">await</span> <span class="gi">expression</span>
</li></ol></div></div></div>
<p><span class="enstr">The value of an <code class="docutils literal notranslate"><span class="pre">await</span></code> expression is the value of the <em>expression</em>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">await</span></code>式の値は、<em>expression</em>の値です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An expression marked with <code class="docutils literal notranslate"><span class="pre">await</span></code> is called a <em>potential suspension point</em>. Execution of an asynchronous function can be suspended at each expression that’s marked with <code class="docutils literal notranslate"><span class="pre">await</span></code>. In addition, execution of concurrent code is never suspended at any other point. This means code between potential suspension points can safely update state that requires temporarily breaking invariants, provided that it completes the update before the next potential suspension point.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">await</span></code>で印された式は、<em>潜在的中断地点</em>と呼ばれます。非同期関数の遂行は、<code class="docutils literal notranslate"><span class="pre">await</span></code>で印される式それぞれで中断されることが可能です。加えて、並行性コードの遂行は、他のどんな地点でも決して中断されません。これが意味するのは、潜在的中断地点の間のコードは、安全に状態を更新可能であるということです、それがその更新を次の潜在的中断地点の前に完了するという条件で。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An <code class="docutils literal notranslate"><span class="pre">await</span></code> expression can appear only within an asynchronous context, such as the trailing closure passed to the <code class="docutils literal notranslate"><span class="pre">async(priority:operation:)</span></code> function. It can’t appear in the body of a <code class="docutils literal notranslate"><span class="pre">defer</span></code> statement, or in an autoclosure of synchronous function type.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">await</span></code>式は、非同期の文脈、たとえば<code class="docutils literal notranslate"><span class="pre">async(priority:operation:)</span></code>関数に渡される後付クロージャなど、の内部でのみ現れることが可能です。それは、<code class="docutils literal notranslate"><span class="pre">defer</span></code>文の本体の中で、または同期関数型の自動クロージャの中で現れることができません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When the expression on the left-hand side of an infix operator is marked with the <code class="docutils literal notranslate"><span class="pre">await</span></code> operator, that operator applies to the whole infix expression. That said, you can use parentheses to be explicit about the scope of the operator’s application.</span><!--end_enstr-->
<span class="jpstr">
ある接中辞演算子の左手側での式が<code class="docutils literal notranslate"><span class="pre">await</span></code>演算子で印される場合、その演算子は接中辞式全体に適用されます。とは言うものの、あなたは丸括弧を使って演算子の作用域について明確にすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// await applies to both function calls</span><!--end_enstr--><span class="jpstr">（awaitは、両方の関数呼び出しに適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = <span class="nv">await</span> <span class="nv">someAsyncFunction</span>() + <span class="nv">anotherAsyncFunction</span>()
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// await applies to both function calls</span><!--end_enstr--><span class="jpstr">（awaitは、両方の関数呼び出しに適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = <span class="nv">await</span> (<span class="nv">someAsyncFunction</span>() + <span class="nv">anotherAsyncFunction</span>())
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Error: await applies only to the first function call</span><!--end_enstr--><span class="jpstr">（エラー：awaitは、最初の関数呼び出しにだけ適用されます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">sum</span> = (<span class="nv">await</span> <span class="nv">someAsyncFunction</span>()) + <span class="nv">anotherAsyncFunction</span>()
</li>
</ol></div></div></div>
<p><span class="enstr">An <code class="docutils literal notranslate"><span class="pre">await</span></code> expression can’t appear on the right-hand side of an infix operator, unless the infix operator is the assignment operator or the <code class="docutils literal notranslate"><span class="pre">await</span></code> expression is enclosed in parentheses.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">await</span></code>式が接中辞演算子の右手側に現れることは、その接中辞演算子が代入演算子であるか<code class="docutils literal notranslate"><span class="pre">await</span></code>式が丸括弧の中に入れられるかしない限りはできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If an expression includes both the <code class="docutils literal notranslate"><span class="pre">await</span></code> and <code class="docutils literal notranslate"><span class="pre">try</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">try</span></code> operator must appear first.</span><!--end_enstr-->
<span class="jpstr">
ある式が<code class="docutils literal notranslate"><span class="pre">await</span></code>と<code class="docutils literal notranslate"><span class="pre">try</span></code>演算子の両方を含むならば、<code class="docutils literal notranslate"><span class="pre">try</span></code>演算子は最初に現れなければなりません。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an await expression</span><!--end_enstr-->
<span class="jpstr">
await式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_await-operator"></a>await-operator</span><span class="arrow"> → </span> <code>await</code></p></div>
</div>
</div>
</div>
<div class="section" id="ID385">
<h2><span class="enstr">Infix Expressions<a class="headerlink" href="#ID385" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
接中辞式<a class="headerlink" href="#ID385" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Infix expressions</em> combine an infix binary operator with the expression that it takes as its left- and right-hand arguments. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>接中辞式</em>は、接中辞二項演算子を、それがその左および右手側の引数としてとる式と組み合わせます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">left-hand argument</span> <span class="gi">operator</span> <span class="gi">right-hand argument</span>
</li></ol></div></div></div>
<p><span class="enstr">For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the operators provided by the Swift standard library, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">At parse time, an expression made up of infix operators is represented as a flat list. This list is transformed into a tree by applying operator precedence. For example, the expression <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code> is initially understood as a flat list of five items, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, and <code class="docutils literal notranslate"><span class="pre">5</span></code>. This process transforms it into the tree (2 + (3 * 5)).</span><!--end_enstr-->
<span class="jpstr">
構文解析の時、接中辞演算子から成り立つ式は、平坦なリストとして表わされます。このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。例えば、式<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>は、最初に５つの項目、<code class="docutils literal notranslate"><span class="pre">2</span></code>、<code class="docutils literal notranslate"><span class="pre">+</span></code>、<code class="docutils literal notranslate"><span class="pre">3</span></code>、<code class="docutils literal notranslate"><span class="pre">*</span></code>、そして<code class="docutils literal notranslate"><span class="pre">5</span></code>の平坦なリストとして理解されます。この処理は、それをツリー(2 + (3 * 5))に変えます。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an infix expression</span><!--end_enstr-->
<span class="jpstr">
接中辞式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-expression"></a>infix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_infix-operator">infix-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-expression_1061"></a>infix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_assignment-operator">assignment-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-expression_1062"></a>infix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_conditional-operator">conditional-operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_try-operator">try-operator</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_prefix-expression">prefix-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-expression_1063"></a>infix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_type-casting-operator">type-casting-operator</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-expressions"></a>infix-expressions</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_infix-expression">infix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_infix-expressions">infix-expressions</a></span> <sub>opt</sub></p>
</div>
</div>
<div class="section" id="ID386">
<h3><span class="enstr">Assignment Operator<a class="headerlink" href="#ID386" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
代入演算子<a class="headerlink" href="#ID386" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>assignment operator</em> sets a new value for a given expression. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>代入演算子</em>は、指定された式に対してある新しい値を設定します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span> = <span class="gi">value</span>
</li></ol></div></div></div>
<p><span class="enstr">The value of the <em>expression</em> is set to the value obtained by evaluating the <em>value</em>. If the <em>expression</em> is a tuple, the <em>value</em> must be a tuple with the same number of elements. (Nested tuples are allowed.) Assignment is performed from each part of the <em>value</em> to the corresponding part of the <em>expression</em>. For example:</span><!--end_enstr-->
<span class="jpstr">
<em>式</em>の値は、<em>値</em>を評価することによって得られる値に設定されます。<em>式</em>がタプルであるならば、<em>値</em>は同じ数の要素をもつタプルでなければなりません。（入れ子にされたタプルは、認められます）。代入は、<em>値</em>の各部分から<em>式</em>の対応する部分へと実行されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>(<span class="nv">a</span>, <span class="k">_</span>, (<span class="nv">b</span>, <span class="nv">c</span>)) = (<span class="s">"test"</span>, <span class="m">9.45</span>, (<span class="m">12</span>, <span class="m">3</span>))
</li>
<li>
<span class="c"><span class="enstr">// a is "test", b is 12, c is 3, and 9.45 is ignored</span><!--end_enstr--><span class="jpstr">（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The assignment operator doesn’t return any value.</span><!--end_enstr-->
<span class="jpstr">
代入演算子は、少しの値も返しません。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an assignment operator</span><!--end_enstr-->
<span class="jpstr">
代入演算子の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_assignment-operator"></a>assignment-operator</span><span class="arrow"> → </span> <code>=</code></p></div>
</div>
</div>
<div class="section" id="ID387">
<h3><span class="enstr">Ternary Conditional Operator<a class="headerlink" href="#ID387" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
三項条件演算子<a class="headerlink" href="#ID387" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>ternary conditional operator</em> evaluates to one of two given values based on the value of a condition. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>三項条件演算子</em>は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">condition</span> ? <span class="gi">expression used if true</span> : <span class="gi">expression used if false</span>
</li></ol></div></div></div>
<p><span class="enstr">If the <em>condition</em> evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, the conditional operator evaluates the first expression and returns its value. Otherwise, it evaluates the second expression and returns its value. The unused expression isn’t evaluated.</span><!--end_enstr-->
<span class="jpstr">
<em>条件</em>が<code class="docutils literal notranslate"><span class="pre">true</span></code>に評価されるならば、条件演算子は最初の式を評価して、その値を返します。そうでなければ、それは第二の式を評価して、その値を返します。使っていない式は、評価されません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For an example that uses the ternary conditional operator, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html#ID71"><span class="std std-ref">Ternary Conditional Operator</span></a>.</span><!--end_enstr-->
<span class="jpstr">
三項条件演算子を使用する例のために、<a class="reference internal" href="../LanguageGuide/BasicOperators.html#ID71"><span class="std std-ref">三項条件演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a conditional operator</span><!--end_enstr-->
<span class="jpstr">
条件演算子の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_conditional-operator"></a>conditional-operator</span><span class="arrow"> → </span> <code>?</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>:</code></p></div>
</div>
</div>
<div class="section" id="ID388">
<h3><span class="enstr">Type-Casting Operators<a class="headerlink" href="#ID388" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型キャスト演算子<a class="headerlink" href="#ID388" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">There are four type-casting operators: the <code class="docutils literal notranslate"><span class="pre">is</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">as</span></code> operator, the <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator, and the <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator.</span><!--end_enstr-->
<span class="jpstr">
４つの型キャスト演算子、<code class="docutils literal notranslate"><span class="pre">is</span></code>演算子、<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子、<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子、そして<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子があります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">They have the following form:</span><!--end_enstr-->
<span class="jpstr">
これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="gi">expression</span> <span class="k">is</span> <span class="gi">type</span>
</li>
<li>
<span class="gi">expression</span> <span class="k">as</span> <span class="gi">type</span>
</li>
<li>
<span class="gi">expression</span> <span class="k">as</span>? <span class="gi">type</span>
</li>
<li>
<span class="gi">expression</span> <span class="k">as</span>! <span class="gi">type</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">is</span></code> operator checks at runtime whether the <em>expression</em> can be cast to the specified <em>type</em>. It returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the <em>expression</em> can be cast to the specified <em>type</em>; otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">is</span></code>演算子は実行時に<em>式</em>が指定された<em>型</em>へとキャスト可能かどうかを調べます。それは、<em>式</em>が指定された<em>型</em>へキャストできるならば<code class="docutils literal notranslate"><span class="pre">true</span></code>を返します；そうでなければ<code class="docutils literal notranslate"><span class="pre">false</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">as</span></code> operator performs a cast when it’s known at compile time that the cast always succeeds, such as upcasting or bridging. Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable. The following approaches are equivalent:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。以下の各取り組みは同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">f</span>(<span class="k">_</span> <span class="nv">any</span>: <span class="k">Any</span>) { <span class="nv">print</span>(<span class="s">"Function for Any"</span>) }
</li>
<li>
<span class="k">func</span> <span class="nv">f</span>(<span class="k">_</span> <span class="nv">int</span>: <span class="nc">Int</span>) { <span class="nv">print</span>(<span class="s">"Function for Int"</span>) }
</li>
<li>
<span class="k">let</span> <span class="nv">x</span> = <span class="m">10</span>
</li>
<li>
<span class="nv">f</span>(<span class="nv">x</span>)
</li>
<li>
<span class="c">// Prints "Function for Int"</span>
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">y</span>: <span class="k">Any</span> = <span class="nv">x</span>
</li>
<li>
<span class="nv">f</span>(<span class="nv">y</span>)
</li>
<li>
<span class="c">// Prints "Function for Any"</span>
</li>
<li>
</li>
<li>
<span class="nv">f</span>(<span class="nv">x</span> <span class="k">as</span> <span class="k">Any</span>)
</li>
<li>
<span class="c">// Prints "Function for Any"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Bridging lets you use an expression of a Swift standard library type such as <code class="docutils literal notranslate"><span class="pre">String</span></code> as its corresponding Foundation type such as <code class="docutils literal notranslate"><span class="pre">NSString</span></code> without needing to create a new instance. For more information on bridging, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types.html">Working with Foundation Types</a>.</span><!--end_enstr-->
<span class="jpstr">
ブリッジは、あなたに<code class="docutils literal notranslate"><span class="pre">String</span></code>のようなスウィフト標準ライブラリ型の式を、<code class="docutils literal notranslate"><span class="pre">NSString</span></code>のようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。ブリッジに関するより多くの情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types.html">Foundation型を扱う</a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator performs a conditional cast of the <em>expression</em> to the specified <em>type</em>. The <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator returns an optional of the specified <em>type</em>. At runtime, if the cast succeeds, the value of <em>expression</em> is wrapped in an optional and returned; otherwise, the value returned is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If casting to the specified <em>type</em> is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子は<em>式</em>の指定された<em>型</em>への条件付きキャストを実行します。<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子は、指定された<em>型</em>のオプショナルを返します。実行時に、キャストが成功したならば、<em>式</em>の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。指定された<em>型</em>へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator performs a forced cast of the <em>expression</em> to the specified <em>type</em>. The <code class="docutils literal notranslate"><span class="pre">as!</span></code> operator returns a value of the specified <em>type</em>, not an optional type. If the cast fails, a runtime error is raised. The behavior of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as!</span> <span class="pre">T</span></code> is the same as the behavior of <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">as?</span> <span class="pre">T)!</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子は<em>式</em>の指定された<em>型</em>への強制的なキャストを実行します。<code class="docutils literal notranslate"><span class="pre">as!</span></code>演算子は指定された<em>型</em>の値を返します、オプショナル型ではなく。キャストが失敗したならば、実行時エラーが引き起こされます。<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as!</span> <span class="pre">T</span></code>の挙動は、<code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">as?</span> <span class="pre">T)!</span></code>の挙動と同じです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more information about type casting and to see examples that use the type-casting operators, see <a class="reference internal" href="../LanguageGuide/TypeCasting.html"><span class="doc">Type Casting</span></a>.</span><!--end_enstr-->
<span class="jpstr">
型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、<a class="reference internal" href="../LanguageGuide/TypeCasting.html"><span class="doc">型キャスト</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a type-casting operator</span><!--end_enstr-->
<span class="jpstr">
型キャスト演算子の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator"></a>type-casting-operator</span><span class="arrow"> → </span> <code>is</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1064"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1065"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <code>?</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_type-casting-operator_1066"></a>type-casting-operator</span><span class="arrow"> → </span> <code>as</code> <code>!</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p>
</div>
</div>
</div>
</div>
<div class="section" id="ID389">
<h2><span class="enstr">Primary Expressions<a class="headerlink" href="#ID389" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
基本式<a class="headerlink" href="#ID389" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Primary expressions</em> are the most basic kind of expression. They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, infix expressions, and postfix expressions.</span><!--end_enstr-->
<span class="jpstr">
<em>基本式</em>は、最も基本的な種類の式です。それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、接中辞式、そして接尾辞式を作るために別のトークンと組み合わされることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a primary expression</span><!--end_enstr-->
<span class="jpstr">
基本式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1067"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_literal-expression">literal-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1068"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-expression">self-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1069"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-expression">superclass-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1070"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-expression">closure-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1071"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_parenthesized-expression">parenthesized-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1072"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-expression">tuple-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1073"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_implicit-member-expression">implicit-member-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1074"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_wildcard-expression">wildcard-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1075"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-expression">key-path-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1076"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_selector-expression">selector-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_primary-expression_1077"></a>primary-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-string-expression">key-path-string-expression</a></span> </p>
</div>
</div>
<div class="section" id="ID390">
<h3><span class="enstr">Literal Expression<a class="headerlink" href="#ID390" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
リテラル式<a class="headerlink" href="#ID390" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>literal expression</em> consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:</span><!--end_enstr-->
<span class="jpstr">
<em>リテラル式</em>は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：
</span><!--end_jpstr-->
</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%">
<col width="21%">
<col width="65%">
</colgroup>
<thead valign="bottom">
<tr class="row-odd">
<th class="head"><span class="enstr">Literal</span><!--end_enstr-->
<span class="jpstr">
リテラル
</span><!--end_jpstr-->
</th>
<th class="head"><span class="enstr">Type</span><!--end_enstr-->
<span class="jpstr">
型
</span><!--end_jpstr-->
</th>
<th class="head"><span class="enstr">Value</span><!--end_enstr-->
<span class="jpstr">
値
</span><!--end_jpstr-->
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even">
<td><code class="docutils literal notranslate"><span class="pre">#file</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td><span class="enstr">The path to the file in which it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れるファイルへのパス。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd">
<td><code class="docutils literal notranslate"><span class="pre">#fileID</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td><span class="enstr">The name of the file and module in which it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れるファイルとモジュールの名前。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even">
<td><code class="docutils literal notranslate"><span class="pre">#filePath</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td><span class="enstr">The path to the file in which it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れるファイルへのパス。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd">
<td><code class="docutils literal notranslate"><span class="pre">#line</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">Int</span></code></td>
<td><span class="enstr">The line number on which it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れる行番号。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even">
<td><code class="docutils literal notranslate"><span class="pre">#column</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">Int</span></code></td>
<td><span class="enstr">The column number in which it begins.</span><!--end_enstr-->
<span class="jpstr">
それが始まるコラム番号。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd">
<td><code class="docutils literal notranslate"><span class="pre">#function</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">String</span></code></td>
<td><span class="enstr">The name of the declaration in which it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れる宣言の名前。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even">
<td><code class="docutils literal notranslate"><span class="pre">#dsohandle</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">UnsafeRawPointer</span></code></td>
<td><span class="enstr">The dynamic shared object (DSO) handle in use where it appears.</span><!--end_enstr-->
<span class="jpstr">
それが現れる用法での動的共有オブジェクト（DSO）ハンドル。
</span><!--end_jpstr-->
</td>
</tr>
</tbody>
</table>
<p><span class="enstr">The string value of <code class="docutils literal notranslate"><span class="pre">#file</span></code> depends on the language version, to enable migration from the old <code class="docutils literal notranslate"><span class="pre">#filePath</span></code> behavior to the new <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> behavior. Currently, <code class="docutils literal notranslate"><span class="pre">#file</span></code> has the same value as <code class="docutils literal notranslate"><span class="pre">#filePath</span></code>. In a future version of Swift, <code class="docutils literal notranslate"><span class="pre">#file</span></code> will have the same value as <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> instead. To adopt the future behavior, replace <code class="docutils literal notranslate"><span class="pre">#file</span></code> with <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> or <code class="docutils literal notranslate"><span class="pre">#filePath</span></code> as appropriate.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">#file</span></code>の文字列値は、言語バージョンに依存して、古い<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>挙動から新しい<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>挙動への移行が可能になります。現在は、<code class="docutils literal notranslate"><span class="pre">#file</span></code>は<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>と同じ値を持ちます。将来のバージョンのスウィフトでは、<code class="docutils literal notranslate"><span class="pre">#file</span></code>は代わりに<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>と同じ値を持つでしょう。将来の挙動を採用するには、<code class="docutils literal notranslate"><span class="pre">#file</span></code>を<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>または<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>で適切に置き換えてください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The string value of a <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> expression has the form <em>module</em>/<em>file</em>, where <em>file</em> is the name of the file in which the expression appears and <em>module</em> is the name of the module that this file is part of. The string value of a <code class="docutils literal notranslate"><span class="pre">#filePath</span></code> expression is the full file-system path to the file in which the expression appears. Both of these values can be changed by <code class="docutils literal notranslate"><span class="pre">#sourceLocation</span></code>, as described in <a class="reference internal" href="Statements.html#ID540"><span class="std std-ref">Line Control Statement</span></a>. Because <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> doesn’t embed the full path to the source file, unlike <code class="docutils literal notranslate"><span class="pre">#filePath</span></code>, it gives you better privacy and reduces the size of the compiled binary. Avoid using <code class="docutils literal notranslate"><span class="pre">#filePath</span></code> outside of tests, build scripts, or other code that doesn’t become part of the shipping program.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>式の文字列値は、形式<em>module</em>/<em>file</em>を持ちます、そこで<em>file</em>はそれにおいて拡張が現れるファイルの名前です、そして<em>module</em>はこのファイルがそれの一部であるところのモジュールの名前です。<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>式の文字列値は、それにおいて式が現れるファイルへの完全なファイルシステムパスです。これらの値の両方とも、<code class="docutils literal notranslate"><span class="pre">#sourceLocation</span></code>によって変更されることが、<a class="reference internal" href="Statements.html#ID540"><span class="std std-ref">行制御文</span></a>で記述されるように可能です。<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>は、<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>とは違い、ソースファイルへの完全パスを埋め込みません、それはあなたにより良いプライバシーを与えます、そしてコンパイル済みバイナリの大きさを減らします。<code class="docutils literal notranslate"><span class="pre">#filePath</span></code>を、テスト、スクリプトのビルド、または出荷プログラムの一部とはならないその他のコード以外で使うのを避けてください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">To parse a <code class="docutils literal notranslate"><span class="pre">#fileID</span></code> expression, read the module name as the text before the first slash (<code class="docutils literal notranslate"><span class="pre">/</span></code>) and the filename as the text after the last slash. In the future, the string might contain multiple slashes, such as <code class="docutils literal notranslate"><span class="pre">MyModule/some/disambiguation/MyFile.swift</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">#fileID</span></code>式を構文解析するには、モジュール名を最初のスラッシュ（<code class="docutils literal notranslate"><span class="pre">/</span></code>）の前のテキストと、そしてファイル名を最後のスラッシュの後のテキストと解釈してください。将来において、その文字列は複数のスラッシュを含むかもしれません、たとえば<code class="docutils literal notranslate"><span class="pre">MyModule/some/disambiguation/MyFile.swift</span></code>のように。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Inside a function, the value of <code class="docutils literal notranslate"><span class="pre">#function</span></code> is the name of that function, inside a method it’s the name of that method, inside a property getter or setter it’s the name of that property, inside special members like <code class="docutils literal notranslate"><span class="pre">init</span></code> or <code class="docutils literal notranslate"><span class="pre">subscript</span></code> it’s the name of that keyword, and at the top level of a file it’s the name of the current module.</span><!--end_enstr-->
<span class="jpstr">
関数の内側では、<code class="docutils literal notranslate"><span class="pre">#function</span></code>の値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、<code class="docutils literal notranslate"><span class="pre">init</span></code>または<code class="docutils literal notranslate"><span class="pre">subscript</span></code>のような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When used as the default value of a function or method parameter, the special literal’s value is determined when the default value expression is evaluated at the call site.</span><!--end_enstr-->
<span class="jpstr">
関数およびメソッドのパラメータの省略時の値として使われる時、特殊リテラルの値は、省略時値式が呼び出し現場で評価される場合は決定されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">logFunctionName</span>(<span class="nv">string</span>: <span class="nc">String</span> = <span class="k">#function</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="nv">string</span>)
</li>
<li>}
</li>
<li>
<span class="k">func</span> <span class="nv">myFunction</span>() {
</li>
<li>    <span class="nv">logFunctionName</span>() <span class="c">// Prints "myFunction()".</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">An <em>array literal</em> is an ordered collection of values. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>配列リテラル</em>は、順序付けられた値のコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">value 1</span>, <span class="gi">value 2</span>, <span class="gi">...</span>]
</li></ol></div></div></div>
<p><span class="enstr">The last expression in the array can be followed by an optional comma. The value of an array literal has type <code class="docutils literal notranslate"><span class="pre">[T]</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is the type of the expressions inside it. If there are expressions of multiple types, <code class="docutils literal notranslate"><span class="pre">T</span></code> is their closest common supertype. Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.</span><!--end_enstr-->
<span class="jpstr">
配列の最後の式の後に、１つの任意のコンマが続くことができます。配列リテラルの値は型<code class="docutils literal notranslate"><span class="pre">[T]</span></code>を持ちます、そこで、<code class="docutils literal notranslate"><span class="pre">T</span></code>はそれの内部の式の型です。複数の型の式があるならば、<code class="docutils literal notranslate"><span class="pre">T</span></code>はそれらの最も近い共通のスーパー型です。空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">emptyArray</span>: [<span class="nc">Double</span>] = []
</li></ol></div></div></div>
<p><span class="enstr">A <em>dictionary literal</em> is an unordered collection of key-value pairs. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>辞書リテラル</em>は、「キーと値」の対の順序付けされないコレクションです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>[<span class="gi">key 1</span>: <span class="gi">value 1</span>, <span class="gi">key 2</span>: <span class="gi">value 2</span>, <span class="gi">...</span>]
</li></ol></div></div></div>
<p><span class="enstr">The last expression in the dictionary can be followed by an optional comma. The value of a dictionary literal has type <code class="docutils literal notranslate"><span class="pre">[Key:</span> <span class="pre">Value]</span></code>, where <code class="docutils literal notranslate"><span class="pre">Key</span></code> is the type of its key expressions and <code class="docutils literal notranslate"><span class="pre">Value</span></code> is the type of its value expressions. If there are expressions of multiple types, <code class="docutils literal notranslate"><span class="pre">Key</span></code> and <code class="docutils literal notranslate"><span class="pre">Value</span></code> are the closest common supertype for their respective values. An empty dictionary literal is written as a colon inside a pair of brackets (<code class="docutils literal notranslate"><span class="pre">[:]</span></code>) to distinguish it from an empty array literal. You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.</span><!--end_enstr-->
<span class="jpstr">
辞書の最後の式の後に、１つの任意のコンマが続くことができます。辞書リテラルの値は、型<code class="docutils literal notranslate"><span class="pre">[Key:</span> <span class="pre">Value]</span></code>を持ちます、そこで、<code class="docutils literal notranslate"><span class="pre">Key</span></code>はそのキーの式の型です、そして、<code class="docutils literal notranslate"><span class="pre">Value</span></code>はその値の式の型です。複数の型の式があるならば、<code class="docutils literal notranslate"><span class="pre">Key</span></code>と<code class="docutils literal notranslate"><span class="pre">Value</span></code>はそれらめいめいの値に対して最も近い共通のスーパー型です。空の辞書リテラルは、一対の角括弧の中のコロン（<code class="docutils literal notranslate"><span class="pre">[:]</span></code>）として書かれることで、空の配列リテラルからそれを区別します。あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">emptyDictionary</span>: [<span class="nc">String</span>: <span class="nc">Double</span>] = [:]
</li></ol></div></div></div>
<p><span class="enstr">A <em>playground literal</em> is used by Xcode to create an interactive representation of a color, file, or image within the program editor. Playground literals in plain text outside of Xcode are represented using a special literal syntax.</span><!--end_enstr-->
<span class="jpstr">
<em>プレイグラウンドリテラル</em>は、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information on using playground literals in Xcode, see <a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc">Add a color, file, or image literal</a> in Xcode Help.</span><!--end_enstr-->
<span class="jpstr">
Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、<a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc">Add a color, file, or image literal</a>をXcodeヘルプで見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a literal expression</span><!--end_enstr-->
<span class="jpstr">
リテラル式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression"></a>literal-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_literal">literal</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression_1078"></a>literal-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal">array-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal">dictionary-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_playground-literal">playground-literal</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression_1079"></a>literal-expression</span><span class="arrow"> → </span> <code>#file</code> |  <code>#fileID</code> |  <code>#filePath</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_literal-expression_1080"></a>literal-expression</span><span class="arrow"> → </span> <code>#line</code> |  <code>#column</code> |  <code>#function</code> |  <code>#dsohandle</code></p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal"></a>array-literal</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-items">array-literal-items</a></span> <sub>opt</sub> <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal-items"></a>array-literal-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-item">array-literal-item</a></span>  <code>,</code><sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-item">array-literal-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_array-literal-items">array-literal-items</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_array-literal-item"></a>array-literal-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal"></a>dictionary-literal</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-items">dictionary-literal-items</a></span>  <code>]</code> |  <code>[</code> <code>:</code> <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal-items"></a>dictionary-literal-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-item">dictionary-literal-item</a></span>  <code>,</code><sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-item">dictionary-literal-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_dictionary-literal-items">dictionary-literal-items</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_dictionary-literal-item"></a>dictionary-literal-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal"></a>playground-literal</span><span class="arrow"> → </span> <code>#colorLiteral</code> <code>(</code> <code>red</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>green</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>blue</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>,</code> <code>alpha</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal_1081"></a>playground-literal</span><span class="arrow"> → </span> <code>#fileLiteral</code> <code>(</code> <code>resourceName</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_playground-literal_1082"></a>playground-literal</span><span class="arrow"> → </span> <code>#imageLiteral</code> <code>(</code> <code>resourceName</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
</div>
</div>
</div>
<div class="section" id="ID391">
<h3><span class="enstr">Self Expression<a class="headerlink" href="#ID391" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
self式<a class="headerlink" href="#ID391" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">self</span></code> expression is an explicit reference to the current type or instance of the type in which it occurs. It has the following forms:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">self</span>
</li>
<li>
<span class="k">self</span>.<span class="gi">member name</span>
</li>
<li>
<span class="k">self</span>[<span class="gi">subscript index</span>]
</li>
<li>
<span class="k">self</span>(<span class="gi">initializer arguments</span>)
</li>
<li>
<span class="k">self</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">In an initializer, subscript, or instance method, <code class="docutils literal notranslate"><span class="pre">self</span></code> refers to the current instance of the type in which it occurs. In a type method, <code class="docutils literal notranslate"><span class="pre">self</span></code> refers to the current type in which it occurs.</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ、添え字、またはインスタンスメソッドでは、<code class="docutils literal notranslate"><span class="pre">self</span></code>はそれが現れているところの型の現在のインスタンスに言及します。型メソッドでは、<code class="docutils literal notranslate"><span class="pre">self</span></code>はそれが現れているところの現在の型に言及します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">self</span></code> expression is used to specify scope when accessing members, providing disambiguation when there’s another variable of the same name in scope, such as a function parameter. For example:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">greeting</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">greeting</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">greeting</span> = <span class="nv">greeting</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">In a mutating method of a value type, you can assign a new instance of that value type to <code class="docutils literal notranslate"><span class="pre">self</span></code>. For example:</span><!--end_enstr-->
<span class="jpstr">
値型の変更メソッドでは、あなたは<code class="docutils literal notranslate"><span class="pre">self</span></code>にその値型の新しいインスタンスを代入することができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Point</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li>
<li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="k">self</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">x</span> + <span class="nv">deltaX</span>, <span class="nv">y</span>: <span class="nv">y</span> + <span class="nv">deltaY</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a self expression</span><!--end_enstr-->
<span class="jpstr">
self式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-expression"></a>self-expression</span><span class="arrow"> → </span> <code>self</code> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-method-expression">self-method-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-subscript-expression">self-subscript-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-initializer-expression">self-initializer-expression</a></span> </p></div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-method-expression"></a>self-method-expression</span><span class="arrow"> → </span> <code>self</code> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-subscript-expression"></a>self-subscript-expression</span><span class="arrow"> → </span> <code>self</code> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_self-initializer-expression"></a>self-initializer-expression</span><span class="arrow"> → </span> <code>self</code> <code>.</code> <code>init</code></p>
</div>
</div>
</div>
<div class="section" id="ID392">
<h3><span class="enstr">Superclass Expression<a class="headerlink" href="#ID392" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
スーパークラス式<a class="headerlink" href="#ID392" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>superclass expression</em> lets a class interact with its superclass. It has one of the following forms:</span><!--end_enstr-->
<span class="jpstr">
<em>スーパークラス式</em>は、あるクラスをそのスーパークラスと相互に作用させます。それは、以下の書式のうちの１つを持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">super</span>.<span class="gi">member name</span>
</li>
<li>
<span class="k">super</span>[<span class="gi">subscript index</span>]
</li>
<li>
<span class="k">super</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The first form is used to access a member of the superclass. The second form is used to access the superclass’s subscript implementation. The third form is used to access an initializer of the superclass.</span><!--end_enstr-->
<span class="jpstr">
最初の形式は、スーパークラスのメンバーにアクセスするために使われます。第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.</span><!--end_enstr-->
<span class="jpstr">
サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a superclass expression</span><!--end_enstr-->
<span class="jpstr">
スーパークラス式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-expression"></a>superclass-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-method-expression">superclass-method-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-subscript-expression">superclass-subscript-expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_superclass-initializer-expression">superclass-initializer-expression</a></span> </p></div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-method-expression"></a>superclass-method-expression</span><span class="arrow"> → </span> <code>super</code> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-subscript-expression"></a>superclass-subscript-expression</span><span class="arrow"> → </span> <code>super</code> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_superclass-initializer-expression"></a>superclass-initializer-expression</span><span class="arrow"> → </span> <code>super</code> <code>.</code> <code>init</code></p>
</div>
</div>
</div>
<div class="section" id="ID393">
<h3><span class="enstr">Closure Expression<a class="headerlink" href="#ID393" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クロージャ式<a class="headerlink" href="#ID393" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>closure expression</em> creates a closure, also known as a <em>lambda</em> or an <em>anonymous function</em> in other programming languages. Like a function declaration, a closure contains statements, and it captures constants and variables from its enclosing scope. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>クロージャ式</em>はクロージャ、他のプログラミング言語ではまた<em>lambda</em>または<em>匿名関数</em>として知られるものをつくります。関数宣言の様に、クロージャはいくつかの文を含みます、そしてそれは、定数と変数をそれの取り囲むスコープからキャプチャします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>{ (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> <span class="k">in</span>
</li>
<li>    <span class="gi">statements</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>parameters</em> have the same form as the parameters in a function declaration, as described in <a class="reference internal" href="Declarations.html#ID362"><span class="std std-ref">Function Declaration</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<em>パラメータ</em>は、関数宣言で記述されるように、<a class="reference internal" href="Declarations.html#ID362"><span class="std std-ref">関数宣言でのパラメータ</span></a>と同じ形式を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">There are several special forms that allow closures to be written more concisely:</span><!--end_enstr-->
<span class="jpstr">
クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">A closure can omit the types of its parameters, its return type, or both. If you omit the parameter names and both types, omit the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword before the statements. If the omitted types can’t be inferred, a compile-time error is raised.</span><!--end_enstr-->
<span class="jpstr">
クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。あなたがパラメータ名と両方の型を省略するならば、文の前の<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードを省略します。省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">A closure may omit names for its parameters. Its parameters are then implicitly named <code class="docutils literal notranslate"><span class="pre">$</span></code> followed by their position: <code class="docutils literal notranslate"><span class="pre">$0</span></code>, <code class="docutils literal notranslate"><span class="pre">$1</span></code>, <code class="docutils literal notranslate"><span class="pre">$2</span></code>, and so on.</span><!--end_enstr-->
<span class="jpstr">
クロージャは、そのパラメータの名前を省略することができます。そのパラメータは、それから暗黙のうちに<code class="docutils literal notranslate"><span class="pre">$</span></code>の後にそれらの位置が続く名前：<code class="docutils literal notranslate"><span class="pre">$0</span></code>、<code class="docutils literal notranslate"><span class="pre">$1</span></code>、<code class="docutils literal notranslate"><span class="pre">$2</span></code>、などをつけられます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">A closure that consists of only a single expression is understood to return the value of that expression. The contents of this expression are also considered when performing type inference on the surrounding expression.</span><!--end_enstr-->
<span class="jpstr">
１つの式だけから成るクロージャは、その式の値を返すと理解されます。この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">The following closure expressions are equivalent:</span><!--end_enstr-->
<span class="jpstr">
以下のクロージャ式は、等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">myFunction</span> { (<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> <span class="k">in</span>
</li>
<li>    <span class="k">return</span> <span class="nv">x</span> + <span class="nv">y</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="nv">myFunction</span> { <span class="nv">x</span>, <span class="nv">y</span> <span class="k">in</span>
</li>
<li>    <span class="k">return</span> <span class="nv">x</span> + <span class="nv">y</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="nv">myFunction</span> { <span class="k">return</span> <span class="nv">$0</span> + <span class="nv">$1</span> }
</li>
<li>
</li>
<li>
<span class="nv">myFunction</span> { <span class="nv">$0</span> + <span class="nv">$1</span> }
</li>
</ol></div></div></div>
<p><span class="enstr">For information about passing a closure as an argument to a function, see <a class="reference internal" href="#ID398"><span class="std std-ref">Function Call Expression</span></a>.</span><!--end_enstr-->
<span class="jpstr">
クロージャを引数として関数に渡すことに関する情報については、<a class="reference internal" href="#ID398"><span class="std std-ref">関数呼び出し式</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Closure expressions can be used without being stored in a variable or constant, such as when you immediately use a closure as part of a function call. The closure expressions passed to <code class="docutils literal notranslate"><span class="pre">myFunction</span></code> in code above are examples of this kind of immediate use. As a result, whether a closure expression is escaping or nonescaping depends on the surrounding context of the expression. A closure expression is nonescaping if it’s called immediately or passed as a nonescaping function argument. Otherwise, the closure expression is escaping.</span><!--end_enstr-->
<span class="jpstr">
クロージャ式は、変数や定数の中に格納されることなく利用できます、例えばあなたが直接にクロージャを関数呼び出しの一部として使う場合など。上のコードにおいて<code class="docutils literal notranslate"><span class="pre">myFunction</span></code>に渡されるクロージャ式は、この種の直接的な利用の例です。結果として、あるクロージャ式が脱出または非脱出であるかどうかは、その式を取り囲んでいる前後関係に依存します。クロージャ式は、もしそれが直接に呼び出されるか、または非脱出関数引数として渡されるならば非脱出です。それ以外では、クロージャ式は脱出です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more information about escaping closures, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">Escaping Closures</span></a>.</span><!--end_enstr-->
<span class="jpstr">
脱出クロージャについてのさらなる情報として、<a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">脱出クロージャ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID544">
<h4><span class="enstr">Capture Lists<a class="headerlink" href="#ID544" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
キャプチャリスト<a class="headerlink" href="#ID544" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values. You can use a <em>capture list</em> to explicitly control how values are captured in a closure.</span><!--end_enstr-->
<span class="jpstr">
初期状態では、クロージャ式は、それの周囲のスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。あなたは<em>キャプチャリスト</em>を使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A capture list is written as a comma-separated list of expressions surrounded by square brackets, before the list of parameters. If you use a capture list, you must also use the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword, even if you omit the parameter names, parameter types, and return type.</span><!--end_enstr-->
<span class="jpstr">
キャプチャリストは、角括弧に囲まれたいくらかの式からなる「コンマ区切り」のリストとして、パラメータのリストの前に書かれます。あなたがキャプチャリストを使うならば、あなたはまた<code class="docutils literal notranslate"><span class="pre">in</span></code>キーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The entries in the capture list are initialized when the closure is created. For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope. For example in the code below, <code class="docutils literal notranslate"><span class="pre">a</span></code> is included in the capture list but <code class="docutils literal notranslate"><span class="pre">b</span></code> is not, which gives them different behavior.</span><!--end_enstr-->
<span class="jpstr">
キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは周囲のスコープの中で同じ名前を待ちます。例えば以下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">a</span></code>はキャプチャリストに含まれますが<code class="docutils literal notranslate"><span class="pre">b</span></code>はそうではありません、そのことはそれらに異なる挙動を与えます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">a</span> = <span class="m">0</span>
</li>
<li>
<span class="k">var</span> <span class="nv">b</span> = <span class="m">0</span>
</li>
<li>
<span class="k">let</span> <span class="nv">closure</span> = { [<span class="nv">a</span>] <span class="k">in</span>
</li>
<li>    <span class="nv">print</span>(<span class="nv">a</span>, <span class="nv">b</span>)
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="nv">a</span> = <span class="m">10</span>
</li>
<li>
<span class="nv">b</span> = <span class="m">10</span>
</li>
<li>
<span class="nv">closure</span>()
</li>
<li>
<span class="c">// Prints "0 10"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">There are two different things named <code class="docutils literal notranslate"><span class="pre">a</span></code>, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named <code class="docutils literal notranslate"><span class="pre">b</span></code>. The <code class="docutils literal notranslate"><span class="pre">a</span></code> in the inner scope is initialized with the value of the <code class="docutils literal notranslate"><span class="pre">a</span></code> in the outer scope when the closure is created, but their values aren’t connected in any special way. This means that a change to the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the outer scope doesn’t affect the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> in the inner scope, nor does a change to <code class="docutils literal notranslate"><span class="pre">a</span></code> inside the closure affect the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> outside the closure. In contrast, there’s only one variable named <code class="docutils literal notranslate"><span class="pre">b</span></code>—the <code class="docutils literal notranslate"><span class="pre">b</span></code> in the outer scope—so changes from inside or outside the closure are visible in both places.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">a</span></code>と名前をつけられる２つの異なるものがあります、周囲のスコープにおける変数とクロージャのスコープにおける定数、しかし<code class="docutils literal notranslate"><span class="pre">b</span></code>と名前をつけられる変数はただひとつのものです。内側のスコープの中の<code class="docutils literal notranslate"><span class="pre">a</span></code>は、クロージャが作成される時に外側のスコープの中の<code class="docutils literal notranslate"><span class="pre">a</span></code>の値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。これが意味するのは、外側のスコープの<code class="docutils literal notranslate"><span class="pre">a</span></code>の値に対する変更は内側のスコープの<code class="docutils literal notranslate"><span class="pre">a</span></code>の値に影響を及ぼさない、そしてまたクロージャ内部の<code class="docutils literal notranslate"><span class="pre">a</span></code>に対する変更はクロージャ外部の<code class="docutils literal notranslate"><span class="pre">a</span></code>に影響を及ぼさないということです。対照的に、<code class="docutils literal notranslate"><span class="pre">b</span></code>と名前を付けられるただ１つだけの変数があります ― 外側のスコープの中の<code class="docutils literal notranslate"><span class="pre">b</span></code> ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This distinction isn’t visible when the captured variable’s type has reference semantics. For example, there are two things named <code class="docutils literal notranslate"><span class="pre">x</span></code> in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.</span><!--end_enstr-->
<span class="jpstr">
この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。例えば、<code class="docutils literal notranslate"><span class="pre">x</span></code>と名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SimpleClass</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">value</span>: <span class="nc">Int</span> = <span class="m">0</span>
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">x</span> = <span class="nv">SimpleClass</span>()
</li>
<li>
<span class="k">var</span> <span class="nv">y</span> = <span class="nv">SimpleClass</span>()
</li>
<li>
<span class="k">let</span> <span class="nv">closure</span> = { [<span class="nv">x</span>] <span class="k">in</span>
</li>
<li>    <span class="nv">print</span>(<span class="nv">x</span>.<span class="nv">value</span>, <span class="nv">y</span>.<span class="nv">value</span>)
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="nv">x</span>.<span class="nv">value</span> = <span class="m">10</span>
</li>
<li>
<span class="nv">y</span>.<span class="nv">value</span> = <span class="m">10</span>
</li>
<li>
<span class="nv">closure</span>()
</li>
<li>
<span class="c">// Prints "10 10"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">If the type of the expression’s value is a class, you can mark the expression in a capture list with <code class="docutils literal notranslate"><span class="pre">weak</span></code> or <code class="docutils literal notranslate"><span class="pre">unowned</span></code> to capture a weak or unowned reference to the expression’s value.</span><!--end_enstr-->
<span class="jpstr">
この式の値の型がクラスならば、あなたはその式をキャプチャリストの中で<code class="docutils literal notranslate"><span class="pre">weak</span></code>または<code class="docutils literal notranslate"><span class="pre">unowned</span></code>を使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">myFunction</span> { <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }                    <span class="enstr"><span class="c">// implicit strong capture</span></span><!--end_enstr--><span class="jpstr"><span class="c">（暗黙の強いキャプチャ）</span></span><!--end_jpstr--></li>
<li>
<span class="nv">myFunction</span> { [<span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }          <span class="c">// explicit strong capture</span>
</li>
<li>
<span class="nv">myFunction</span> { [<span class="k">weak</span> <span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>!.<span class="nv">title</span>) }    <span class="enstr"><span class="c">// weak capture</span></span><!--end_enstr--><span class="jpstr"><span class="c">（弱いキャプチャ）</span></span><!--end_jpstr--></li>
<li>
<span class="nv">myFunction</span> { [<span class="k">unowned</span> <span class="k">self</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="k">self</span>.<span class="nv">title</span>) }  <span class="enstr"><span class="c">// unowned capture</span></span><!--end_enstr--><span class="jpstr"><span class="c">（非所有キャプチャ）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">You can also bind an arbitrary expression to a named value in a capture list. The expression is evaluated when the closure is created, and the value is captured with the specified strength. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// Weak capture of "self.parent" as "parent"</span><!--end_enstr--><span class="jpstr">（「parent」としての弱いキャプチャ「self.parent」）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">myFunction</span> { [<span class="k">weak</span> <span class="nv">parent</span> = <span class="k">self</span>.<span class="nv">parent</span>] <span class="k">in</span> <span class="nv">print</span>(<span class="nv">parent</span>!.<span class="nv">title</span>) }
</li>
</ol></div></div></div>
<p><span class="enstr">For more information and examples of closure expressions, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID95"><span class="std std-ref">Closure Expressions</span></a>. For more information and examples of capture lists, see <a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID57"><span class="std std-ref">Resolving Strong Reference Cycles for Closures</span></a>.</span><!--end_enstr-->
<span class="jpstr">
クロージャ式のより多くの情報と例のために、<a class="reference internal" href="../LanguageGuide/Closures.html#ID95"><span class="std std-ref">クロージャ式</span></a>を見てください。キャプチャリストのより多くの情報と例のために、<a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID57"><span class="std std-ref">クロージャのための強い参照循環の解消</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a closure expression</span><!--end_enstr-->
<span class="jpstr">
クロージャ式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-expression"></a>closure-expression</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-signature">closure-signature</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_statements">statements</a></span> <sub>opt</sub> <code>}</code></p></div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-signature"></a>closure-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list">capture-list</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-clause">closure-parameter-clause</a></span>  <code>throws</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-result">function-result</a></span> <sub>opt</sub> <code>in</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-signature_1083"></a>closure-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list">capture-list</a></span>  <code>in</code></p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-clause"></a>closure-parameter-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-list">closure-parameter-list</a></span>  <code>)</code> |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier-list">identifier-list</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-list"></a>closure-parameter-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter">closure-parameter</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter">closure-parameter</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-list">closure-parameter-list</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter"></a>closure-parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-name">closure-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter_1084"></a>closure-parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-parameter-name">closure-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <code>...</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_closure-parameter-name"></a>closure-parameter-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list"></a>capture-list</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-items">capture-list-items</a></span>  <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-items"></a>capture-list-items</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-item">capture-list-item</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-item">capture-list-item</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-list-items">capture-list-items</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-item"></a>capture-list-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-specifier">capture-specifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-item_1085"></a>capture-list-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-specifier">capture-specifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>=</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-list-item_1086"></a>capture-list-item</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_capture-specifier">capture-specifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_self-expression">self-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_capture-specifier"></a>capture-specifier</span><span class="arrow"> → </span> <code>weak</code> |  <code>unowned</code> |  <code>unowned(safe)</code> |  <code>unowned(unsafe)</code></p>
</div>
</div>
</div>
</div>
<div class="section" id="ID394">
<h3><span class="enstr">Implicit Member Expression<a class="headerlink" href="#ID394" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
暗黙的メンバー式<a class="headerlink" href="#ID394" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>implicit member expression</em> is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>暗黙的メンバー式</em>は、型推論が暗黙の型を決定することができる文脈においてある型のメンバー、たとえば列挙ケース節や型メソッド、にアクセスするための簡略された方法です。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>.<span class="gi">member name</span>
</li></ol></div></div></div>
<p><span class="enstr">For example:</span><!--end_enstr-->
<span class="jpstr">
例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">x</span> = <span class="nv">MyEnumeration</span>.<span class="nv">someValue</span>
</li>
<li>
<span class="nv">x</span> = .<span class="nv">anotherValue</span>
</li>
</ol></div></div></div>
<p><span class="enstr">If the inferred type is an optional, you can also use a member of the non-optional type in an implicit member expression.</span><!--end_enstr-->
<span class="jpstr">
推論された型がオプショナルならば、あなたはまた非オプショナル型のメンバーを暗黙的メンバー式において使用できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">someOptional</span>: <span class="nc">MyEnumeration</span>? = .<span class="nv">someValue</span>
</li></ol></div></div></div>
<p><span class="enstr">Implicit member expressions can be followed by a postfix operator or other postfix syntax listed in <a class="reference internal" href="#ID397"><span class="std std-ref">Postfix Expressions</span></a>. This is called a <em>chained implicit member expression</em>. Although it’s common for all of the chained postfix expressions to have the same type, the only requirement is that the whole chained implicit member expression needs to be convertible to the type implied by its context. Specifically, if the implied type is an optional you can use a value of the non-optional type, and if the implied type is a class type you can use a value of one of its subclasses. For example:</span><!--end_enstr-->
<span class="jpstr">
暗黙的メンバー式は、<a class="reference internal" href="#ID397"><span class="std std-ref">接尾辞式</span></a>において一覧にされる接尾辞演算子または他の接尾辞構文を後に続けることが可能です。これは、<em>連鎖暗黙的メンバー式</em>と呼ばれます。連鎖にされた接尾辞式の全てが同じ型を持つのが普通であるとはいえ、唯一の要件は、連鎖暗黙的メンバー式の全体がそれの文脈によってほのめかされた型へと変換可能でなければならないことです。具体的には、その暗黙的型がオプショナルであるとしてもあなたは非オプショナル型の値を使用できます、そしてその暗黙的型がクラス型であるならばあなたはそれのサブクラスの１つの値を使用できます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">shared</span> = <span class="nv">SomeClass</span>()
</li>
<li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">sharedSubclass</span> = <span class="nv">SomeSubclass</span>()
</li>
<li>    <span class="k">var</span> <span class="nv">a</span> = <span class="nv">AnotherClass</span>()
</li>
<li>}
</li>
<li>
<span class="k">class</span> <span class="nv">SomeSubclass</span>: <span class="nc">SomeClass</span> { }
</li>
<li>
<span class="k">class</span> <span class="nv">AnotherClass</span> {
</li>
<li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">s</span> = <span class="nv">SomeClass</span>()
</li>
<li>    <span class="k">func</span> <span class="nv">f</span>() -&gt; <span class="nc">SomeClass</span> { <span class="k">return</span> <span class="nv">AnotherClass</span>.<span class="nv">s</span> }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">x</span>: <span class="nc">SomeClass</span> = .<span class="nv">shared</span>.<span class="nv">a</span>.<span class="nv">f</span>()
</li>
<li>
<span class="k">let</span> <span class="nv">y</span>: <span class="nc">SomeClass</span>? = .<span class="nv">shared</span>
</li>
<li>
<span class="k">let</span> <span class="nv">z</span>: <span class="nc">SomeClass</span> = .<span class="nv">sharedSubclass</span>
</li>
</ol></div></div></div>
<p><span class="enstr">In the code above, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> matches the type implied by its context exactly, the type of <code class="docutils literal notranslate"><span class="pre">y</span></code> is convertible from <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> to <code class="docutils literal notranslate"><span class="pre">SomeClass?</span></code>, and the type of <code class="docutils literal notranslate"><span class="pre">z</span></code> is convertible from <code class="docutils literal notranslate"><span class="pre">SomeSubclass</span></code> to <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>.</span><!--end_enstr-->
<span class="jpstr">
上のコードにおいて、<code class="docutils literal notranslate"><span class="pre">x</span></code>の型はそれの文脈によってほのめかされる型とぴったり合致します、<code class="docutils literal notranslate"><span class="pre">y</span></code>の型は<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>から<code class="docutils literal notranslate"><span class="pre">SomeClass?</span></code>へと変換可能です、そして<code class="docutils literal notranslate"><span class="pre">z</span></code>の型は<code class="docutils literal notranslate"><span class="pre">SomeSubclass</span></code>から<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>へと変換可能です。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a implicit member expression</span><!--end_enstr-->
<span class="jpstr">
暗黙的メンバー式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_implicit-member-expression"></a>implicit-member-expression</span><span class="arrow"> → </span> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_implicit-member-expression_1087"></a>implicit-member-expression</span><span class="arrow"> → </span> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span> </p>
</div>
</div>
</div>
<div class="section" id="ID395">
<h3><span class="enstr">Parenthesized Expression<a class="headerlink" href="#ID395" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
括弧に入れられた式<a class="headerlink" href="#ID395" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>parenthesized expression</em> consists of an expression surrounded by parentheses. You can use parentheses to specify the precedence of operations by explicitly grouping expressions. Grouping parentheses don’t change an expression’s type—for example, the type of <code class="docutils literal notranslate"><span class="pre">(1)</span></code> is simply <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>括弧に入れられた式</em>は、丸括弧で囲まれたある式から成ります。あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。グループ化括弧はある式のもつ型を変えません — 例えば、<code class="docutils literal notranslate"><span class="pre">(1)</span></code>の型は単に<code class="docutils literal notranslate"><span class="pre">Int</span></code>です。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a parenthesized expression</span><!--end_enstr-->
<span class="jpstr">
丸括弧に入れられた式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parenthesized-expression"></a>parenthesized-expression</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div>
</div>
</div>
<div class="section" id="ID552">
<h3><span class="enstr">Tuple Expression<a class="headerlink" href="#ID552" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
タプル式<a class="headerlink" href="#ID552" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>tuple expression</em> consists of a comma-separated list of expressions surrounded by parentheses. Each expression can have an optional identifier before it, separated by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>タプル式</em>は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。各式はそれの前に、コロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で区切られる任意の識別子を持つことができます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>(<span class="gi">identifier 1</span>: <span class="gi">expression 1</span>, <span class="gi">identifier 2</span>: <span class="gi">expression 2</span>, <span class="gi">...</span>)
</li></ol></div></div></div>
<p><span class="enstr">Each identifier in a tuple expression must be unique within the scope of the tuple expression. In a nested tuple expression, identifiers at the same level of nesting must be unique. For example, <code class="docutils literal notranslate"><span class="pre">(a:</span> <span class="pre">10,</span> <span class="pre">a:</span> <span class="pre">20)</span></code> is invalid because the label <code class="docutils literal notranslate"><span class="pre">a</span></code> appears twice at the same level. However, <code class="docutils literal notranslate"><span class="pre">(a:</span> <span class="pre">10,</span> <span class="pre">b:</span> <span class="pre">(a:</span> <span class="pre">1,</span> <span class="pre">x:</span> <span class="pre">2))</span></code> is valid—although <code class="docutils literal notranslate"><span class="pre">a</span></code> appears twice, it appears once in the outer tuple and once in the inner tuple.</span><!--end_enstr-->
<span class="jpstr">
あるタプル式の中の各識別子は、そのタプル式のスコープ内で特有でなければなりません。入れ子にされたタプル式において、同じ水準の入れ子での識別子それらは特有でなければなりません。例えば、<code class="docutils literal notranslate"><span class="pre">(a:</span> <span class="pre">10,</span> <span class="pre">a:</span> <span class="pre">20)</span></code>は無効です、なぜならラベル<code class="docutils literal notranslate"><span class="pre">a</span></code>が同じ水準で二度現れるからです。しかしながら、<code class="docutils literal notranslate"><span class="pre">(a:</span> <span class="pre">10,</span> <span class="pre">b:</span> <span class="pre">(a:</span> <span class="pre">1,</span> <span class="pre">x:</span> <span class="pre">2))</span></code>は有効です — もっとも<code class="docutils literal notranslate"><span class="pre">a</span></code>が二度現れますが、それは一度だけ外側タプルに、そして一度だけ内側タプルに現れます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A tuple expression can contain zero expressions, or it can contain two or more expressions. A single expression inside parentheses is a parenthesized expression.</span><!--end_enstr-->
<span class="jpstr">
タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Both an empty tuple expression and an empty tuple type are written <code class="docutils literal notranslate"><span class="pre">()</span></code> in Swift. Because <code class="docutils literal notranslate"><span class="pre">Void</span></code> is a type alias for <code class="docutils literal notranslate"><span class="pre">()</span></code>, you can use it to write an empty tuple type. However, like all type aliases, <code class="docutils literal notranslate"><span class="pre">Void</span></code> is always a type—you can’t use it to write an empty tuple expression.</span><!--end_enstr-->
<span class="jpstr">
空のタプル式と空のタプル型は両方とも、<code class="docutils literal notranslate"><span class="pre">()</span></code>とスウィフトでは書かれます。<code class="docutils literal notranslate"><span class="pre">Void</span></code>が<code class="docutils literal notranslate"><span class="pre">()</span></code>に対する型エイリアスであることから、あなたはそれを使って空のタプル型を書くことができます。しかしながら、すべての型エイリアスのように、<code class="docutils literal notranslate"><span class="pre">Void</span></code>は常にある型です—あなたはそれを使って空のタプル式を書くことはできません。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a tuple expression</span><!--end_enstr-->
<span class="jpstr">
タプル式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-expression"></a>tuple-expression</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element-list">tuple-element-list</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-element-list"></a>tuple-element-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element">tuple-element</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_tuple-element-list">tuple-element-list</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_tuple-element"></a>tuple-element</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p>
</div>
</div>
</div>
<div class="section" id="ID396">
<h3><span class="enstr">Wildcard Expression<a class="headerlink" href="#ID396" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ワイルドカード式<a class="headerlink" href="#ID396" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>wildcard expression</em> is used to explicitly ignore a value during an assignment. For example, in the following assignment 10 is assigned to <code class="docutils literal notranslate"><span class="pre">x</span></code> and 20 is ignored:</span><!--end_enstr-->
<span class="jpstr">
<em>ワイルドカード式</em>は、代入の間に明示的に値を無視するために使われます。例えば、以下の代入において、10は<code class="docutils literal notranslate"><span class="pre">x</span></code>に代入されて20は無視されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>(<span class="nv">x</span>, <span class="k">_</span>) = (<span class="m">10</span>, <span class="m">20</span>)
</li>
<li>
<span class="c"><span class="enstr">// x is 10, and 20 is ignored</span><!--end_enstr--><span class="jpstr">（xは10です、そして20は無視されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a wildcard expression</span><!--end_enstr-->
<span class="jpstr">
ワイルドカード式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_wildcard-expression"></a>wildcard-expression</span><span class="arrow"> → </span> <code>_</code></p></div>
</div>
</div>
<div class="section" id="ID563">
<h3><span class="enstr">Key-Path Expression<a class="headerlink" href="#ID563" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
キーパス式<a class="headerlink" href="#ID563" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>key-path expression</em> refers to a property or subscript of a type. You use key-path expressions in dynamic programming tasks, such as key-value observing. They have the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>キーパス式</em>は、ある型のプロパティまたは添え字を参照します。あなたはキーパス式を動的なプログラミング作業、例えばキー値監視などにおいて使用します。これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>\<span class="gi">type name</span>.<span class="gi">path</span>
</li></ol></div></div></div>
<p><span class="enstr">The <em>type name</em> is the name of a concrete type, including any generic parameters, such as <code class="docutils literal notranslate"><span class="pre">String</span></code>, <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>, or <code class="docutils literal notranslate"><span class="pre">Set&lt;Int&gt;</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>type name</em>は、ある具象型の名前で、何らかの総称体パラメータを含みます、例えば<code class="docutils literal notranslate"><span class="pre">String</span></code>、<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>、または<code class="docutils literal notranslate"><span class="pre">Set&lt;Int&gt;</span></code>など。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <em>path</em> consists of property names, subscripts, optional-chaining expressions, and forced unwrapping expressions. Each of these key-path components can be repeated as many times as needed, in any order.</span><!--end_enstr-->
<span class="jpstr">
<em>path</em>は、プロパティ名、添え字、「オプショナル連鎖」式、そして強制アンラップ式からなります。これらキーパス構成要素のそれぞれは、必要なだけ、任意の順序で、何度も繰り返されることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">At compile time, a key-path expression is replaced by an instance of the <a class="reference external" href="../../../developer.apple.com/documentation/swift/keypath.html"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a> class.</span><!--end_enstr-->
<span class="jpstr">
コンパイル時に、キーパス式は<a class="reference external" href="../../../developer.apple.com/documentation/swift/keypath.html"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a>クラスのインスタンスによって置き換えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To access a value using a key path, pass the key path to the <code class="docutils literal notranslate"><span class="pre">subscript(keyPath:)</span></code> subscript, which is available on all types. For example:</span><!--end_enstr-->
<span class="jpstr">
キーパスを使ってある値にアクセスするには、そのキーパスを<code class="docutils literal notranslate"><span class="pre">subscript(keyPath:)</span></code>添え字に渡してください、それは全ての型で利用可能です。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">someValue</span>: <span class="nc">Int</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">s</span> = <span class="nv">SomeStructure</span>(<span class="nv">someValue</span>: <span class="m">12</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">pathToProperty</span> = \<span class="nv">SomeStructure</span>.<span class="nv">someValue</span>
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">value</span> = <span class="nv">s</span>[<span class="nv">keyPath</span>: <span class="nv">pathToProperty</span>]
</li>
<li>
<span class="c"><span class="enstr">// value is 12</span><!--end_enstr--><span class="jpstr">（valueは12です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>type name</em> can be omitted in contexts where type inference can determine the implied type. The following code uses <code class="docutils literal notranslate"><span class="pre">\.someProperty</span></code> instead of <code class="docutils literal notranslate"><span class="pre">\SomeClass.someProperty</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<em>type name</em>は、型推論が暗黙の型を判定できるところの文脈では省略できます。以下のコードは、<code class="docutils literal notranslate"><span class="pre">\.someProperty</span></code>を<code class="docutils literal notranslate"><span class="pre">\SomeClass.someProperty</span></code>の代わりに使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li>
<li>    <span class="k">@objc</span> <span class="k">dynamic</span> <span class="k">var</span> <span class="nv">someProperty</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">someProperty</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">someProperty</span> = <span class="nv">someProperty</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>(<span class="nv">someProperty</span>: <span class="m">10</span>)
</li>
<li>
<span class="nv">c</span>.<span class="nv">observe</span>(\.<span class="nv">someProperty</span>) { <span class="nv">object</span>, <span class="nv">change</span> <span class="k">in</span>
</li>
<li>    <span class="c">// ...</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>path</em> can refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> to create the identity key path (<code class="docutils literal notranslate"><span class="pre">\.self</span></code>). The identity key path refers to a whole instance, so you can use it to access and change all of the data stored in a variable in a single step. For example:</span><!--end_enstr-->
<span class="jpstr">
<em>path</em>は、<code class="docutils literal notranslate"><span class="pre">self</span></code>を参照することで、同一性キーパス（<code class="docutils literal notranslate"><span class="pre">\.self</span></code>）を作成できます。同一性キーパスはインスタンス全体を参照します、それであなたはそれを使って、ただ一段階で変数の中に格納されたデータの全てにアクセスおよび変更できます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">compoundValue</span> = (<span class="nv">a</span>: <span class="m">1</span>, <span class="nv">b</span>: <span class="m">2</span>)
</li>
<li>
<span class="c"><span class="enstr">// Equivalent to compoundValue = (a: 10, b: 20)</span><!--end_enstr--><span class="jpstr">（compoundValue = (a: 10, b: 20) に等しい）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">compoundValue</span>[<span class="nv">keyPath</span>: \.<span class="k">self</span>] = (<span class="nv">a</span>: <span class="m">10</span>, <span class="nv">b</span>: <span class="m">20</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>path</em> can contain multiple property names, separated by periods, to refer to a property of a property’s value. This code uses the key path expression <code class="docutils literal notranslate"><span class="pre">\OuterStructure.outer.someValue</span></code> to access the <code class="docutils literal notranslate"><span class="pre">someValue</span></code> property of the <code class="docutils literal notranslate"><span class="pre">OuterStructure</span></code> type’s <code class="docutils literal notranslate"><span class="pre">outer</span></code> property:</span><!--end_enstr-->
<span class="jpstr">
<em>path</em>は、ピリオドで区切った複数のプロパティ名を含むことで、あるプロパティの持つ値に属するプロパティを参照できます。このコードは、キーパス式<code class="docutils literal notranslate"><span class="pre">\OuterStructure.outer.someValue</span></code>を使って、<code class="docutils literal notranslate"><span class="pre">someValue</span></code>プロパティにアクセスします、そのプロパティは<code class="docutils literal notranslate"><span class="pre">OuterStructure</span></code>型の持つ<code class="docutils literal notranslate"><span class="pre">outer</span></code>プロパティに属しています：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">OuterStructure</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">outer</span>: <span class="nc">SomeStructure</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">someValue</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">outer</span> = <span class="nv">SomeStructure</span>(<span class="nv">someValue</span>: <span class="nv">someValue</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">nested</span> = <span class="nv">OuterStructure</span>(<span class="nv">someValue</span>: <span class="m">24</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">nestedKeyPath</span> = \<span class="nv">OuterStructure</span>.<span class="nv">outer</span>.<span class="nv">someValue</span>
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">nestedValue</span> = <span class="nv">nested</span>[<span class="nv">keyPath</span>: <span class="nv">nestedKeyPath</span>]
</li>
<li>
<span class="c"><span class="enstr">// nestedValue is 24</span><!--end_enstr--><span class="jpstr">（nestedValue は 24 です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>path</em> can include subscripts using brackets, as long as the subscript’s parameter type conforms to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol. This example uses a subscript in a key path to access the second element of an array:</span><!--end_enstr-->
<span class="jpstr">
<em>path</em>は角括弧を使う添え字を含むことができます、その添え字の持つパラメータ型が<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>プロトコルに準拠する限りは。この例は、キーパス式において添え字を使って、配列の２番目の要素にアクセスします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">greetings</span> = [<span class="s">"hello"</span>, <span class="s">"hola"</span>, <span class="s">"bonjour"</span>, <span class="s">"안녕"</span>]
</li>
<li>
<span class="k">let</span> <span class="nv">myGreeting</span> = <span class="nv">greetings</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>].[<span class="m">1</span>]]
</li>
<li>
<span class="c"><span class="enstr">// myGreeting is 'hola'</span><!--end_enstr--><span class="jpstr">（myGreeting は 'hola' です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The value used in a subscript can be a named value or a literal. Values are captured in key paths using value semantics. The following code uses the variable <code class="docutils literal notranslate"><span class="pre">index</span></code> in both a key-path expression and in a closure to access the third element of the <code class="docutils literal notranslate"><span class="pre">greetings</span></code> array. When <code class="docutils literal notranslate"><span class="pre">index</span></code> is modified, the key-path expression still references the third element, while the closure uses the new index.</span><!--end_enstr-->
<span class="jpstr">
添え字の中で使われる値は、名前付きの値またはあるリテラルであることが可能です。様々な値は、キーパスの中に値意味論を使ってキャプチャされます。以下のコードは、変数<code class="docutils literal notranslate"><span class="pre">index</span></code>をキーパス式の中でそしてクロージャの中での両方で使うことで、<code class="docutils literal notranslate"><span class="pre">greetings</span></code>配列の３番目の要素にアクセスします。<code class="docutils literal notranslate"><span class="pre">index</span></code>が修正される時、キーパス式は依然として３番目の要素に参照を付けます、一方でクロージャは新しいインデックスを使用します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">index</span> = <span class="m">2</span>
</li>
<li>
<span class="k">let</span> <span class="nv">path</span> = \[<span class="nv">String</span>].[<span class="nv">index</span>]
</li>
<li>
<span class="k">let</span> <span class="nv">fn</span>: ([<span class="nc">String</span>]) -&gt; <span class="nc">String</span> = { <span class="nv">strings</span> <span class="k">in</span> <span class="nv">strings</span>[<span class="nv">index</span>] }
</li>
<li>
</li>
<li>
<span class="nv">print</span>(<span class="nv">greetings</span>[<span class="nv">keyPath</span>: <span class="nv">path</span>])
</li>
<li>
<span class="c">// Prints "bonjour"</span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">fn</span>(<span class="nv">greetings</span>))
</li>
<li>
<span class="c">// Prints "bonjour"</span>
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Setting 'index' to a new value doesn't affect 'path'</span><!--end_enstr--><span class="jpstr">（'index'を新しい値に設定することは、'path'に影響を与えない）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">index</span> += <span class="m">1</span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">greetings</span>[<span class="nv">keyPath</span>: <span class="nv">path</span>])
</li>
<li>
<span class="c">// Prints "bonjour"</span>
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Because 'fn' closes over 'index', it uses the new value</span><!--end_enstr--><span class="jpstr">（'fn'が'index'をしっかり掴むので、それは新しい値を使います）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">fn</span>(<span class="nv">greetings</span>))
</li>
<li>
<span class="c">// Prints "안녕"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>path</em> can use optional chaining and forced unwrapping. This code uses optional chaining in a key path to access a property of an optional string:</span><!--end_enstr-->
<span class="jpstr">
<em>path</em>は、オプショナル連鎖と強制アンラップを使うことができます。このコードは、オプショナル連鎖をキーパスの中で使うことで、あるオプショナル文字列に属するプロパティにアクセスします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">firstGreeting</span>: <span class="nc">String</span>? = <span class="nv">greetings</span>.<span class="nv">first</span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">firstGreeting</span>?.<span class="nv">count</span> <span class="k">as</span> <span class="k">Any</span>)
</li>
<li>
<span class="c">// Prints "Optional(5)"</span>
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Do the same thing using a key path.</span><!--end_enstr--><span class="jpstr">（同じことをキーパスを使って行う。）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">count</span> = <span class="nv">greetings</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>].<span class="nv">first</span>?.<span class="nv">count</span>]
</li>
<li>
<span class="nv">print</span>(<span class="nv">count</span> <span class="k">as</span> <span class="k">Any</span>)
</li>
<li>
<span class="c">// Prints "Optional(5)"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">You can mix and match components of key paths to access values that are deeply nested within a type. The following code accesses different values and properties of a dictionary of arrays by using key-path expressions that combine these components.</span><!--end_enstr-->
<span class="jpstr">
あなたは、キーパスの構成要素をうまく組み合わせることで、ある型の内部に深く入れ子にされた値にアクセスできます。以下のコードは、いくつかの配列からなる辞書に属する異なる値およびプロパティに、それらの構成要素を組み合わせるキーパス式を使うことでアクセスします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">interestingNumbers</span> = [<span class="s">"prime"</span>: [<span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>, <span class="m">11</span>, <span class="m">13</span>, <span class="m">17</span>],
</li>
<li>                          <span class="s">"triangular"</span>: [<span class="m">1</span>, <span class="m">3</span>, <span class="m">6</span>, <span class="m">10</span>, <span class="m">15</span>, <span class="m">21</span>, <span class="m">28</span>],
</li>
<li>                          <span class="s">"hexagonal"</span>: [<span class="m">1</span>, <span class="m">6</span>, <span class="m">15</span>, <span class="m">28</span>, <span class="m">45</span>, <span class="m">66</span>, <span class="m">91</span>]]
</li>
<li>
<span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">"prime"</span>]] <span class="k">as</span> <span class="k">Any</span>)
</li>
<li>
<span class="c">// Prints "Optional([2, 3, 5, 7, 11, 13, 17])"</span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">"prime"</span>]![<span class="m">0</span>]])
</li>
<li>
<span class="c"><span class="enstr">// Prints "2"</span><!--end_enstr--><span class="jpstr">（「2」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">"hexagonal"</span>]!.<span class="nv">count</span>])
</li>
<li>
<span class="c"><span class="enstr">// Prints "7"</span><!--end_enstr--><span class="jpstr">（「７」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">interestingNumbers</span>[<span class="nv">keyPath</span>: \[<span class="nv">String</span>: [<span class="nv">Int</span>]].[<span class="s">"hexagonal"</span>]!.<span class="nv">count</span>.<span class="nv">bitWidth</span>])
</li>
<li>
<span class="c"><span class="enstr">// Prints "64"</span><!--end_enstr--><span class="jpstr">（「64」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">You can use a key path expression in contexts where you would normally provide a function or closure. Specifically, you can use a key path expression whose root type is <code class="docutils literal notranslate"><span class="pre">SomeType</span></code> and whose path produces a value of type <code class="docutils literal notranslate"><span class="pre">Value</span></code>, instead of a function or closure of type <code class="docutils literal notranslate"><span class="pre">(SomeType)</span> <span class="pre">-&gt;</span> <span class="pre">Value</span></code>.</span><!--end_enstr-->
<span class="jpstr">
あなたはキーパス式を、あなたが通常は関数またはクロージャを提供するところの文脈において使用できます。とりわけ、あなたはそれのルート型が<code class="docutils literal notranslate"><span class="pre">SomeType</span></code>でそれのパスが型<code class="docutils literal notranslate"><span class="pre">Value</span></code>の値を生み出すキーパス式を、型<code class="docutils literal notranslate"><span class="pre">(SomeType)</span> <span class="pre">-&gt;</span> <span class="pre">Value</span></code>の関数またはクロージャの代わりに使用できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Task</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">var</span> <span class="nv">completed</span>: <span class="nc">Bool</span>
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">toDoList</span> = [
</li>
<li>    <span class="nv">Task</span>(<span class="nv">description</span>: <span class="s">"Practice ping-pong."</span>, <span class="nv">completed</span>: <span class="k">false</span>),
</li>
<li>    <span class="nv">Task</span>(<span class="nv">description</span>: <span class="s">"Buy a pirate costume."</span>, <span class="nv">completed</span>: <span class="k">true</span>),
</li>
<li>    <span class="nv">Task</span>(<span class="nv">description</span>: <span class="s">"Visit Boston in the Fall."</span>, <span class="nv">completed</span>: <span class="k">false</span>),
</li>
<li>]
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Both approaches below are equivalent.</span><!--end_enstr--><span class="jpstr">（下の両方の取り組みは等しいです。）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">descriptions</span> = <span class="nv">toDoList</span>.<span class="nv">filter</span>(\.<span class="nv">completed</span>).<span class="nv">map</span>(\.<span class="nv">description</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">descriptions2</span> = <span class="nv">toDoList</span>.<span class="nv">filter</span> { <span class="nv">$0</span>.<span class="nv">completed</span> }.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">description</span> }
</li>
</ol></div></div></div>
<p><span class="enstr">Any side effects of a key path expression are evaluated only at the point where the expression is evaluated. For example, if you make a function call inside a subscript in a key path expression, the function is called only once as part of evaluating the expression, not every time the key path is used.</span><!--end_enstr-->
<span class="jpstr">
キーパス式のあらゆる副作用は、式が評価されるところの時点でのみ評価されます。例えば、あなたがキーパス式の中の添え字内で関数呼び出しを作るならば、関数は式の評価の一部としてただ一度だけ呼び出されます、キーパス式が使われるたびごとではなく。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">makeIndex</span>() -&gt; <span class="nc">Int</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Made an index"</span>)
</li>
<li>    <span class="k">return</span> <span class="m">0</span>
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// The line below calls makeIndex().</span><!--end_enstr--><span class="jpstr">（下の行は makeIndex() を呼び出します。）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">taskKeyPath</span> = \[<span class="nv">Task</span>][<span class="nv">makeIndex</span>()]
</li>
<li>
<span class="c"><span class="enstr">// Prints "Made an index"</span><!--end_enstr--><span class="jpstr">（"Made an index" を出力します）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// Using taskKeyPath doesn't call makeIndex() again.</span><!--end_enstr--><span class="jpstr">（ taskKeyPath を使うことは、 makeIndex() を再び呼び出しません。）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">someTask</span> = <span class="nv">toDoList</span>[<span class="nv">keyPath</span>: <span class="nv">taskKeyPath</span>]
</li>
</ol></div></div></div>
<p><span class="enstr">For more information about using key paths in code that interacts with Objective-C APIs, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Using Objective-C Runtime Features in Swift</a>. For information about key-value coding and key-value observing, see <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">Key-Value Coding Programming Guide</a> and <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-Value Observing Programming Guide</a>.</span><!--end_enstr-->
<span class="jpstr">
Objective-C APIと相互作用するコードにおけるキーパスの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。キー値コーディングとキー値監視についての情報として、<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">キー値コーディングプログラミングガイド</a>と<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">キー値監視プログラミングガイド</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a key-path expression</span><!--end_enstr-->
<span class="jpstr">
キーパス式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-expression"></a>key-path-expression</span><span class="arrow"> → </span> <code>\</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> <sub>opt</sub> <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-components">key-path-components</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-components"></a>key-path-components</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-component">key-path-component</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-component">key-path-component</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-components">key-path-components</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-component"></a>key-path-component</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> <sub>opt</sub> |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-postfixes"></a>key-path-postfixes</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfix">key-path-postfix</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_key-path-postfixes">key-path-postfixes</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-postfix"></a>key-path-postfix</span><span class="arrow"> → </span> <code>?</code> |  <code>!</code> |  <code>self</code> |  <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p>
</div>
</div>
</div>
<div class="section" id="ID547">
<h3><span class="enstr">Selector Expression<a class="headerlink" href="#ID547" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
セレクタ式<a class="headerlink" href="#ID547" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">#selector</span>(<span class="gi">method name</span>)
</li>
<li>
<span class="k">#selector</span>(<span class="k">getter</span>: <span class="gi">property name</span>)
</li>
<li>
<span class="k">#selector</span>(<span class="k">setter</span>: <span class="gi">property name</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>method name</em> and <em>property name</em> must be a reference to a method or a property that’s available in the Objective-C runtime. The value of a selector expression is an instance of the <code class="docutils literal notranslate"><span class="pre">Selector</span></code> type. For example:</span><!--end_enstr-->
<span class="jpstr">
<em>method name</em>と<em>property name</em>は、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。セレクタ式の値は、<code class="docutils literal notranslate"><span class="pre">Selector</span></code>型のインスタンスです。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li>
<li>    <span class="k">@objc</span> <span class="k">let</span> <span class="nv">property</span>: <span class="nc">String</span>
</li>
<li>
</li>
<li>    <span class="k">@objc(doSomethingWithInt:)</span>
</li>
<li>    <span class="k">func</span> <span class="nv">doSomething</span>(<span class="k">_</span> <span class="nv">x</span>: <span class="nc">Int</span>) { }
</li>
<li>
</li>
<li>    <span class="k">init</span>(<span class="nv">property</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">property</span> = <span class="nv">property</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">selectorForMethod</span> = <span class="k">#selector</span>(<span class="nv">SomeClass</span>.<span class="nv">doSomething</span>(<span class="k">_</span>:))
</li>
<li>
<span class="k">let</span> <span class="nv">selectorForPropertyGetter</span> = <span class="k">#selector</span>(<span class="k">getter</span>: <span class="nv">SomeClass</span>.<span class="nv">property</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">When creating a selector for a property’s getter, the <em>property name</em> can be a reference to a variable or constant property. In contrast, when creating a selector for a property’s setter, the <em>property name</em> must be a reference to a variable property only.</span><!--end_enstr-->
<span class="jpstr">
プロパティのゲッターのためのセレクタを作成するとき、<em>property name</em>は変数または定数プロパティへの参照であることができます。対照的に、プロパティのセッターのためのセレクタを作成するとき、<em>property name</em>は必ず変数プロパティへの参照でなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <em>method name</em> can contain parentheses for grouping, as well the <code class="docutils literal notranslate"><span class="pre">as</span></code> operator to disambiguate between methods that share a name but have different type signatures. For example:</span><!--end_enstr-->
<span class="jpstr">
<em>method name</em>は、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするために<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子を含むことができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SomeClass</span> {
</li>
<li>    <span class="k">@objc(doSomethingWithString:)</span>
</li>
<li>    <span class="k">func</span> <span class="nv">doSomething</span>(<span class="k">_</span> <span class="nv">x</span>: <span class="nc">String</span>) { }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">anotherSelector</span> = <span class="k">#selector</span>(<span class="nv">SomeClass</span>.<span class="nv">doSomething</span>(<span class="k">_</span>:) <span class="k">as</span> (<span class="nc">SomeClass</span>) -&gt; (<span class="nc">String</span>) -&gt; <span class="nc">Void</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.</span><!--end_enstr-->
<span class="jpstr">
あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Although the <em>method name</em> and the <em>property name</em> are expressions, they’re never evaluated.</span><!--end_enstr-->
<span class="jpstr">
<em>method name（メソッド名）</em>と<em>property name（プロパティ名）</em>は式であるけれども、それらは決して評価されません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">For more information about using selectors in Swift code that interacts with Objective-C APIs, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Using Objective-C Runtime Features in Swift</a>.</span><!--end_enstr-->
<span class="jpstr">
Objective-C APIと相互作用するSwiftコードにおけるセレクタの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a selector expression</span><!--end_enstr-->
<span class="jpstr">
セレクタ式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression_1088"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <code>getter:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_selector-expression_1089"></a>selector-expression</span><span class="arrow"> → </span> <code>#selector</code> <code>(</code> <code>setter:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p>
</div>
</div>
</div>
<div class="section" id="ID549">
<h3><span class="enstr">Key-Path String Expression<a class="headerlink" href="#ID549" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
キーパス文字列式<a class="headerlink" href="#ID549" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A key-path string expression lets you access the string used to refer to a property in Objective-C, for use in key-value coding and key-value observing APIs. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
キーパス文字列式は、あなたにObjective-Cでのプロパティを参照するために使われる文字列にアクセスさせます、キー値コーディングとキー値監視APIで使用するために。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">#keyPath</span>(<span class="gi">property name</span>)
</li></ol></div></div></div>
<p><span class="enstr">The <em>property name</em> must be a reference to a property that’s available in the Objective-C runtime. At compile time, the key-path string expression is replaced by a string literal. For example:</span><!--end_enstr-->
<span class="jpstr">
<em>property name</em>は、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。コンパイル時で、キーパス文字列式は文字列リテラルによって置き換えられます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">NSObject</span> {
</li>
<li>    <span class="k">@objc</span> <span class="k">var</span> <span class="nv">someProperty</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">someProperty</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">someProperty</span> = <span class="nv">someProperty</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>(<span class="nv">someProperty</span>: <span class="m">12</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">keyPath</span> = <span class="k">#keyPath</span>(<span class="nv">SomeClass</span>.<span class="nv">someProperty</span>)
</li>
<li>
</li>
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> = <span class="nv">c</span>.<span class="nv">value</span>(<span class="nv">forKey</span>: <span class="nv">keyPath</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="nv">value</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "12"</span><!--end_enstr--><span class="jpstr">（「12」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">When you use a key-path string expression within a class, you can refer to a property of that class by writing just the property name, without the class name.</span><!--end_enstr-->
<span class="jpstr">
あなたがキーパス文字列式をあるクラス内で使う時、あなたはそのクラスのプロパティを参照することが、クラス名なしで単にそのプロパティ名を書くことによって可能です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SomeClass</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">getSomeKeyPath</span>() -&gt; <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="k">#keyPath</span>(<span class="nv">someProperty</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="nv">print</span>(<span class="nv">keyPath</span> == <span class="nv">c</span>.<span class="nv">getSomeKeyPath</span>())
</li>
<li>
<span class="c"><span class="enstr">// Prints "true"</span><!--end_enstr--><span class="jpstr">（「true」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Because the key path string is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.</span><!--end_enstr-->
<span class="jpstr">
キーパス文字列は実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more information about using key paths in Swift code that interacts with Objective-C APIs, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Using Objective-C Runtime Features in Swift</a>. For information about key-value coding and key-value observing, see <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">Key-Value Coding Programming Guide</a> and <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">Key-Value Observing Programming Guide</a>.</span><!--end_enstr-->
<span class="jpstr">
Objective-C APIと相互作用するSwiftコードにおけるキーパスの使用についてのさらなる情報として、<a class="reference external" href="../../../developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift.html">Objective-Cランタイム機能をSwiftで使用する</a>を見てください。キー値コーディングとキー値監視についての情報として、<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i">キー値コーディングプログラミングガイド</a>と<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i">キー値監視プログラミングガイド</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Although the <em>property name</em> is an expression, it’s never evaluated.</span><!--end_enstr-->
<span class="jpstr">
<em>property name（プロパティ名）</em>は式であるけれども、それは決して評価されません。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a key-path string expression</span><!--end_enstr-->
<span class="jpstr">
キーパス文字列式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_key-path-string-expression"></a>key-path-string-expression</span><span class="arrow"> → </span> <code>#keyPath</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  <code>)</code></p></div>
</div>
</div>
</div>
<div class="section" id="ID397">
<h2><span class="enstr">Postfix Expressions<a class="headerlink" href="#ID397" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
接尾辞式<a class="headerlink" href="#ID397" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Postfix expressions</em> are formed by applying a postfix operator or other postfix syntax to an expression. Syntactically, every primary expression is also a postfix expression.</span><!--end_enstr-->
<span class="jpstr">
<em>接尾辞式</em>は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。統語論的に、あらゆる基本式は、また、接尾辞式です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the behavior of these operators, see <a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">Basic Operators</span></a> and <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">Advanced Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
これらの演算子の挙動に関して詳しくは、<a class="reference internal" href="../LanguageGuide/BasicOperators.html"><span class="doc">基本の演算子</span></a>と<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html"><span class="doc">先進の演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the operators provided by the Swift standard library, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報のために、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a postfix expression</span><!--end_enstr-->
<span class="jpstr">
接尾辞式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_primary-expression">primary-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1090"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_postfix-operator">postfix-operator</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1091"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-expression">function-call-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1092"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_initializer-expression">initializer-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1093"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_explicit-member-expression">explicit-member-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1094"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-self-expression">postfix-self-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1095"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_subscript-expression">subscript-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1096"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_forced-value-expression">forced-value-expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-expression_1097"></a>postfix-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_optional-chaining-expression">optional-chaining-expression</a></span> </p>
</div>
</div>
<div class="section" id="ID398">
<h3><span class="enstr">Function Call Expression<a class="headerlink" href="#ID398" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
関数呼び出し式<a class="headerlink" href="#ID398" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>function call expression</em> consists of a function name followed by a comma-separated list of the function’s arguments in parentheses. Function call expressions have the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>関数呼び出し式</em>は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">function name</span>(<span class="gi">argument value 1</span>, <span class="gi">argument value 2</span>)
</li></ol></div></div></div>
<p><span class="enstr">The <em>function name</em> can be any expression whose value is of a function type.</span><!--end_enstr-->
<span class="jpstr">
<em>関数名</em>は、それの値が関数型のものであるどんな式でも可能です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If the function definition includes names for its parameters, the function call must include names before its argument values, separated by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). This kind of function call expression has the following form:</span><!--end_enstr-->
<span class="jpstr">
関数定義がそれのパラメータそれらの名前を含むならば、関数呼び出しはそれの引数値の前に名前を、コロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）で区切って含まなければなりません。この種類の関数呼び出し式は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">function name</span>(<span class="gi">argument name 1</span>: <span class="gi">argument value 1</span>, <span class="gi">argument name 2</span>: <span class="gi">argument value 2</span>)
</li></ol></div></div></div>
<p><span class="enstr">A function call expression can include trailing closures in the form of closure expressions immediately after the closing parenthesis. The trailing closures are understood as arguments to the function, added after the last parenthesized argument. The first closure expression is unlabeled; any additional closure expressions are preceded by their argument labels. The example below shows the equivalent version of function calls that do and don’t use trailing closure syntax:</span><!--end_enstr-->
<span class="jpstr">
関数呼び出し式は、閉じ丸括弧の直後にクロージャ式の形で後付クロージャいくつかを含むことができます。後付クロージャそれらは、関数に対する引数それらとして理解されます、そして、丸括弧に入れられた最後の引数の後に加えられます。最初のクロージャ式は、ラベルをつけられません；あらゆる追加的なクロージャ式は、それらの引数ラベルを前に置かれます。下の例は、後付クロージャ構文を使用および使用しない同等版の関数呼び出しを示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// someFunction takes an integer and a closure as its arguments</span><!--end_enstr--><span class="jpstr">（someFunctionは、その引数としてある整数とあるクロージャをとります）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">someFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>, <span class="nv">f</span>: { <span class="nv">$0</span> == <span class="m">13</span> })
</li>
<li>
<span class="nv">someFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>) { <span class="nv">$0</span> == <span class="m">13</span> }
</li>
<li>
</li>
<li>
<span class="c"><span class="enstr">// anotherFunction takes an integer and two closures as its arguments</span><!--end_enstr--><span class="jpstr">（anotherFunctionは、その引数としてある整数と２つのクロージャをとります）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">anotherFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>, <span class="nv">f</span>: { <span class="nv">$0</span> == <span class="m">13</span> }, <span class="nv">g</span>: { <span class="nv">print</span>(<span class="m">99</span>) })
</li>
<li>
<span class="nv">anotherFunction</span>(<span class="nv">x</span>: <span class="nv">x</span>) { <span class="nv">$0</span> == <span class="m">13</span> } <span class="nv">g</span>: { <span class="nv">print</span>(<span class="m">99</span>) }
</li>
</ol></div></div></div>
<p><span class="enstr">If the trailing closure is the function’s only argument, you can omit the parentheses.</span><!--end_enstr-->
<span class="jpstr">
後付クロージャがその関数のもつただ１つの引数であるならば、あなたは丸括弧を省略できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// someMethod takes a closure as its only argument</span><!--end_enstr--><span class="jpstr">（someMethodは、そのただ１つの引数としてクロージャをとります）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">myData</span>.<span class="nv">someMethod</span>() { <span class="nv">$0</span> == <span class="m">13</span> }
</li>
<li>
<span class="nv">myData</span>.<span class="nv">someMethod</span> { <span class="nv">$0</span> == <span class="m">13</span> }
</li>
</ol></div></div></div>
<p><span class="enstr">To include the trailing closures in the arguments, the compiler examines the function’s parameters from left to right as follows:</span><!--end_enstr-->
<span class="jpstr">
後付クロージャを引数それらの中に含めるために、コンパイラは関数のもつパラメータを左から右へと調査します、次のように：
</span><!--end_jpstr-->
</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%">
<col width="13%">
<col width="65%">
</colgroup>
<thead valign="bottom">
<tr class="row-odd">
<th class="head"><span class="enstr">Trailing Closure</span><!--end_enstr-->
<span class="jpstr">
後付クロージャ
</span><!--end_jpstr-->
</th>
<th class="head"><span class="enstr">Parameter</span><!--end_enstr-->
<span class="jpstr">
パラメータ
</span><!--end_jpstr-->
</th>
<th class="head"><span class="enstr">Action</span><!--end_enstr-->
<span class="jpstr">
動作
</span><!--end_jpstr-->
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even">
<td><span class="enstr">Labeled</span><!--end_enstr-->
<span class="jpstr">
ラベル付き
</span><!--end_jpstr-->
</td>
<td><span class="enstr">Labeled</span><!--end_enstr-->
<span class="jpstr">
ラベル付き
</span><!--end_jpstr-->
</td>
<td><span class="enstr">If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped.</span><!--end_enstr-->
<span class="jpstr">
ラベルそれらが同じならば、クロージャはパラメータと合致します；そうでなければ、パラメータは飛ばされます。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-odd">
<td><span class="enstr">Labeled</span><!--end_enstr-->
<span class="jpstr">
ラベル付き
</span><!--end_jpstr-->
</td>
<td><span class="enstr">Unlabeled</span><!--end_enstr-->
<span class="jpstr">
ラベルなし
</span><!--end_jpstr-->
</td>
<td><span class="enstr">The parameter is skipped.</span><!--end_enstr-->
<span class="jpstr">
パラメータは飛ばされます。
</span><!--end_jpstr-->
</td>
</tr>
<tr class="row-even">
<td><span class="enstr">Unlabeled</span><!--end_enstr-->
<span class="jpstr">
ラベルなし
</span><!--end_jpstr-->
</td>
<td><span class="enstr">Labeled or unlabeled</span><!--end_enstr-->
<span class="jpstr">
ラベル付きまたはラベルなし
</span><!--end_jpstr-->
</td>
<td><span class="enstr">If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped.</span><!--end_enstr-->
<span class="jpstr">
下で定義されるように、パラメータが構造的に関数型に似ているならば、クロージャはそのパラメータと合致します；そうでなければ、パラメータは飛ばされます。
</span><!--end_jpstr-->
</td>
</tr>
</tbody>
</table>
<p><span class="enstr">The trailing closure is passed as the argument for the parameter that it matches. Parameters that were skipped during the scanning process don’t have an argument passed to them—for example, they can use a default parameter. After finding a match, scanning continues with the next trailing closure and the next parameter. At the end of the matching process, all trailing closures must have a match.</span><!--end_enstr-->
<span class="jpstr">
後付クロージャは、それが合致するパラメータに対して引数として渡されます。走査処理の間に飛ばされたパラメータそれらは、それらに渡される引数を持ちません — 例えば、それらはある省略時パラメータを使用できます。ある合致を見つけた後、走査は、次の後付クロージャと次のパラメータで継続します。合致処理の終わりで、全ての後付クロージャはある合致を持たなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A parameter <em>structurally resembles</em> a function type if the parameter isn’t an in-out parameter, and the parameter is one of the following:</span><!--end_enstr-->
<span class="jpstr">
パラメータは、そのパラメータがin-outパラメータでないならば関数型と<em>構造的に似ています</em>、そしてそのパラメータは以下の１つです：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">A parameter whose type is a function type, like <code class="docutils literal notranslate"><span class="pre">(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code></span><!--end_enstr-->
<span class="jpstr">
それの型が関数型であるパラメータ、たとえば<code class="docutils literal notranslate"><span class="pre">(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>
</span><!--end_jpstr-->

</li>
<li><span class="enstr">An autoclosure parameter whose wrapped expression’s type is a function type, like <code class="docutils literal notranslate"><span class="pre">@autoclosure</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">((Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code></span><!--end_enstr-->
<span class="jpstr">
それのラップした式のもつ型が関数型である自動クロージャパラメータ、たとえば<code class="docutils literal notranslate"><span class="pre">@autoclosure</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">((Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code>
</span><!--end_jpstr-->

</li>
<li><span class="enstr">A variadic parameter whose array element type is a function type, like <code class="docutils literal notranslate"><span class="pre">((Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int)...</span></code></span><!--end_enstr-->
<span class="jpstr">
それの配列要素型が関数型である可変長パラメータ、たとえば<code class="docutils literal notranslate"><span class="pre">((Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int)...</span></code>
</span><!--end_jpstr-->

</li>
<li><span class="enstr">A parameter whose type is wrapped in one or more layers of optional, like <code class="docutils literal notranslate"><span class="pre">Optional&lt;(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int&gt;</span></code></span><!--end_enstr-->
<span class="jpstr">
それの型が１つ以上のオプショナルのレイヤーの中にラップされるパラメータ、たとえば<code class="docutils literal notranslate"><span class="pre">Optional&lt;(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int&gt;</span></code>
</span><!--end_jpstr-->

</li>
<li><span class="enstr">A parameter whose type combines these allowed types, like <code class="docutils literal notranslate"><span class="pre">(Optional&lt;(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int&gt;)...</span></code></span><!--end_enstr-->
<span class="jpstr">
それの型は許可される型それらを組み合わせるものであるパラメータ、たとえば<code class="docutils literal notranslate"><span class="pre">(Optional&lt;(Bool)</span> <span class="pre">-&gt;</span> <span class="pre">Int&gt;)...</span></code>
</span><!--end_jpstr-->

</li>
</ul>
<p><span class="enstr">When a trailing closure is matched to a parameter whose type structurally resembles a function type, but isn’t a function, the closure is wrapped as needed. For example, if the parameter’s type is an optional type, the closure is wrapped in <code class="docutils literal notranslate"><span class="pre">Optional</span></code> automatically.</span><!--end_enstr-->
<span class="jpstr">
後付クロージャが、それの型が構造的に関数型と似ている、しかし関数でないパラメータと組み合わされる場合、クロージャは必要に応じてラップされます。例えば、パラメータのもつ型がオプショナル型であるならば、クロージャは自動的に<code class="docutils literal notranslate"><span class="pre">Optional</span></code>にラップされます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To ease migration of code from versions of Swift prior to 5.3—which performed this matching from right to left—the compiler checks both the left-to-right and right-to-left orderings. If the scan directions produce different results, the old right-to-left ordering is used and the compiler generates a warning. A future version of Swift will always use the left-to-right ordering.</span><!--end_enstr-->
<span class="jpstr">
5.3より前のスウィフトのバージョンからのコードの移行を簡単にするために — それはこの合致を右から左に実行しました — コンパイラは左から右と右から左順の両方を調べます。走査方向が異なる結果を生じるならば、古い右から左順が使われます、そしてコンパイラは警告を生成します。スウィフトの将来のバージョンは、常に左から右順を使うでしょう。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">typealias</span> <span class="nv">Callback</span> = (<span class="nc">Int</span>) -&gt; <span class="nc">Int</span>
</li>
<li>
<span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">firstClosure</span>: <span class="nc">Callback</span>? = <span class="k">nil</span>,
</li>
<li>                  <span class="nv">secondClosure</span>: <span class="nc">Callback</span>? = <span class="k">nil</span>) {
</li>
<li>    <span class="k">let</span> <span class="nv">first</span> = <span class="nv">firstClosure</span>?(<span class="m">10</span>)
</li>
<li>    <span class="k">let</span> <span class="nv">second</span> = <span class="nv">secondClosure</span>?(<span class="m">20</span>)
</li>
<li>    <span class="nv">print</span>(<span class="nv">first</span> ?? <span class="s">"-"</span>, <span class="nv">second</span> ?? <span class="s">"-"</span>)
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="nv">someFunction</span>()  <span class="c">// Prints "- -"</span>
</li>
<li>
<span class="nv">someFunction</span> { <span class="k">return</span> <span class="nv">$0</span> + <span class="m">100</span> }  <span class="enstr"><span class="c">// Ambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></li>
<li>
<span class="nv">someFunction</span> { <span class="k">return</span> <span class="nv">$0</span> } <span class="nv">secondClosure</span>: { <span class="k">return</span> <span class="nv">$0</span> }  <span class="c">// Prints "10 20"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">In the example above, the function call marked “Ambiguous” prints “- 120” and produces a compiler warning on Swift 5.3. A future version of Swift will print “110 -”.</span><!--end_enstr-->
<span class="jpstr">
上の例において、“あいまい（Ambiguous）” と印される関数呼び出しは “- 120” を出力します、そしてコンパイラ警告をSwift 5.3で生成します。スウィフトの将来のバージョンは、“110 -” を出力するでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A class, structure, or enumeration type can enable syntactic sugar for function call syntax by declaring one of several methods, as described in <a class="reference internal" href="Declarations.html#ID622"><span class="std std-ref">Methods with Special Names</span></a>.</span><!--end_enstr-->
<span class="jpstr">
クラス、構造体、または列挙型は、構文糖を関数呼び出し構文に対して可能にすることが、幾つかのメソッドの１つを宣言することによって可能です、<a class="reference internal" href="Declarations.html#ID622"><span class="std std-ref">特殊名を持つメソッド</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID632">
<h4><span class="enstr">Implicit Conversion to a Pointer Type<a class="headerlink" href="#ID632" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ポインター型への暗黙的変換<a class="headerlink" href="#ID632" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">In a function call expression, if the argument and parameter have a different type, the compiler tries to make their types match by applying one of the implicit conversions in the following list:</span><!--end_enstr-->
<span class="jpstr">
関数呼び出し式において、引数とパラメータが異なる型を持つならば、コンパイラはそれらの型を合致させようと試みます、以下のリストにおける暗黙的変換のうちの１つを適用することによって：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">inout</span> <span class="pre">SomeType</span></code> can become <code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">UnsafeMutablePointer&lt;SomeType&gt;</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">inout</span> <span class="pre">SomeType</span></code>は、<code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code>または<code class="docutils literal notranslate"><span class="pre">UnsafeMutablePointer&lt;SomeType&gt;</span></code>になれます
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">inout</span> <span class="pre">Array&lt;SomeType&gt;</span></code> can become <code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">UnsafeMutablePointer&lt;SomeType&gt;</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">inout</span> <span class="pre">Array&lt;SomeType&gt;</span></code>は、<code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code>または<code class="docutils literal notranslate"><span class="pre">UnsafeMutablePointer&lt;SomeType&gt;</span></code>になれます
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">Array&lt;SomeType&gt;</span></code> can become <code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Array&lt;SomeType&gt;</span></code>は、<code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;SomeType&gt;</span></code>になれます
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">String</span></code> can become <code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;CChar&gt;</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">String</span></code>は、<code class="docutils literal notranslate"><span class="pre">UnsafePointer&lt;CChar&gt;</span></code>になれます
</span><!--end_jpstr-->

</li>
</ul>
<p><span class="enstr">The following two function calls are equivalent:</span><!--end_enstr-->
<span class="jpstr">
以下の２つの関数呼び出しは、同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">unsafeFunction</span>(<span class="nv">pointer</span>: <span class="nc">UnsafePointer</span>&lt;<span class="nc">Int</span>&gt;) {
</li>
<li>    <span class="c">// ...</span>
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">myNumber</span> = <span class="m">1234</span>
</li>
<li>
</li>
<li>
<span class="nv">unsafeFunction</span>(<span class="nv">pointer</span>: &amp;<span class="nv">myNumber</span>)
</li>
<li>
<span class="nv">withUnsafePointer</span>(<span class="nv">to</span>: <span class="nv">myNumber</span>) { <span class="nv">unsafeFunction</span>(<span class="nv">pointer</span>: <span class="nv">$0</span>) }
</li>
</ol></div></div></div>
<p><span class="enstr">A pointer that’s created by these implicit conversions is valid only for the duration of the function call. To avoid undefined behavior, ensure that your code never persists the pointer after the function call ends.</span><!--end_enstr-->
<span class="jpstr">
これらの暗黙的変換によって作成されるポインタは、その関数呼び出しの間だけ有効です。未定義挙動を防ぐために、あなたのコードがその関数呼び出しが終わった後に決してそのポインタに固執しないことを確実にしてください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">When implicitly converting an array to an unsafe pointer, Swift ensures that the array’s storage is contiguous by converting or copying the array as needed. For example, you can use this syntax with an array that was bridged to <code class="docutils literal notranslate"><span class="pre">Array</span></code> from an <code class="docutils literal notranslate"><span class="pre">NSArray</span></code> subclass that makes no API contract about its storage. If you need to guarantee that the array’s storage is already contiguous, so the implicit conversion never needs to do this work, use <code class="docutils literal notranslate"><span class="pre">ContiguousArray</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Array</span></code>.</span><!--end_enstr-->
<span class="jpstr">
配列からアンセーフポインタへの暗黙的変換の場合、スウィフトは、配列のもつストレージが隣接することを配列を必要に応じて変換または複製することによって確実にします。例えば、あなたはこの構文を<code class="docutils literal notranslate"><span class="pre">Array</span></code>から<code class="docutils literal notranslate"><span class="pre">NSArray</span></code>サブクラスへとブリッジされた配列でそれのストレージについてAPI協定をしないものに使用できます。配列のもつストレージが既に隣接する、そのため暗黙的変換はこの仕事をするために絶対に必要ないことをあなたが保証する必要があるならば、<code class="docutils literal notranslate"><span class="pre">ContiguousArray</span></code>を<code class="docutils literal notranslate"><span class="pre">Array</span></code>の代わりに使ってください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Using <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> instead of an explicit function like <code class="docutils literal notranslate"><span class="pre">withUnsafePointer(to:)</span></code> can help make calls to low-level C functions more readable, especially when the function takes several pointer arguments. However, when calling functions from other Swift code, avoid using <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> instead of using the unsafe APIs explicitly.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>を<code class="docutils literal notranslate"><span class="pre">withUnsafePointer(to:)</span></code>のような明示的な関数の代わりに使うことは、低レベルC関数への呼び出しをより読みやすくする助けとなりえます、とりわけ関数がいくつかのポインタ引数を取る場合には。しかしながら、他のスウィフトコードからの関数呼び出しの場合、<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>を明示的なアンセーフAPIの使用の代わりに使うことは避けてください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a function call expression</span><!--end_enstr-->
<span class="jpstr">
関数呼び出し式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-expression"></a>function-call-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-clause">function-call-argument-clause</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-expression_1098"></a>function-call-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-clause">function-call-argument-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_trailing-closures">trailing-closures</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument-clause"></a>function-call-argument-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument-list"></a>function-call-argument-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument">function-call-argument</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument">function-call-argument</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument"></a>function-call-argument</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-call-argument_1099"></a>function-call-argument</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_trailing-closures"></a>trailing-closures</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-expression">closure-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_labeled-trailing-closures">labeled-trailing-closures</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_labeled-trailing-closures"></a>labeled-trailing-closures</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_labeled-trailing-closure">labeled-trailing-closure</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_labeled-trailing-closures">labeled-trailing-closures</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_labeled-trailing-closure"></a>labeled-trailing-closure</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_closure-expression">closure-expression</a></span> </p>
</div>
</div>
</div>
</div>
<div class="section" id="ID399">
<h3><span class="enstr">Initializer Expression<a class="headerlink" href="#ID399" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザ式<a class="headerlink" href="#ID399" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>initializer expression</em> provides access to a type’s initializer. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、スーパークラスのイニシャライザに委任するために、<em>イニシャライザ式</em>を使います。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span>.<span class="nv">init</span>(<span class="gi">initializer arguments</span>)
</li></ol></div></div></div>
<p><span class="enstr">You use the initializer expression in a function call expression to initialize a new instance of a type. You also use an initializer expression to delegate to the initializer of a superclass.</span><!--end_enstr-->
<span class="jpstr">
あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeSubClass</span>: <span class="nc">SomeSuperClass</span> {
</li>
<li>    <span class="k">override</span> <span class="k">init</span>() {
</li>
<li>        <span class="c"><span class="enstr">// subclass initialization goes here</span><!--end_enstr--><span class="jpstr">（サブクラスの初期化が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>()
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Like a function, an initializer can be used as a value. For example:</span><!--end_enstr-->
<span class="jpstr">
関数のように、イニシャライザは値として使われることができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// Type annotation is required because String has multiple initializers.</span><!--end_enstr--><span class="jpstr">（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです。）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">initializer</span>: (<span class="nc">Int</span>) -&gt; <span class="nc">String</span> = <span class="nv">String</span>.<span class="nv">init</span>
</li>
<li>
<span class="k">let</span> <span class="nv">oneTwoThree</span> = [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>].<span class="nv">map</span>(<span class="nv">initializer</span>).<span class="nv">reduce</span>(<span class="s">""</span>, +)
</li>
<li>
<span class="nv">print</span>(<span class="nv">oneTwoThree</span>)
</li>
<li>
<span class="c">// Prints "123"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">If you specify a type by name, you can access the type’s initializer without using an initializer expression. In all other cases, you must use an initializer expression.</span><!--end_enstr-->
<span class="jpstr">
あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。すべての他の場合では、あなたはイニシャライザ式を使う必要があります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">s1</span> = <span class="nv">SomeType</span>.<span class="nv">init</span>(<span class="nv">data</span>: <span class="m">3</span>)  <span class="c">// Valid</span>
</li>
<li>
<span class="k">let</span> <span class="nv">s2</span> = <span class="nv">SomeType</span>(<span class="nv">data</span>: <span class="m">1</span>)       <span class="c">// Also valid</span>
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">s3</span> = <span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">someValue</span>).<span class="nv">init</span>(<span class="nv">data</span>: <span class="m">7</span>)  <span class="c">// Valid</span>
</li>
<li>
<span class="k">let</span> <span class="nv">s4</span> = <span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">someValue</span>)(<span class="nv">data</span>: <span class="m">5</span>)       <span class="c">// Error</span>
</li>
</ol></div></div></div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an initializer expression</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-expression"></a>initializer-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>init</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-expression_1100"></a>initializer-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>init</code> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span>  <code>)</code></p>
</div>
</div>
</div>
<div class="section" id="ID400">
<h3><span class="enstr">Explicit Member Expression<a class="headerlink" href="#ID400" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
明示的メンバー式<a class="headerlink" href="#ID400" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>explicit member expression</em> allows access to the members of a named type, a tuple, or a module. It consists of a period (<code class="docutils literal notranslate"><span class="pre">.</span></code>) between the item and the identifier of its member.</span><!--end_enstr-->
<span class="jpstr">
<em>明示的メンバー式</em>は、名前付き型、タプル、またはモジュールに属するそれらメンバーへのアクセスを可能にします。それは、その項目とそれのメンバーの識別子の間のピリオド（<code class="docutils literal notranslate"><span class="pre">.</span></code>）から成ります。
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span>.<span class="gi">member name</span>
</li></ol></div></div></div>
<p><span class="enstr">The members of a named type are named as part of the type’s declaration or extension. For example:</span><!--end_enstr-->
<span class="jpstr">
ある名前付きの型に属するメンバーそれらは、その型のもつ宣言や拡張の一部として指名されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">someProperty</span> = <span class="m">42</span>
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">c</span> = <span class="nv">SomeClass</span>()
</li>
<li>
<span class="k">let</span> <span class="nv">y</span> = <span class="nv">c</span>.<span class="nv">someProperty</span>  <span class="c">// Member access</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The members of a tuple are implicitly named using integers in the order they appear, starting from zero. For example:</span><!--end_enstr-->
<span class="jpstr">
タプルのメンバーそれらは、暗黙的に、整数を使って、それらが現れる順序で、ゼロから開始して、指名されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">t</span> = (<span class="m">10</span>, <span class="m">20</span>, <span class="m">30</span>)
</li>
<li>
<span class="nv">t</span>.<span class="m">0</span> = <span class="nv">t</span>.<span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// Now t is (20, 20, 30)</span><!--end_enstr--><span class="jpstr">（tは、現在 (20, 20, 30)です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The members of a module access the top-level declarations of that module.</span><!--end_enstr-->
<span class="jpstr">
モジュールのメンバーそれらは、そのモジュールのトップレベル宣言それらにアクセスします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Types declared with the <code class="docutils literal notranslate"><span class="pre">dynamicMemberLookup</span></code> attribute include members that are looked up at runtime, as described in <a class="reference internal" href="Attributes.html"><span class="doc">Attributes</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">dynamicMemberLookup</span></code>属性とともに宣言される型は、実行時に捜されるメンバーを含みます、<a class="reference internal" href="Attributes.html"><span class="doc">属性</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>). Write an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) for an argument with no name. To distinguish between overloaded methods, use a type annotation. For example:</span><!--end_enstr-->
<span class="jpstr">
それらの名前がそれらのもつ引数の名前によってのみ異なるメソッドやイニシャライザ間の区別をするには、丸括弧の中に引数名を、各引数名にコロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）を続けることで、含めて下さい。名前のない引数に対しては１つのアンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）を書いてください。オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">someMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) {}
</li>
<li>    <span class="k">func</span> <span class="nv">someMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">z</span>: <span class="nc">Int</span>) {}
</li>
<li>    <span class="k">func</span> <span class="nv">overloadedMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) {}
</li>
<li>    <span class="k">func</span> <span class="nv">overloadedMethod</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Bool</span>) {}
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">instance</span> = <span class="nv">SomeClass</span>()
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">a</span> = <span class="nv">instance</span>.<span class="nv">someMethod</span>              <span class="enstr"><span class="c">// Ambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">b</span> = <span class="nv">instance</span>.<span class="nv">someMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)        <span class="enstr"><span class="c">// Unambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（あいまいさ無し）</span></span><!--end_jpstr--></li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">d</span> = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>        <span class="enstr"><span class="c">// Ambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（あいまい）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">d</span> = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)  <span class="enstr"><span class="c">// Still ambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（依然あいまい）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">d</span>: (<span class="nc">Int</span>, <span class="nc">Bool</span>) -&gt; <span class="nc">Void</span>  = <span class="nv">instance</span>.<span class="nv">overloadedMethod</span>(<span class="nv">x</span>:<span class="nv">y</span>:)  <span class="enstr"><span class="c">// Unambiguous</span></span><!--end_enstr--><span class="jpstr"><span class="c">（あいまいさ無し）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">If a period appears at the beginning of a line, it’s understood as part of an explicit member expression, not as an implicit member expression. For example, the following listing shows chained method calls split over several lines:</span><!--end_enstr-->
<span class="jpstr">
ピリオドがある行の初めに現れたならば、それはある明示的メンバー式の一部分として理解されます、ある暗黙的メンバー式としてではなく。例えば、以下のコード出力は、いくつかの行に分かれた、連結されたメソッド呼び出しいくつかを示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">x</span> = [<span class="m">10</span>, <span class="m">3</span>, <span class="m">20</span>, <span class="m">15</span>, <span class="m">4</span>]
</li>
<li>    .<span class="nv">sorted</span>()
</li>
<li>    .<span class="nv">filter</span> { <span class="nv">$0</span> &gt; <span class="m">5</span> }
</li>
<li>    .<span class="nv">map</span> { <span class="nv">$0</span> * <span class="m">100</span> }
</li>
</ol></div></div></div>
<p><span class="enstr">You can combine this multiline chained syntax with compiler control statements to control when each method is called. For example, the following code uses a different filtering rule on iOS:</span><!--end_enstr-->
<span class="jpstr">
あなたは、この複数行連鎖構文をコンパイラ制御文いくらかと結合することで、いつ各メソッドが呼び出されるかを制御できます。例えば、以下のコードはiOS上では異なるフィルタ規則を使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">numbers</span> = [<span class="m">10</span>, <span class="m">20</span>, <span class="m">33</span>, <span class="m">43</span>, <span class="m">50</span>]
</li>
<li>
<span class="k">#if</span> <span class="nv">os</span>(<span class="nv">iOS</span>)
</li>
<li>.<span class="nv">filter</span> { <span class="nv">$0</span> &lt; <span class="m">40</span> }
</li>
<li>
<span class="k">#else</span>
</li>
<li>.<span class="nv">filter</span> { <span class="nv">$0</span> &gt; <span class="m">25</span> }
</li>
<li>
<span class="k">#endif</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Between <code class="docutils literal notranslate"><span class="pre">#if</span></code>, <code class="docutils literal notranslate"><span class="pre">#endif</span></code>, and other compilation directives, the conditional compilation block can contain an implicit member expression followed by zero or more postfixes, to form a postfix expression. It can also contain another conditional compilation block, or a combination of these expressions and blocks.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">#if</span></code>、<code class="docutils literal notranslate"><span class="pre">#endif</span></code>、そしてその他のコンパイル指令の間で、条件コンパイルブロックは、ある接尾辞式を形成するため、０個以上の接尾辞をその後に続ける、ある暗黙的メンバー式を含むことができます。それはまた、別の条件コンパイルブロックを、またはこれらの式とブロックからなるある組み合わせを含むことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use this syntax anywhere that you can write an explicit member expression, not just in top-level code.</span><!--end_enstr-->
<span class="jpstr">
あなたはこの構文を、あなたが明示的メンバー式を記述可能なあらゆるところに使用できます、単にトップレベルコードにだけでなく。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In the conditional compilation block, the branch for the <code class="docutils literal notranslate"><span class="pre">#if</span></code> compilation directive must contain at least one expression. The other branches can be empty.</span><!--end_enstr-->
<span class="jpstr">
条件コンパイルブロックにおいて、<code class="docutils literal notranslate"><span class="pre">#if</span></code>コンパイル指令に対する分岐は少なくとも１つの式を含まなければなりません。他の分岐は、空であることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an explicit member expression</span><!--end_enstr-->
<span class="jpstr">
明示的メンバー式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_decimal-digits">decimal-digits</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression_1101"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-argument-clause">generic-argument-clause</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression_1102"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span>  <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_explicit-member-expression_1103"></a>explicit-member-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_conditional-compilation-block">conditional-compilation-block</a></span> </p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_argument-names"></a>argument-names</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-name">argument-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_argument-names">argument-names</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_argument-name"></a>argument-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>:</code></p>
</div>
</div>
</div>
<div class="section" id="ID401">
<h3><span class="enstr">Postfix Self Expression<a class="headerlink" href="#ID401" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
接尾辞self式<a class="headerlink" href="#ID401" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A postfix <code class="docutils literal notranslate"><span class="pre">self</span></code> expression consists of an expression or the name of a type, immediately followed by <code class="docutils literal notranslate"><span class="pre">.self</span></code>. It has the following forms:</span><!--end_enstr-->
<span class="jpstr">
接尾辞<code class="docutils literal notranslate"><span class="pre">self</span></code>式は、ある式または型の名前と、それに直ちに続く<code class="docutils literal notranslate"><span class="pre">.self</span></code>から成ります。それは、以下の各形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="gi">expression</span>.<span class="k">self</span>
</li>
<li>
<span class="gi">type</span>.<span class="k">self</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The first form evaluates to the value of the <em>expression</em>. For example, <code class="docutils literal notranslate"><span class="pre">x.self</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">x</span></code>.</span><!--end_enstr-->
<span class="jpstr">
最初の形式は、<em>式</em>の値に評価されます。例えば、<code class="docutils literal notranslate"><span class="pre">x.self</span></code>は<code class="docutils literal notranslate"><span class="pre">x</span></code>に評価されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The second form evaluates to the value of the <em>type</em>. Use this form to access a type as a value. For example, because <code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code> evaluates to the <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> type itself, you can pass it to a function or method that accepts a type-level argument.</span><!--end_enstr-->
<span class="jpstr">
第二の形式は、<em>型</em>の値に評価されます。値として型にアクセスするために、この形式を使ってください。例えば、<code class="docutils literal notranslate"><span class="pre">SomeClass.self</span></code>は<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a postfix self expression</span><!--end_enstr-->
<span class="jpstr">
接尾辞self式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-self-expression"></a>postfix-self-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>.</code> <code>self</code></p></div>
</div>
</div>
<div class="section" id="ID403">
<h3><span class="enstr">Subscript Expression<a class="headerlink" href="#ID403" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
添え字式<a class="headerlink" href="#ID403" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>subscript expression</em> provides subscript access using the getter and setter of the corresponding subscript declaration. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>添え字式</em>は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span>[<span class="gi">index expressions</span>]
</li></ol></div></div></div>
<p><span class="enstr">To evaluate the value of a subscript expression, the subscript getter for the <em>expression</em>’s type is called with the <em>index expressions</em> passed as the subscript parameters. To set its value, the subscript setter is called in the same way.</span><!--end_enstr-->
<span class="jpstr">
添え字式の値を評価するために、この<em>式</em>のもつ型のための添え字ゲッターが、添え字パラメータとして渡される<em>インデックス式</em>を使って呼び出されます。その値を設定するために、添え字セッターが同様に呼ばれます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about subscript declarations, see <a class="reference internal" href="Declarations.html#ID373"><span class="std std-ref">Protocol Subscript Declaration</span></a>.</span><!--end_enstr-->
<span class="jpstr">
添え字宣言に関して詳しくは、<a class="reference internal" href="Declarations.html#ID373"><span class="std std-ref">プロトコル添え字宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a subscript expression</span><!--end_enstr-->
<span class="jpstr">
添え字式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-expression"></a>subscript-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_function-call-argument-list">function-call-argument-list</a></span>  <code>]</code></p></div>
</div>
</div>
<div class="section" id="ID404">
<h3><span class="enstr">Forced-Value Expression<a class="headerlink" href="#ID404" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
強制された値式<a class="headerlink" href="#ID404" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A <em>forced-value expression</em> unwraps an optional value that you are certain isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>強制された値式</em>は、あなたが<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないことを確信しているオプショナルの値をアンラップします。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span>!
</li></ol></div></div></div>
<p><span class="enstr">If the value of the <em>expression</em> isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the optional value is unwrapped and returned with the corresponding non-optional type. Otherwise, a runtime error is raised.</span><!--end_enstr-->
<span class="jpstr">
<em>式</em>の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば、オプショナルの値は包装を取られて（アンラップされて）、対応する非オプショナル型で返されます。そうでなければ、実行時エラーが引き起こされます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. For example:</span><!--end_enstr-->
<span class="jpstr">
強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">x</span>: <span class="nc">Int</span>? = <span class="m">0</span>
</li>
<li>
<span class="nv">x</span>! += <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// x is now 1</span><!--end_enstr--><span class="jpstr">（x は、現在 1 です）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li>
<span class="k">var</span> <span class="nv">someDictionary</span> = [<span class="s">"a"</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">"b"</span>: [<span class="m">10</span>, <span class="m">20</span>]]
</li>
<li>
<span class="nv">someDictionary</span>[<span class="s">"a"</span>]![<span class="m">0</span>] = <span class="m">100</span>
</li>
<li>
<span class="c"><span class="enstr">// someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]</span><!--end_enstr--><span class="jpstr">（someDictionary は、現在 ["a": [100, 2, 3], "b": [10, 20]] です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of a forced-value expression</span><!--end_enstr-->
<span class="jpstr">
強制された値の式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_forced-value-expression"></a>forced-value-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>!</code></p></div>
</div>
</div>
<div class="section" id="ID405">
<h3><span class="enstr">Optional-Chaining Expression<a class="headerlink" href="#ID405" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖式<a class="headerlink" href="#ID405" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">An <em>optional-chaining expression</em> provides a simplified syntax for using optional values in postfix expressions. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<em>オプショナル連鎖式</em>は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="gi">expression</span>?
</li></ol></div></div></div>
<p><span class="enstr">The postfix <code class="docutils literal notranslate"><span class="pre">?</span></code> operator makes an optional-chaining expression from an expression without changing the expression’s value.</span><!--end_enstr-->
<span class="jpstr">
接尾辞<code class="docutils literal notranslate"><span class="pre">?</span></code>演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way. If the value of the optional-chaining expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If the value of the optional-chaining expression isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression. In either case, the value of the postfix expression is still of an optional type.</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体は<code class="docutils literal notranslate"><span class="pre">nil</span></code>に評価されます。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type. In the example below, when <code class="docutils literal notranslate"><span class="pre">c</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>, its value is unwrapped and used to evaluate <code class="docutils literal notranslate"><span class="pre">.property</span></code>, the value of which is used to evaluate <code class="docutils literal notranslate"><span class="pre">.performAction()</span></code>. The entire expression <code class="docutils literal notranslate"><span class="pre">c?.property.performAction()</span></code> has a value of an optional type.</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。下記の例で、<code class="docutils literal notranslate"><span class="pre">c</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でないとき、その値はアンラップされて<code class="docutils literal notranslate"><span class="pre">.property</span></code>を評価するために使われ、その値が<code class="docutils literal notranslate"><span class="pre">.performAction()</span></code>を評価するために使われます。式<code class="docutils literal notranslate"><span class="pre">c?.property.performAction()</span></code>の全体がオプショナル型の値を持ちます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">c</span>: <span class="nc">SomeClass</span>?
</li>
<li>
<span class="k">var</span> <span class="nv">result</span>: <span class="nc">Bool</span>? = <span class="nv">c</span>?.<span class="nv">property</span>.<span class="nv">performAction</span>()
</li>
</ol></div></div></div>
<p><span class="enstr">The following example shows the behavior of the example above without using optional chaining.</span><!--end_enstr-->
<span class="jpstr">
以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">result</span>: <span class="nc">Bool</span>?
</li>
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">unwrappedC</span> = <span class="nv">c</span> {
</li>
<li>    <span class="nv">result</span> = <span class="nv">unwrappedC</span>.<span class="nv">property</span>.<span class="nv">performAction</span>()
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members. If the value of the optional-chaining expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the expression on the right-hand side of the assignment operator isn’t evaluated. For example:</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。オプショナル連鎖式の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、代入演算子の右手側での式は評価されません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">someFunctionWithSideEffects</span>() -&gt; <span class="nc">Int</span> {
</li>
<li>    <span class="k">return</span> <span class="m">42</span>  <span class="enstr"><span class="c">// No actual side effects.</span></span><!--end_enstr--><span class="jpstr"><span class="c">（実際の副作用なし）</span></span><!--end_jpstr--></li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">someDictionary</span> = [<span class="s">"a"</span>: [<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], <span class="s">"b"</span>: [<span class="m">10</span>, <span class="m">20</span>]]
</li>
<li>
</li>
<li>
<span class="nv">someDictionary</span>[<span class="s">"not here"</span>]?[<span class="m">0</span>] = <span class="nv">someFunctionWithSideEffects</span>()
</li>
<li>
<span class="c">// someFunctionWithSideEffects isn't evaluated</span>
</li>
<li>
<span class="c"><span class="enstr">// someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]</span><!--end_enstr--><span class="jpstr">（someDictionary は、まだ ["a": [1, 2, 3], "b": [10, 20]] です）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li>
<span class="nv">someDictionary</span>[<span class="s">"a"</span>]?[<span class="m">0</span>] = <span class="nv">someFunctionWithSideEffects</span>()
</li>
<li>
<span class="c"><span class="enstr">// someFunctionWithSideEffects is evaluated and returns 42</span><!--end_enstr--><span class="jpstr">（someFunctionWithSideEffectsは、評価されて42を返します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]</span><!--end_enstr--><span class="jpstr">（omeDictionary は、現在 ["a": [42, 2, 3], "b": [10, 20]] です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an optional-chaining expression</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖式の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_optional-chaining-expression"></a>optional-chaining-expression</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_postfix-expression">postfix-expression</a></span>  <code>?</code></p></div>
</div>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Types.html"><span class="enstr">Types</span><!--end_enstr-->
<span class="jpstr">
型
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Statements.html"><span class="enstr">Statements</span><!--end_enstr-->
<span class="jpstr">
文
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
