<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Attributes — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="AboutTheLanguageReference.html"><span class="enstr">About the Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="LexicalStructure.html"><span class="enstr">Lexical Structure</span><!--end_enstr-->
<span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html"><span class="enstr">Types</span><!--end_enstr-->
<span class="jpstr">
型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Expressions.html"><span class="enstr">Expressions</span><!--end_enstr-->
<span class="jpstr">
式
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Statements.html"><span class="enstr">Statements</span><!--end_enstr-->
<span class="jpstr">
文
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Declarations.html"><span class="enstr">Declarations</span><!--end_enstr-->
<span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Attributes</span><!--end_enstr-->
<span class="jpstr">
属性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Patterns.html"><span class="enstr">Patterns</span><!--end_enstr-->
<span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="GenericParametersAndArguments.html"><span class="enstr">Generic Parameters and Arguments</span><!--end_enstr-->
<span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="zzSummaryOfTheGrammar.html"><span class="enstr">Summary of the Grammar</span><!--end_enstr-->
<span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Attributes</span><!--end_enstr-->
<span class="jpstr">
属性
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID348"><span class="enstr">Declaration Attributes</span><!--end_enstr-->
<span class="jpstr">
宣言属性
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID583">available</a></li>
<li><a class="reference internal" href="#ID584">discardableResult</a></li>
<li><a class="reference internal" href="#ID603">dynamicCallable</a></li>
<li><a class="reference internal" href="#ID585">dynamicMemberLookup</a></li>
<li><a class="reference internal" href="#ID620">frozen</a></li>
<li><a class="reference internal" href="#ID586">GKInspectable</a></li>
<li><a class="reference internal" href="#ID587">inlinable</a></li>
<li><a class="reference internal" href="#ID626">main</a></li>
<li><a class="reference internal" href="#ID588">nonobjc</a></li>
<li><a class="reference internal" href="#ID589">NSApplicationMain</a></li>
<li><a class="reference internal" href="#ID590">NSCopying</a></li>
<li><a class="reference internal" href="#ID591">NSManaged</a></li>
<li><a class="reference internal" href="#ID592">objc</a></li>
<li><a class="reference internal" href="#ID593">objcMembers</a></li>
<li><a class="reference internal" href="#ID621">propertyWrapper</a></li>
<li>
<a class="reference internal" href="#ID633">resultBuilder</a><ul>
<li><a class="reference internal" href="#ID634">Result-Building Methods</a></li>
<li><a class="reference internal" href="#ID635">Result Transformations</a></li>
<li><a class="reference internal" href="#ID636">Custom Result-Builder Attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID594">requires_stored_property_inits</a></li>
<li><a class="reference internal" href="#ID595">testable</a></li>
<li><a class="reference internal" href="#ID596">UIApplicationMain</a></li>
<li><a class="reference internal" href="#ID597">usableFromInline</a></li>
<li><a class="reference internal" href="#ID598">warn_unqualified_access</a></li>
<li><a class="reference internal" href="#ID349"><span class="enstr">Declaration Attributes Used by Interface Builder</span><!--end_enstr-->
<span class="jpstr">
インターフェイスビルダーで使用される宣言属性
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID350"><span class="enstr">Type Attributes</span><!--end_enstr-->
<span class="jpstr">
型属性
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID599">autoclosure</a></li>
<li><a class="reference internal" href="#ID600">convention</a></li>
<li><a class="reference internal" href="#ID601">escaping</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID604"><span class="enstr">Switch Case Attributes</span><!--end_enstr-->
<span class="jpstr">
スイッチケース節属性
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID605">unknown</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="attributes">
<h1><span class="enstr">Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
属性<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types. An attribute provides additional information about the declaration or type. For example, the <code class="docutils literal notranslate"><span class="pre">discardableResult</span></code> attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.</span><!--end_enstr-->
<span class="jpstr">
スウィフトには２種類の属性があります — 宣言に適用されるもの、そして型に適用されるもの。属性は、宣言または型についての追加的な情報を提供します。例えば、ある関数宣言上での<code class="docutils literal notranslate"><span class="pre">discardableResult</span></code>属性が指し示すのは、たとえその関数が値を返すとしても、コンパイラは戻り値が使われなくても警告を生成すべきでないということです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You specify an attribute by writing the <code class="docutils literal notranslate"><span class="pre">@</span></code> symbol followed by the attribute’s name and any arguments that the attribute accepts:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">@</span></code>記号に続いてその属性の名前そしてその属性が受け入れる任意の引数を書くことによって属性を指定します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="gi">attribute name</span>
</li>
<li>@<span class="gi">attribute name</span>(<span class="gi">attribute arguments</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration. These <em>attribute arguments</em> are enclosed in parentheses, and their format is defined by the attribute they belong to.</span><!--end_enstr-->
<span class="jpstr">
若干の宣言属性は、属性に関するより多くの情報とそれが特定の宣言に適用される方法を指定する引数を受け入れます。これらの<em>属性引数</em>は丸括弧に囲まれます、そして、それらの形式はそれらが属している属性によって定義されます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID348">
<h2><span class="enstr">Declaration Attributes<a class="headerlink" href="#ID348" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
宣言属性<a class="headerlink" href="#ID348" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can apply a declaration attribute to declarations only.</span><!--end_enstr-->
<span class="jpstr">
あなたは、宣言属性を宣言だけに適用することができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID583">
<h3>available<a class="headerlink" href="#ID583" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to indicate a declaration’s life cycle relative to certain Swift language versions or certain platforms and operating system versions.</span><!--end_enstr-->
<span class="jpstr">
この属性を適用することで、ある宣言の寿命を、特定のスウィフト言語バージョンまたは特定のプラットホームおよびオペレーティングシステムバージョンに相関的に指し示してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute always appears with a list of two or more comma-separated attribute arguments. These arguments begin with one of the following platform or language names:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">available</span></code>属性は、常に２つ以上のコンマで区切られた属性引数とともに現れます。これらの引数は、以下のプラットホームまたは言語名の１つで始まります。
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">iOS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">iOSApplicationExtension</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">macOS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">macOSApplicationExtension</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">macCatalyst</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">macCatalystApplicationExtension</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">watchOS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">watchOSApplicationExtension</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">tvOS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">tvOSApplicationExtension</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">swift</span></code></li>
</ul>
<p><span class="enstr">You can also use an asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) to indicate the availability of the declaration on all of the platform names listed above. An <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute that specifies availability using a Swift version number can’t use the asterisk.</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、アスタリスク（<code class="docutils literal notranslate"><span class="pre">*</span></code>）を使って上でリストされるプラットホーム名の全てでその宣言の有効性を指し示すことができます。スウィフトバージョン数を使って有効性を指定する<code class="docutils literal notranslate"><span class="pre">available</span></code>属性は、アスタリスクを使用できません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The remaining arguments can appear in any order and specify additional information about the declaration’s life cycle, including important milestones.</span><!--end_enstr-->
<span class="jpstr">
残りの引数は、随意の順序で現れることができて、追加的な情報を宣言の寿命について、重要なマイルストーンを含めて指定します。
</span><!--end_jpstr-->
</p>
<ul>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> argument indicates that the declaration isn’t available on the specified platform. This argument can’t be used when specifying Swift version availability.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">unavailable</span></code>引数は、その宣言が指定されたプラットホーム上で利用可能でないことを指し示します。この引数は、スウィフトバージョン有効性を指定する時に使われることはできません。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">introduced</span></code> argument indicates the first version of the specified platform or language in which the declaration was introduced. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">introduced</span></code>引数は、そこにおいてその宣言が導入されたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">introduced</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p><span class="enstr">The <em>version number</em> consists of one to three positive integers, separated by periods.</span><!--end_enstr-->
<span class="jpstr">
<em>バージョン番号</em>は、ビリオドで区切られた、１つから３つの正の整数から成ります。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> argument indicates the first version of the specified platform or language in which the declaration was deprecated. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">deprecated</span></code>引数は、そこにおいてその宣言が非推奨とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">deprecated</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p><span class="enstr">The optional <em>version number</em> consists of one to three positive integers, separated by periods. Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred. If you omit the version number, omit the colon (<code class="docutils literal notranslate"><span class="pre">:</span></code>) as well.</span><!--end_enstr-->
<span class="jpstr">
随意の<em>バージョン番号</em>は、ビリオドで区切られた、１つから３つの正の整数から成ります。バージョン番号の省略は、宣言が現れた時についてのどんな情報も与えることなく、その宣言が現在は非推奨であることを示します。あなたがこのバージョン番号を省略したならば、コロン（<code class="docutils literal notranslate"><span class="pre">:</span></code>）も同様に省いてください。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">obsoleted</span></code> argument indicates the first version of the specified platform or language in which the declaration was obsoleted. When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">obsoleted</span></code>引数は、そこにおいてその宣言が廃止とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。ある宣言が廃止された場合は、それは指定されたプラットホームまたは言語から取り除かれます、そしてもはや使用されることはできません。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">obsoleted</span>: <span class="gi">version number</span>
</li></ol></div></div></div>
<p><span class="enstr">The <em>version number</em> consists of one to three positive integers, separated by periods.</span><!--end_enstr-->
<span class="jpstr">
<em>バージョン番号</em>は、ビリオドで区切られた、１つから３つの正の整数から成ります。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">message</span></code> argument provides a textual message that the compiler displays when emitting a warning or error about the use of a deprecated or obsoleted declaration. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">message</span></code>引数は、あるテキストメッセージを提供します、それはコンパイラが非推奨または廃止された宣言の使用についての警告またはエラーを発するときに表示するものです。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">message</span>: <span class="gi">message</span>
</li></ol></div></div></div>
<p><span class="enstr">The <em>message</em> consists of a string literal.</span><!--end_enstr-->
<span class="jpstr">
<em>message</em>は、文字列リテラルから成ります。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">renamed</span></code> argument provides a textual message that indicates the new name for a declaration that’s been renamed. The compiler displays the new name when emitting an error about the use of a renamed declaration. It has the following form:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">renamed</span></code>引数は、あるテキストメッセージを提供します、それは改名された宣言に対する新しい名前を指し示すものです。コンパイラは、ある改名された宣言の使用についてのエラーを発するときにその新しい名前を表示します。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">renamed</span>: <span class="gi">new name</span>
</li></ol></div></div></div>
<p><span class="enstr">The <em>new name</em> consists of a string literal.</span><!--end_enstr-->
<span class="jpstr">
<em>新しい名前</em>は文字列リテラルからなります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can apply the <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute with the <code class="docutils literal notranslate"><span class="pre">renamed</span></code> and <code class="docutils literal notranslate"><span class="pre">unavailable</span></code> arguments to a type alias declaration, as shown below, to indicate that the name of a declaration changed between releases of a framework or library. This combination results in a compile-time error that the declaration has been renamed.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">available</span></code>属性を<code class="docutils literal notranslate"><span class="pre">renamed</span></code>および<code class="docutils literal notranslate"><span class="pre">unavailable</span></code>属性とともに型エイリアス宣言に対して使うことで、下で示されるように、ある宣言の名前がフレームワークまたはライブラリのリリースの間に変わったことを指し示せます。この連携は、宣言が改名されてしまっているというコンパイル時エラーという結果になります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="c"><span class="enstr">// First release</span><!--end_enstr--><span class="jpstr">（最初のリリース）</span><!--end_jpstr--></span>
</li>
<li><span class="k">protocol</span> <span class="nv">MyProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// protocol definition</span><!--end_enstr--><span class="jpstr">（プロトコル定義）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="c"><span class="enstr">// Subsequent release renames MyProtocol</span><!--end_enstr--><span class="jpstr">（続くリリースでMyProtocolに改名する）</span><!--end_jpstr--></span>
</li>
<li><span class="k">protocol</span> <span class="nv">MyRenamedProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// protocol definition</span><!--end_enstr--><span class="jpstr">（プロトコル定義）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">@available</span>(*, <span class="nv">unavailable</span>, <span class="nv">renamed</span>: <span class="s">"MyRenamedProtocol"</span>)
</li>
<li><span class="k">typealias</span> <span class="nv">MyProtocol</span> = <span class="nc">MyRenamedProtocol</span>
</li>
</ol></div></div></div>
</li>
</ul>
<p><span class="enstr">You can apply multiple <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes on a single declaration to specify the declaration’s availability on different platforms and different versions of Swift. The declaration that the <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute applies to is ignored if the attribute specifies a platform or language version that doesn’t match the current target. If you use multiple <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes, the effective availability is the combination of the platform and Swift availabilities.</span><!--end_enstr-->
<span class="jpstr">
あなたは、複数の<code class="docutils literal notranslate"><span class="pre">available</span></code>属性を単一の宣言上に適用することで、その宣言の有効性を異なるプラットホームおよび異なるバージョンのスウィフトに関して指定することができます。<code class="docutils literal notranslate"><span class="pre">available</span></code>属性を適用される宣言は、その属性が現在の対象と合致しないプラットホームまたは言語バージョンを指定するならば無視されます。あなたが複数の<code class="docutils literal notranslate"><span class="pre">available</span></code>属性を使うならば、有効な有効性はプラットホームとスウィフト有効性の組み合わせとなります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If an <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute only specifies an <code class="docutils literal notranslate"><span class="pre">introduced</span></code> argument in addition to a platform or language name argument, you can use the following shorthand syntax instead:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">available</span></code>属性がただ１つの<code class="docutils literal notranslate"><span class="pre">introduced</span></code>引数をプラットホームまたは言語名引数に加えて指定するならば、あなたは以下の略記構文が代わりに利用可能です：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@available</span>(<span class="gi">platform name</span> <span class="gi">version number</span>, *)
</li>
<li><span class="k">@available</span>(<span class="nv">swift</span> <span class="gi">version number</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The shorthand syntax for <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes concisely expresses availability for multiple platforms. Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">available</span></code>属性のための略記構文は、複数のプラットホームに対する有効性を簡潔に表します。２つの書式は機能的に等しいですが、可能であればいつでも略記書式が好ましいです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@available</span>(<span class="k">iOS</span> <span class="m">10.0</span>, <span class="k">macOS</span> <span class="m">10.12</span>, *)
</li>
<li><span class="k">class</span> <span class="nv">MyClass</span> {
</li>
<li>    <span class="c">// class definition</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">An <code class="docutils literal notranslate"><span class="pre">available</span></code> attribute that specifies availability using a Swift version number can’t additionally specify a declaration’s platform availability. Instead, use separate <code class="docutils literal notranslate"><span class="pre">available</span></code> attributes to specify a Swift version availability and one or more platform availabilities.</span><!--end_enstr-->
<span class="jpstr">
スウィフトバージョン数を使って有効性を指定している<code class="docutils literal notranslate"><span class="pre">available</span></code>属性は、ある宣言の持つプラットホーム有効性を追加的に指定することはできません。代わりに、<code class="docutils literal notranslate"><span class="pre">available</span></code>属性を使うことで、スウィフトバージョン有効性と１つ以上のプラットホーム有効性を指定してください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@available</span>(<span class="nv">swift</span> <span class="m">3.0</span>.<span class="m">2</span>)
</li>
<li><span class="k">@available</span>(<span class="k">macOS</span> <span class="m">10.12</span>, *)
</li>
<li><span class="k">struct</span> <span class="nv">MyStruct</span> {
</li>
<li>    <span class="c">// struct definition</span>
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID584">
<h3>discardableResult<a class="headerlink" href="#ID584" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</span><!--end_enstr-->
<span class="jpstr">
この属性を関数またはメソッド宣言に適用して、値を返す関数やメソッドがそれの結果を使うことなく呼び出された時にコンパイラが警告を発するのを抑制してください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID603">
<h3>dynamicCallable<a class="headerlink" href="#ID603" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class, structure, enumeration, or protocol to treat instances of the type as callable functions. The type must implement either a <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> method, a <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method, or both.</span><!--end_enstr-->
<span class="jpstr">
この属性をクラス、構造体、列挙、またはプロトコルに適用することで、その型のインスタンスをcallable関数として扱ってください。その型は、<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code>、<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code>メソッドのどちらか、または両方を実装しなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can call an instance of a dynamically callable type as if it’s a function that takes any number of arguments.</span><!--end_enstr-->
<span class="jpstr">
あなたは動的callable型のインスタンスを、まるでそれがいくらかの数の引数を取る関数であるかのように呼び出せます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@dynamicCallable</span>
</li>
<li><span class="k">struct</span> <span class="nv">TelephoneExchange</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">dynamicallyCall</span>(<span class="nv">withArguments</span> <span class="nv">phoneNumber</span>: [<span class="nc">Int</span>]) {
</li>
<li>        <span class="k">if</span> <span class="nv">phoneNumber</span> == [<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>] {
</li>
<li>            <span class="nv">print</span>(<span class="s">"Get Swift help on forums.swift.org"</span>)
</li>
<li>        } <span class="k">else</span> {
</li>
<li>            <span class="nv">print</span>(<span class="s">"Unrecognized number"</span>)
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">dial</span> = <span class="nv">TelephoneExchange</span>()
</li>
<li>
</li>
<li><span class="c"><span class="enstr">// Use a dynamic method call.</span><!--end_enstr--><span class="jpstr">（動的メソッド呼び出しを使います。）</span><!--end_jpstr--></span>
</li>
<li><span class="nv">dial</span>(<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>)
</li>
<li><span class="c">// Prints "Get Swift help on forums.swift.org"</span>
</li>
<li>
</li>
<li><span class="nv">dial</span>(<span class="m">8</span>, <span class="m">6</span>, <span class="m">7</span>, <span class="m">5</span>, <span class="m">3</span>, <span class="m">0</span>, <span class="m">9</span>)
</li>
<li><span class="c">// Prints "Unrecognized number"</span>
</li>
<li>
</li>
<li><span class="c"><span class="enstr">// Call the underlying method directly.</span><!--end_enstr--><span class="jpstr">（基礎をなすメソッドを直接に呼び出します。）</span><!--end_jpstr--></span>
</li>
<li><span class="nv">dial</span>.<span class="nv">dynamicallyCall</span>(<span class="nv">withArguments</span>: [<span class="m">4</span>, <span class="m">1</span>, <span class="m">1</span>])
</li>
</ol></div></div></div>
<p><span class="enstr">The declaration of the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> method must have a single parameter that conforms to the <a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebyarrayliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByArrayLiteral</span></code></a> protocol—like <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> in the example above. The return type can be any type.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code>メソッドの宣言は、<a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebyarrayliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByArrayLiteral</span></code></a>プロトコルに準拠する単一のパラメータを持たなければいけません — 上の例の<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>のように。戻りの型は任意の型であることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can include labels in a dynamic method call if you implement the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method.</span><!--end_enstr-->
<span class="jpstr">
あなたは、いくつかのラベルを動的メソッド呼び出しに含めることができます、もしあなたが<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code>メソッドを実装するならば。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@dynamicCallable</span>
</li>
<li><span class="k">struct</span> <span class="nv">Repeater</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">dynamicallyCall</span>(<span class="nv">withKeywordArguments</span> <span class="nv">pairs</span>: <span class="nc">KeyValuePairs</span>&lt;<span class="nc">String</span>, <span class="nc">Int</span>&gt;) -&gt; <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">pairs</span>
</li>
<li>            .<span class="nv">map</span> { <span class="nv">label</span>, <span class="nv">count</span> <span class="k">in</span>
</li>
<li>                <span class="nv">repeatElement</span>(<span class="nv">label</span>, <span class="nv">count</span>: <span class="nv">count</span>).<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">" "</span>)
</li>
<li>            }
</li>
<li>            .<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">repeatLabels</span> = <span class="nv">Repeater</span>()
</li>
<li><span class="nv">print</span>(<span class="nv">repeatLabels</span>(<span class="nv">a</span>: <span class="m">1</span>, <span class="nv">b</span>: <span class="m">2</span>, <span class="nv">c</span>: <span class="m">3</span>, <span class="nv">b</span>: <span class="m">2</span>, <span class="nv">a</span>: <span class="m">1</span>))
</li>
<li><span class="c">// a</span>
</li>
<li><span class="c">// b b</span>
</li>
<li><span class="c">// c c c</span>
</li>
<li><span class="c">// b b</span>
</li>
<li><span class="c">// a</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The declaration of the <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> method must have a single parameter that conforms to the <a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebydictionaryliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByDictionaryLiteral</span></code></a> protocol, and the return type can be any type. The parameter’s <a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key.html"><code class="docutils literal notranslate"><span class="pre">Key</span></code></a> must be <a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebystringliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a>. The previous example uses <a class="reference external" href="../../../developer.apple.com/documentation/swift/keyvaluepairs.html"><code class="docutils literal notranslate"><span class="pre">KeyValuePairs</span></code></a> as the parameter type so that callers can include duplicate parameter labels—<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> appear multiple times in the call to <code class="docutils literal notranslate"><span class="pre">repeat</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code>メソッドの宣言は、ある単一のパラメータを持たなければなりません、それは<a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebydictionaryliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByDictionaryLiteral</span></code></a>プロトコルに準拠するものです、そして戻り型はどんな型でも構いません。パラメータの<a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key.html"><code class="docutils literal notranslate"><span class="pre">Key</span></code></a>は、<a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebystringliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a>でなければなりません。前の例は、<a class="reference external" href="../../../developer.apple.com/documentation/swift/keyvaluepairs.html"><code class="docutils literal notranslate"><span class="pre">KeyValuePairs</span></code></a>をパラメータ型として使います、それで呼び出し側は重複するパラメータラベルを含むことができます — <code class="docutils literal notranslate"><span class="pre">a</span></code>と<code class="docutils literal notranslate"><span class="pre">b</span></code>は複数回<code class="docutils literal notranslate"><span class="pre">repeat</span></code>の呼び出しにおいて現れます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you implement both <code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code> methods, <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code> is called when the method call includes keyword arguments. In all other cases, <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> is called.</span><!--end_enstr-->
<span class="jpstr">
あなたが両方の<code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code>メソッドを実装するならば、<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withKeywordArguments:)</span></code>が呼び出されるのは、メソッド呼び出しがキーワード引数を含む時です。全ての他の場合には、<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code>が呼び出されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can only call a dynamically callable instance with arguments and a return value that match the types you specify in one of your <code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code> method implementations. The call in the following example doesn’t compile because there isn’t an implementation of <code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code> that takes <code class="docutils literal notranslate"><span class="pre">KeyValuePairs&lt;String,</span> <span class="pre">String&gt;</span></code>.</span><!--end_enstr-->
<span class="jpstr">
あなたは動的callableインスタンスを、あなたの<code class="docutils literal notranslate"><span class="pre">dynamicallyCall</span></code>メソッド実装の１つにおいてあなたが指定する型に合致する引数いくつかと戻り値ひとつで呼び出せるだけです。以下の例における呼び出しはコンパイルしません、なぜなら<code class="docutils literal notranslate"><span class="pre">dynamicallyCall(withArguments:)</span></code>の実装で<code class="docutils literal notranslate"><span class="pre">KeyValuePairs&lt;String,</span> <span class="pre">String&gt;</span></code>をとるものがないからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">repeatLabels</span>(<span class="nv">a</span>: <span class="s">"four"</span>) <span class="c">// Error</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID585">
<h3>dynamicMemberLookup<a class="headerlink" href="#ID585" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class, structure, enumeration, or protocol to enable members to be looked up by name at runtime. The type must implement a <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> subscript.</span><!--end_enstr-->
<span class="jpstr">
この属性をクラス、構造体、列挙、またはプロトコルに適用して、メンバーが実行時に名前で検索されることを可能にしてください。この型は、<code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code>添え字を実装しなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In an explicit member expression, if there isn’t a corresponding declaration for the named member, the expression is understood as a call to the type’s <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> subscript, passing information about the member as the argument. The subscript can accept a parameter that’s either a key path or a member name; if you implement both subscripts, the subscript that takes key path argument is used.</span><!--end_enstr-->
<span class="jpstr">
明示的メンバー式において、名前付きメンバーに対して対応する宣言がないならば、式は型の持つ<code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code>添え字に対する呼び出しとして理解されます、メンバーについての情報を引数として渡します。添え字は、あるパラメータを受け入れます、それはキーパスまたはメンバー名のどちらかです；あなたが両方の添え字を実装するならば、キーパス引数をとる添え字が使われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An implementation of <code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code> can accept key paths using an argument of type <a class="reference external" href="../../../developer.apple.com/documentation/swift/keypath.html"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a>, <a class="reference external" href="../../../developer.apple.com/documentation/swift/writablekeypath.html"><code class="docutils literal notranslate"><span class="pre">WritableKeyPath</span></code></a>, or <a class="reference external" href="../../../developer.apple.com/documentation/swift/referencewritablekeypath.html"><code class="docutils literal notranslate"><span class="pre">ReferenceWritableKeyPath</span></code></a>. It can accept member names using an argument of a type that conforms to the <a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebystringliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a> protocol—in most cases, <code class="docutils literal notranslate"><span class="pre">String</span></code>. The subscript’s return type can be any type.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">subscript(dynamicMember:)</span></code>の実装はキーパスを、型<a class="reference external" href="../../../developer.apple.com/documentation/swift/keypath.html"><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code></a>、<a class="reference external" href="../../../developer.apple.com/documentation/swift/writablekeypath.html"><code class="docutils literal notranslate"><span class="pre">WritableKeyPath</span></code></a>、または<a class="reference external" href="../../../developer.apple.com/documentation/swift/referencewritablekeypath.html"><code class="docutils literal notranslate"><span class="pre">ReferenceWritableKeyPath</span></code></a>の引数を使って受け入れ可能です。それはメンバー名を、<a class="reference external" href="../../../developer.apple.com/documentation/swift/expressiblebystringliteral.html"><code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code></a>プロトコルに準拠する型 — ほとんどの場合、<code class="docutils literal notranslate"><span class="pre">String</span></code> — の引数を使って受け入れ可能です。添え字のもつ戻り型は、どんな型でも可能です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Dynamic member lookup by member name can be used to create a wrapper type around data that can’t be type checked at compile time, such as when bridging data from other languages into Swift. For example:</span><!--end_enstr-->
<span class="jpstr">
メンバー名による動的メンバー検索は、コンパイル時に型検査されることができないデータを取り囲むラッパー型を作成するために使用できます、たとえば他の言語からスウィフトへとブリッジしている時など。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@dynamicMemberLookup</span>
</li>
<li><span class="k">struct</span> <span class="nv">DynamicStruct</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">dictionary</span> = [<span class="s">"someDynamicMember"</span>: <span class="m">325</span>,
</li>
<li>                      <span class="s">"someOtherMember"</span>: <span class="m">787</span>]
</li>
<li>    <span class="k">subscript</span>(<span class="nv">dynamicMember</span> <span class="nv">member</span>: <span class="nc">String</span>) -&gt; <span class="nc">Int</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">dictionary</span>[<span class="nv">member</span>] ?? <span class="m">1054</span>
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">s</span> = <span class="nv">DynamicStruct</span>()
</li>
<li>
</li>
<li><span class="c"><span class="enstr">// Use dynamic member lookup.</span><!--end_enstr--><span class="jpstr">（動的メンバー検索を使います。）</span><!--end_jpstr--></span>
</li>
<li><span class="k">let</span> <span class="nv">dynamic</span> = <span class="nv">s</span>.<span class="nv">someDynamicMember</span>
</li>
<li><span class="nv">print</span>(<span class="nv">dynamic</span>)
</li>
<li><span class="c"><span class="enstr">// Prints "325"</span><!--end_enstr--><span class="jpstr">（ "325" を出力する）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="c"><span class="enstr">// Call the underlying subscript directly.</span><!--end_enstr--><span class="jpstr">（基礎をなす添え字を直接に呼び出す。）</span><!--end_jpstr--></span>
</li>
<li><span class="k">let</span> <span class="nv">equivalent</span> = <span class="nv">s</span>[<span class="nv">dynamicMember</span>: <span class="s">"someDynamicMember"</span>]
</li>
<li><span class="nv">print</span>(<span class="nv">dynamic</span> == <span class="nv">equivalent</span>)
</li>
<li><span class="c"><span class="enstr">// Prints "true"</span><!--end_enstr--><span class="jpstr">（「true」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Dynamic member lookup by key path can be used to implement a wrapper type in a way that supports compile-time type checking. For example:</span><!--end_enstr-->
<span class="jpstr">
キーパスによる動的メンバー検索は、ラッパー型を、コンバイル時型検査をサポートするある方法で実装するために使用できます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Point</span> { <span class="k">var</span> <span class="nv">x</span>, <span class="nv">y</span>: <span class="nc">Int</span> }
</li>
<li>
</li>
<li><span class="k">@dynamicMemberLookup</span>
</li>
<li><span class="k">struct</span> <span class="nv">PassthroughWrapper</span>&lt;<span class="nv">Value</span>&gt; {
</li>
<li>    <span class="k">var</span> <span class="nv">value</span>: <span class="nc">Value</span>
</li>
<li>    <span class="k">subscript</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">dynamicMember</span> <span class="nv">member</span>: <span class="nc">KeyPath</span>&lt;<span class="nc">Value</span>, <span class="nc">T</span>&gt;) -&gt; <span class="nc">T</span> {
</li>
<li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">value</span>[<span class="nv">keyPath</span>: <span class="nv">member</span>] }
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">point</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">381</span>, <span class="nv">y</span>: <span class="m">431</span>)
</li>
<li><span class="k">let</span> <span class="nv">wrapper</span> = <span class="nv">PassthroughWrapper</span>(<span class="nv">value</span>: <span class="nv">point</span>)
</li>
<li><span class="nv">print</span>(<span class="nv">wrapper</span>.<span class="nv">x</span>)
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID620">
<h3>frozen<a class="headerlink" href="#ID620" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a structure or enumeration declaration to restrict the kinds of changes you can make to the type. This attribute is allowed only when compiling in library evolution mode. Future versions of the library can’t change the declaration by adding, removing, or reordering an enumeration’s cases or a structure’s stored instance properties. These changes are allowed on nonfrozen types, but they break ABI compatibility for frozen types.</span><!--end_enstr-->
<span class="jpstr">
この属性を構造体または列挙宣言に適用して、あなたがその型にすることが出来る変更の種類を制約してください。この属性は、ライブラリ進化モードでコンパイルしている場合にのみ許可されます。ライブラリの将来のバージョンは、追加、削除、または列挙のもつケース節や構造体のもつ格納インスタンスプロパティの再配列によって宣言を変更できません。これらの変更は、非凍結型の上では許可されます、しかしそれらは凍結型に対するABI互換性を破壊します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">When the compiler isn’t in library evolution mode, all structures and enumerations are implicitly frozen, and this attribute is ignored.</span><!--end_enstr-->
<span class="jpstr">
コンパイラがライブラリ進化モードではない場合、全ての構造体と列挙は暗黙的に凍結されます、そしてこの属性は無視されます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">In library evolution mode, code that interacts with members of nonfrozen structures and enumerations is compiled in a way that allows it to continue working without recompiling even if a future version of the library adds, removes, or reorders some of that type’s members. The compiler makes this possible using techniques like looking up information at runtime and adding a layer of indirection. Marking a structure or enumeration as frozen gives up this flexibility to gain performance: Future versions of the library can make only limited changes to the type, but the compiler can make additional optimizations in code that interacts with the type’s members.</span><!--end_enstr-->
<span class="jpstr">
ライブラリ進化モードでは、非凍結の構造体および列挙のメンバーと相互作用するコードは、ある方法でコンパイルされます、それは、再コンパイルすることなしにそれに仕事を継続させます、たとえ将来のバージョンのライブラリが追加する、削除する、またはその型のもつメンバーのいくつかを再配置するとしてもです。コンパイラは、これを、実行時に情報を検索することそして間接参照のレイヤーを加えることのような技術いくつかを使って可能にします。構造体または列挙を凍結されると印することは、この柔軟性を諦めることで性能を手に入れます：ライブラリの将来のバージョンは、制限された変更だけしか型に対して出来ません、しかしコンパイラは追加的な最適化を、型のもつメンバーと相互作用するコードにすることが出来ます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Frozen types, the types of the stored properties of frozen structures, and the associated values of frozen enumeration cases must be public or marked with the <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> attribute. The properties of a frozen structure can’t have property observers, and expressions that provide the initial value for stored instance properties must follow the same restrictions as inlinable functions, as discussed in <a class="reference internal" href="#ID587"><span class="std std-ref">inlinable</span></a>.</span><!--end_enstr-->
<span class="jpstr">
凍結型、凍結構造体の格納プロパティの型、そして凍結列挙ケース節の関連値は、パブリックであるか<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>属性で印されなければなりません。凍結構造体のプロパティは、ブロパティオブザーバを持つことが出来ません、そして格納インスタンスプロパティに初期値を提供する式は、インライン可能関数と同じ制約に従わなければなりません、<a class="reference internal" href="#ID587"><span class="std std-ref">inlinable</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To enable library evolution mode on the command line, pass the <code class="docutils literal notranslate"><span class="pre">-enable-library-evolution</span></code> option to the Swift compiler. To enable it in Xcode, set the “Build Libraries for Distribution” build setting (<code class="docutils literal notranslate"><span class="pre">BUILD_LIBRARY_FOR_DISTRIBUTION</span></code>) to Yes, as described in <a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev04b3a04ba">Xcode Help</a>.</span><!--end_enstr-->
<span class="jpstr">
ライブラリ進化モードをコマンドライン上で可能にするには、<code class="docutils literal notranslate"><span class="pre">-enable-library-evolution</span></code>オプションをスウィフトコンパイラに渡してください。それをXcodeで可能にするには、“Build Libraries for Distribution” ビルド設定（<code class="docutils literal notranslate"><span class="pre">BUILD_LIBRARY_FOR_DISTRIBUTION</span></code>）を Yes に設定してください、<a class="reference external" href="https://help.apple.com/xcode/mac/current/#/dev04b3a04ba">Xcode Help</a>で記述されるとおりに。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A switch statement over a frozen enumeration doesn’t require a <code class="docutils literal notranslate"><span class="pre">default</span></code> case, as discussed in <a class="reference internal" href="Statements.html#ID602"><span class="std std-ref">Switching Over Future Enumeration Cases</span></a>. Including a <code class="docutils literal notranslate"><span class="pre">default</span></code> or <code class="docutils literal notranslate"><span class="pre">@unknown</span> <span class="pre">default</span></code> case when switching over a frozen enumeration produces a warning because that code is never executed.</span><!--end_enstr-->
<span class="jpstr">
凍結列挙に対するスイッチ文は、<code class="docutils literal notranslate"><span class="pre">default</span></code>ケース節を必要しません、<a class="reference internal" href="Statements.html#ID602"><span class="std std-ref">未来列挙ケース節に対してスイッチする</span></a>で議論されるように。<code class="docutils literal notranslate"><span class="pre">default</span></code>または<code class="docutils literal notranslate"><span class="pre">@unknown</span> <span class="pre">default</span></code>ケース節を、凍結列挙に対してスイッチしている時に含めることは、警告を生成します、なぜならそのコードは決して遂行されないからです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID586">
<h3>GKInspectable<a class="headerlink" href="#ID586" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI. Applying this attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
この属性を適用することであつらえのGameplayKitコンポーネントプロパティをSpriteKitエディタUIに露出してください。この属性を適用することはまた、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性も暗に意味します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID587">
<h3>inlinable<a class="headerlink" href="#ID587" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a function, method, computed property, subscript, convenience initializer, or deinitializer declaration to expose that declaration’s implementation as part of the module’s public interface. The compiler is allowed to replace calls to an inlinable symbol with a copy of the symbol’s implementation at the call site.</span><!--end_enstr-->
<span class="jpstr">
この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、宣言の実装をモジュールの公開インターフェイスの一部として露出してください。コンパイラは、インライン可能シンボルへの呼び出しを、呼び出し場所でのそのシンボルの持つ実装のコピーで置き換えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Inlinable code can interact with <code class="docutils literal notranslate"><span class="pre">public</span></code> symbols declared in any module, and it can interact with <code class="docutils literal notranslate"><span class="pre">internal</span></code> symbols declared in the same module that are marked with the <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> attribute. Inlinable code can’t interact with <code class="docutils literal notranslate"><span class="pre">private</span></code> or <code class="docutils literal notranslate"><span class="pre">fileprivate</span></code> symbols.</span><!--end_enstr-->
<span class="jpstr">
インライン可能コードは、何らかのモジュールにおいて宣言される<code class="docutils literal notranslate"><span class="pre">public</span></code>シンボルと相互作用できます、そしてそれは同じモジュールにおいて宣言される<code class="docutils literal notranslate"><span class="pre">internal</span></code>シンボルで、<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>属性で印されるものと相互作用できます。インライン可能コードは、<code class="docutils literal notranslate"><span class="pre">private</span></code>または<code class="docutils literal notranslate"><span class="pre">fileprivate</span></code>シンボルと相互作用できません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This attribute can’t be applied to declarations that are nested inside functions or to <code class="docutils literal notranslate"><span class="pre">fileprivate</span></code> or <code class="docutils literal notranslate"><span class="pre">private</span></code> declarations. Functions and closures that are defined inside an inlinable function are implicitly inlinable, even though they can’t be marked with this attribute.</span><!--end_enstr-->
<span class="jpstr">
この属性は、関数の内部に入れ子にされる宣言に、または<code class="docutils literal notranslate"><span class="pre">fileprivate</span></code>や<code class="docutils literal notranslate"><span class="pre">private</span></code>宣言に適用できません。インライン可能関数内部で定義される関数とクロージャは、暗黙的にインライン可能です。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID626">
<h3>main<a class="headerlink" href="#ID626" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a structure, class, or enumeration declaration to indicate that it contains the top-level entry point for program flow. The type must provide a <code class="docutils literal notranslate"><span class="pre">main</span></code> type function that doesn’t take any arguments and returns <code class="docutils literal notranslate"><span class="pre">Void</span></code>. For example:</span><!--end_enstr-->
<span class="jpstr">
この属性を構造体、クラス、または列挙宣言に適用して、それがプログラム流れに対するトップレベルエントリポイントを含むことを指し示してください。型は、ある<code class="docutils literal notranslate"><span class="pre">main</span></code>型関数を提供しなければなりません、それはどんな引数もとりません、そして<code class="docutils literal notranslate"><span class="pre">Void</span></code>を返します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">main</span>
</li>
<li><span class="k">struct</span> <span class="nv">MyTopLevel</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">main</span>() {
</li>
<li>        <span class="c">// Top-level code goes here</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Another way to describe the requirements of the <code class="docutils literal notranslate"><span class="pre">main</span></code> attribute is that the type you write this attribute on must satisfy the same requirements as types that conform to the following hypothetical protocol:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">main</span></code>属性の要件を記述する別の方法は、あなたがそれの上でこの属性を書くところの型は以下の仮定的なプロトコルに準拠する型と同じ要件を満たさなければならない、ということになります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">protocol</span> <span class="nv">ProvidesMain</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">main</span>() <span class="k">throws</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">Top-Level Code</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがコンパイルして実行可能にするSwiftコードは、最大で１つのトップレベルエントリポイントを持つことができます、<a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">トップレベル・コード</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID588">
<h3>nonobjc<a class="headerlink" href="#ID588" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. The <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</span><!--end_enstr-->
<span class="jpstr">
この属性をメソッド、プロパティ、添え字、およびイニシャライザ宣言に適用することで、暗黙的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性となるのを抑制してください。<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性は、コンパイラにその宣言がObjective-Cコードにおいて利用不可にされることを伝えます、たとえそれがObjective-Cにおいて表現可能であってもです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
この属性をある拡張に適用することは、明示的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されていないその拡張のあらゆるメンバーにそれを適用することと同じ効果を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You use the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute to resolve circularity for bridging methods in a class marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute, and to allow overloading of methods and initializers in a class marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるクラスの中のブリッジしているメソッドに対する循環性を解決するために、そして<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるクラスにおいてメソッドとイニシャライザをオーバーロードすることを許可するために<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性を使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute can’t override a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. However, a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can override a method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute. Similarly, a method marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute can’t satisfy a protocol requirement for a method marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性で印されるメソッドは、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるメソッドをオーバーライドできません。しかしながら、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるメソッドは<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性で印されるメソッドをオーバーライドすることができます。同様に、<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性で印されるメソッドは、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるメソッドに対するプロトコル要件を満たすことは出来ません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID589">
<h3>NSApplicationMain<a class="headerlink" href="#ID589" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class to indicate that it’s the application delegate. Using this attribute is equivalent to calling the <code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code> function.</span><!--end_enstr-->
<span class="jpstr">
この属性をあるクラスに適用することで、それがアプリケーション委任先であることを指し示してください。この属性を使用することは、<code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code>関数を呼ぶことに相当します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you don’t use this attribute, supply a <code class="docutils literal notranslate"><span class="pre">main.swift</span></code> file with code at the top level that calls the <code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code> function as follows:</span><!--end_enstr-->
<span class="jpstr">
あなたがこの属性を使わないならば、<code class="docutils literal notranslate"><span class="pre">NSApplicationMain(_:_:)</span></code>関数を呼ぶトップレベルコードを持つ<code class="docutils literal notranslate"><span class="pre">main.swift</span></code>ファイルを以下のように提供してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">import</span> <span class="nv">AppKit</span>
</li>
<li><span class="nv">NSApplicationMain</span>(<span class="nv">CommandLine</span>.<span class="nv">argc</span>, <span class="nv">CommandLine</span>.<span class="nv">unsafeArgv</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">Top-Level Code</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがコンパイルして実行可能にするSwiftコードは、最大で１つのトップレベルエントリポイントを持つことができます、<a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">トップレベル・コード</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID590">
<h3>NSCopying<a class="headerlink" href="#ID590" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a stored variable property of a class. This attribute causes the property’s setter to be synthesized with a <em>copy</em> of the property’s value—returned by the <code class="docutils literal notranslate"><span class="pre">copyWithZone(_:)</span></code> method—instead of the value of the property itself. The type of the property must conform to the <code class="docutils literal notranslate"><span class="pre">NSCopying</span></code> protocol.</span><!--end_enstr-->
<span class="jpstr">
この属性をクラスの格納変数プロパティに適用してください。この属性は、プロパティのセッターがそのプロパティの値の<em>コピー</em> ― <code class="docutils literal notranslate"><span class="pre">copyWithZone(_:)</span></code>メソッドによって返されるもの ― を使って合成されるようにします、プロパティそれ自体の値ではなく。プロパティの型は、<code class="docutils literal notranslate"><span class="pre">NSCopying</span></code>プロトコルに準拠しなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">NSCopying</span></code> attribute behaves in a way similar to the Objective-C <code class="docutils literal notranslate"><span class="pre">copy</span></code> property attribute.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">NSCopying</span></code>属性は、Objective-Cの<code class="docutils literal notranslate"><span class="pre">copy</span></code>プロパティ属性に似たやり方でふるまいます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID591">
<h3>NSManaged<a class="headerlink" href="#ID591" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to an instance method or stored variable property of a class that inherits from <code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code> to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description. For a property marked with the <code class="docutils literal notranslate"><span class="pre">NSManaged</span></code> attribute, Core Data also provides the storage at runtime. Applying this attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
この属性を<code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code>から継承するクラスのインスタンスメソッドまたは格納変数プロパティに適用することで、関連する実体記述に基づいて、Coreデータが動的にそれの実装に実行時に提供されることを指し示してください。<code class="docutils literal notranslate"><span class="pre">NSManaged</span></code>属性で印されるプロパティに対して、Coreデータはまたストレージを実行時に提供します。この属性を適用することはさらにまた<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性も意味します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID592">
<h3>objc<a class="headerlink" href="#ID592" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to any declaration that can be represented in Objective-C—for example, nonnested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes, protocols and optional members of a protocol, initializers, and subscripts. The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute tells the compiler that a declaration is available to use in Objective-C code.</span><!--end_enstr-->
<span class="jpstr">
この属性をObjective-Cにおいて表わされることができる何らかの宣言に適用してください ― 例えば、入れ子にされないクラス、プロトコル、総称体でない列挙（整数の生の値型に制限される）、クラスのプロパティとメソッド（ゲッターやセッターを含む）、プロトコルおよびあるプロトコルのオプショナルメンバー、イニシャライザ、そして添え字など。<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性は、コンパイラにある宣言がObjective-Cコードにおいて使われることが可能であるのを伝えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <code class="docutils literal notranslate"><span class="pre">nonobjc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
この属性をある拡張に適用することは、その拡張のあらゆるメンバーで明示的に<code class="docutils literal notranslate"><span class="pre">nonobjc</span></code>属性で印されていないものにそれを適用することと同じ効果を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The compiler implicitly adds the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to subclasses of any class defined in Objective-C. However, the subclass must not be generic, and must not inherit from any generic classes. You can explicitly add the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to a subclass that meets these criteria, to specify its Objective-C name as discussed below. Protocols that are marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can’t inherit from protocols that aren’t marked with this attribute.</span><!--end_enstr-->
<span class="jpstr">
コンパイラは、Objective-Cにおいて定義されたあらゆるクラスのサブクラスに暗黙的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を加えます。しかしながら、サブクラスは総称体である必要はありません、そして何らかの総称体クラスから継承する必要はありません。あなたは、明示的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性をこの基準に合うサブクラスに適用して、下で議論されるように、それのObjective-C名を指定できます。<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるプロトコルは、この属性で印されないプロトコルから継承できません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute is also implicitly added in the following cases:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性はまた、以下の場合において暗黙的に加えられます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">The declaration is an override in a subclass, and the superclass’s declaration has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
その宣言は、サブクラスの中のオーバーライドである、そしてそのサブクラスの宣言が<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を持つ。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The declaration satisfies a requirement from a protocol that has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
その宣言は、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を持つあるプロトコルからの要件を満たす。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The declaration has the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>, <code class="docutils literal notranslate"><span class="pre">NSManaged</span></code>, or <code class="docutils literal notranslate"><span class="pre">GKInspectable</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
その宣言は、<code class="docutils literal notranslate"><span class="pre">IBAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>、<code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>、<code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>、<code class="docutils literal notranslate"><span class="pre">NSManaged</span></code>、または<code class="docutils literal notranslate"><span class="pre">GKInspectable</span></code>を持つ。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">If you apply the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name. The first letter of the case name is capitalized. For example, a case named <code class="docutils literal notranslate"><span class="pre">venus</span></code> in a Swift <code class="docutils literal notranslate"><span class="pre">Planet</span></code> enumeration is exposed to Objective-C code as a case named <code class="docutils literal notranslate"><span class="pre">PlanetVenus</span></code>.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性をある列挙に適応したならば、個々の列挙ケース節はObjective-Cコードに列挙名とそのケース節名を連結したものとして暴露されます。ケース節の最初の文字は大文字で書かれます。例えば、スウィフトの<code class="docutils literal notranslate"><span class="pre">Planet</span></code>列挙の中の<code class="docutils literal notranslate"><span class="pre">venus</span></code>と名付けられるケース節は、Objective-Cコードに<code class="docutils literal notranslate"><span class="pre">PlanetVenus</span></code>と名付けられるケース節として暴露されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute optionally accepts a single attribute argument, which consists of an identifier. The identifier specifies the name to be exposed to Objective-C for the entity that the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute applies to. You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers. If you specify the Objective-C name for a class, protocol, or enumeration, include a three-letter prefix on the name, as described in <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1">Conventions</a> in <a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210">Programming with Objective-C</a>. The example below exposes the getter for the <code class="docutils literal notranslate"><span class="pre">enabled</span></code> property of the <code class="docutils literal notranslate"><span class="pre">ExampleClass</span></code> to Objective-C code as <code class="docutils literal notranslate"><span class="pre">isEnabled</span></code> rather than just as the name of the property itself.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性は、任意にただ１つだけ属性引数を受け入れます、それはひとつの識別子から成ります。この識別子は、Objective-Cへと暴露される名前を<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を適用される存在に対して指定します。あなたはこの引数を、クラス、列挙、列挙ケース、プロトコル、メソッド、ゲッター、セッター、そしてイニシャライザに名前をつけるために使うことができます。あなたがObjective-C名をクラス、プロトコル、または列挙に指定するならば、ある３文字接頭辞をその名前に含めて下さい、<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1">Conventions</a>で<a class="reference external" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210">Programming with Objective-C</a>において記述されるように。以下の例は、<code class="docutils literal notranslate"><span class="pre">ExampleClass</span></code>の<code class="docutils literal notranslate"><span class="pre">enabled</span></code>プロパティのためのゲッターをObjective-Cコードに、ただプロパティそれ自身の名前ではなく<code class="docutils literal notranslate"><span class="pre">isEnabled</span></code>として露出します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">ExampleClass</span>: <span class="nc">NSObject</span> {
</li>
<li>    <span class="k">@objc</span> <span class="k">var</span> <span class="nv">enabled</span>: <span class="nc">Bool</span> {
</li>
<li>        <span class="k">@objc(isEnabled)</span> <span class="k">get</span> {
</li>
<li>            <span class="c"><span class="enstr">// Return the appropriate value</span><!--end_enstr--><span class="jpstr">（適切な値を返す）</span><!--end_jpstr--></span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">For more information, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c.html">Importing Swift into Objective-C</a>.</span><!--end_enstr-->
<span class="jpstr">
さらなる情報は、<a class="reference external" href="../../../developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c.html">SwiftをObjective-Cにインポートする</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The argument to the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute can also change the runtime name for that declaration. You use the runtime name when calling functions that interact with the Objective-C runtime, like <a class="reference external" href="../../../developer.apple.com/documentation/foundation/1395135-nsclassfromstring.html"><code class="docutils literal notranslate"><span class="pre">NSClassFromString</span></code></a>, and when specifying class names in an app’s Info.plist file. If you specify a name by passing an argument, that name is used as the name in Objective-C code and as the runtime name. If you omit the argument, the name used in Objective-C code matches the name in Swift code, and the runtime name follows the normal Swift compiler convention of name mangling.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性に対する引数はまた、その宣言に対するランタイム名を変更できます。あなたはランタイム名を、Objective-Cランタイムと相互作用する関数、<a class="reference external" href="../../../developer.apple.com/documentation/foundation/1395135-nsclassfromstring.html"><code class="docutils literal notranslate"><span class="pre">NSClassFromString</span></code></a>などを呼び出す時に、そしてクラス名をアプリのもつInfo.plistファイルの中で指定する時に使います。あなたが名前を引数を渡す事によって指定するならば、その名前はObjective-Cコードにおける名前としてそしてランタイム名として使われます。あなたが引数を省略するならば、Objective-Cコードにおいて使われる名前はSwiftコードにおける名前と合致します、そしてランタイム名は名前修飾の通常のSwiftコンパイラ慣例に従います。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID593">
<h3>objcMembers<a class="headerlink" href="#ID593" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class declaration, to implicitly apply the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute to all Objective-C compatible members of the class, its extensions, its subclasses, and all of the extensions of its subclasses.</span><!--end_enstr-->
<span class="jpstr">
この属性をあるクラス宣言に適用してください、暗黙的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性をそのクラスの全てのObjective-C互換メンバー、それの拡張、それのサブクラス、そしてそれのサブクラスの全ての拡張に適用するには。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Most code should use the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute instead, to expose only the declarations that are needed. If you need to expose many declarations, you can group them in an extension that has the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. The <code class="docutils literal notranslate"><span class="pre">objcMembers</span></code> attribute is a convenience for libraries that make heavy use of the introspection facilities of the Objective-C runtime. Applying the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute when it isn’t needed can increase your binary size and adversely affect performance.</span><!--end_enstr-->
<span class="jpstr">
ほとんどのコードは、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を代わりに使って、必要とされる宣言だけを露出するべきです。あなたが多くの宣言を露出する必要があるならば、あなたはそれらを<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を持つある拡張にまとめることができます。<code class="docutils literal notranslate"><span class="pre">objcMembers</span></code>属性は、Objective-Cランタイムの自己観察便宜の重度の使用を生じさせるライブラリにとって好都合です。それが必要とされない時に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を適用することは、あなたのバイナリサイズを増加させ性能に逆効果です。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID621">
<h3>propertyWrapper<a class="headerlink" href="#ID621" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class, structure, or enumeration declaration to use that type as a property wrapper. When you apply this attribute to a type, you create a custom attribute with the same name as the type. Apply that new attribute to a property of a class, structure, or enumeration to wrap access to the property through an instance of the wrapper type; apply the attribute to a local stored variable declaration to wrap access to the variable the same way. Computed variables, global variables, and constants can’t use property wrappers.</span><!--end_enstr-->
<span class="jpstr">
この属性をクラス、構造体、または列挙の宣言に適用して、その型をプロパティラッパーとして使ってください。あなたがこの属性をある型に適用する場合、あなたはあるあつらえの属性をその型と同じ名前で作成します。その新しい属性をクラス、構造体、または列挙のプロパティに適用することで、そのプロパティに対するアクセスを、ラッパー型のインスタンスによってラップしてください；その属性をあるローカル格納変数宣言に適用することで、その変数に対するアクセスを同じ方法でラップしてください。計算変数、グローバル変数、そして定数は、プロパティラッパーを使用できません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The wrapper must define a <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> instance property. The <em>wrapped value</em> of the property is the value that the getter and setter for this property expose. In most cases, <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> is a computed value, but it can be a stored value instead. The wrapper defines and manages any underlying storage needed by its wrapped value. The compiler synthesizes storage for the instance of the wrapper type by prefixing the name of the wrapped property with an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>)—for example, the wrapper for <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is stored as <code class="docutils literal notranslate"><span class="pre">_someProperty</span></code>. The synthesized storage for the wrapper has an access control level of <code class="docutils literal notranslate"><span class="pre">private</span></code>.</span><!--end_enstr-->
<span class="jpstr">
ラッパーは、ある<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>インスタンスプロパティを定義しなければなりません。そのプロパティの<em>ラップされた値</em>は、このプロパティに対するゲッターとセッターが露出する値です。ほとんどの場合には、<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>は計算される値です、しかしそれは代わりに格納される値であることもできます。ラッパーは、それのラップされた値によって必要とされるあらゆる基礎をなすストレージを定義および管理します。コンパイラは、ラッパー型のインスタンスのためにストレージを合成します、ラップされたプロパティの名前にアンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）で接頭辞をつけることによって — 例えば、<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>に対するラッパーは、<code class="docutils literal notranslate"><span class="pre">_someProperty</span></code>として格納されます。ラッパーのために合成されたストレージは、<code class="docutils literal notranslate"><span class="pre">private</span></code>のアクセス制御水準を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A property that has a property wrapper can include <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> blocks, but it can’t override the compiler-synthesized <code class="docutils literal notranslate"><span class="pre">get</span></code> or <code class="docutils literal notranslate"><span class="pre">set</span></code> blocks.</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパーを持つプロパティは、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>ブロックを含むことができます、しかしそれはコンパイラが合成した<code class="docutils literal notranslate"><span class="pre">get</span></code>または<code class="docutils literal notranslate"><span class="pre">set</span></code>ブロックをオーバーライドできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides two forms of syntactic sugar for initialization of a property wrapper. You can use assignment syntax in the definition of a wrapped value to pass the expression on the right-hand side of the assignment as the argument to the <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> parameter of the property wrapper’s initializer. You can also provide arguments to the attribute when you apply it to a property, and those arguments are passed to the property wrapper’s initializer. For example, in the code below, <code class="docutils literal notranslate"><span class="pre">SomeStruct</span></code> calls each of the initializers that <code class="docutils literal notranslate"><span class="pre">SomeWrapper</span></code> defines.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、２つの形式の糖衣構文をプロパティラッパーの初期化に対して提供します。あなたは、代入構文をラップ値の定義において使用して、代入の右手側での式を、プロパティラッパーのもつイニシャライザの<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>パラメータに対する引数として渡せます。あなたはまた引数いくつかを、属性に対して提供することが、それをあなたがプロパティに適用する時に行えます、そしてそれら引数は、プロパティラッパーのもつイニシャライザに渡されます。例えば、下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">SomeStruct</span></code>は、<code class="docutils literal notranslate"><span class="pre">SomeWrapper</span></code>が定義するイニシャライザそれぞれを呼び出します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">propertyWrapper</span>
</li>
<li><span class="k">struct</span> <span class="nv">SomeWrapper</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">var</span> <span class="nv">someValue</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>() {
</li>
<li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="m">100</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="m">12.3</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">wrappedValue</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="nv">wrappedValue</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="m">45.6</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">wrappedValue</span> <span class="nv">value</span>: <span class="nc">Int</span>, <span class="nv">custom</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">wrappedValue</span> = <span class="nv">value</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">someValue</span> = <span class="nv">custom</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li>
<li>    <span class="c">// Uses init()</span>
</li>
<li>    @<span class="nv">SomeWrapper</span> <span class="k">var</span> <span class="nv">a</span>: <span class="nc">Int</span>
</li>
<li>
</li>
<li>    <span class="c">// Uses init(wrappedValue:)</span>
</li>
<li>    @<span class="nv">SomeWrapper</span> <span class="k">var</span> <span class="nv">b</span> = <span class="m">10</span>
</li>
<li>
</li>
<li>    <span class="c">// Both use init(wrappedValue:custom:)</span>
</li>
<li>    @<span class="nv">SomeWrapper</span>(<span class="nv">custom</span>: <span class="m">98.7</span>) <span class="k">var</span> <span class="nv">c</span> = <span class="m">30</span>
</li>
<li>    @<span class="nv">SomeWrapper</span>(<span class="nv">wrappedValue</span>: <span class="m">30</span>, <span class="nv">custom</span>: <span class="m">98.7</span>) <span class="k">var</span> <span class="nv">d</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <em>projected value</em> for a wrapped property is a second value that a property wrapper can use to expose additional functionality. The author of a property wrapper type is responsible for determining the meaning of its projected value and defining the interface that the projected value exposes. To project a value from a property wrapper, define a <code class="docutils literal notranslate"><span class="pre">projectedValue</span></code> instance property on the wrapper type. The compiler synthesizes an identifier for the projected value by prefixing the name of the wrapped property with a dollar sign (<code class="docutils literal notranslate"><span class="pre">$</span></code>)—for example, the projected value for <code class="docutils literal notranslate"><span class="pre">someProperty</span></code> is <code class="docutils literal notranslate"><span class="pre">$someProperty</span></code>. The projected value has the same access control level as the original wrapped property.</span><!--end_enstr-->
<span class="jpstr">
あるラップされたプロパティに対する<em>投影値</em>は、２番目の値です、それはプロパティラッパーが使用することで追加的機能性を露出できるものです。プロパティラッパー型の作者は、その投影値の意味の決定にそして投影値を露出するインターフェイスの定義に責任があります。ある値をプロパティラッパーから投影をするには、<code class="docutils literal notranslate"><span class="pre">projectedValue</span></code>インスタンスプロパティをそのラッパー型上で定義してください。コンパイラは、ある識別子を投影値に対して合成します、ラップされたプロパティの名前にドル記号（<code class="docutils literal notranslate"><span class="pre">$</span></code>）で接頭辞をつけることによって — 例えば、<code class="docutils literal notranslate"><span class="pre">someProperty</span></code>に対する投影値は<code class="docutils literal notranslate"><span class="pre">$someProperty</span></code>です。投影値は、元のラップされたプロパティと同じアクセス制御水準を持ちます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">propertyWrapper</span>
</li>
<li><span class="k">struct</span> <span class="nv">WrapperWithProjection</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">var</span> <span class="nv">projectedValue</span>: <span class="nc">SomeProjection</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">SomeProjection</span>(<span class="nv">wrapper</span>: <span class="k">self</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">struct</span> <span class="nv">SomeProjection</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">wrapper</span>: <span class="nc">WrapperWithProjection</span>
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li>
<li>    @<span class="nv">WrapperWithProjection</span> <span class="k">var</span> <span class="nv">x</span> = <span class="m">123</span>
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">s</span> = <span class="nv">SomeStruct</span>()
</li>
<li><span class="nv">s</span>.<span class="nv">x</span>           <span class="c">// Int value</span>
</li>
<li><span class="nv">s</span>.<span class="nv">$x</span>          <span class="c">// SomeProjection value</span>
</li>
<li><span class="nv">s</span>.<span class="nv">$x</span>.<span class="nv">wrapper</span>  <span class="c">// WrapperWithProjection value</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID633">
<h3>resultBuilder<a class="headerlink" href="#ID633" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class, structure, enumeration to use that type as a result builder. A <em>result builder</em> is a type that builds a nested data structure step by step. You use result builders to implement a domain-specific language (DSL) for creating nested data structures in a natural, declarative way. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">resultBuilder</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html#ID630"><span class="std std-ref">Result Builders</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この属性をクラス、構造体、列挙に適用することで、その型をリザルトビルダーとして使ってください。<em>リザルトビルダー</em>は、ある型です、それは入れ子にされたデータ構造を着実に組み立てます。あなたはリザルトビルダーを使用することで、入れ子にされたデータ構造の自然な、宣言的な方法での作成のためにあるドメイン固有言語 (DSL) を実装します。どのように<code class="docutils literal notranslate"><span class="pre">resultBuilder</span></code>属性を使うかの例として、<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html#ID630"><span class="std std-ref">リザルトビルダー</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID634">
<h4><span class="enstr">Result-Building Methods<a class="headerlink" href="#ID634" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
リザルトビルド（結果組立）メソッド<a class="headerlink" href="#ID634" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">A result builder implements static methods described below. Because all of the result builder’s functionality is exposed through static methods, you don’t ever initialize an instance of that type. The <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method is required; the other methods—which enable additional functionality in the DSL—are optional. The declaration of a result builder type doesn’t actually have to include any protocol conformance.</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダーは、下で記述される静的メソッドを実装します。リザルトビルダーのもつ機能性の全ては静的メソッドを通して露出されることから、あなたは決してその型のインスタンスを初期化しないでください。<code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code>メソッドは必須とされます；他のメソッド — それは追加の機能性をDSLにおいて可能にします — は随意です。リザルトビルダー型の宣言は、実際はどんなプロトコル準拠も含む必要はありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The description of the static methods uses three types as placeholders. The type <code class="docutils literal notranslate"><span class="pre">Expression</span></code> is a placeholder for the type of the result builder’s input, <code class="docutils literal notranslate"><span class="pre">Component</span></code> is a placeholder for the type of a partial result, and <code class="docutils literal notranslate"><span class="pre">FinalResult</span></code> is a placeholder for the type of the result that the result builder produces. You replace these types with the actual types that your result builder uses. If your result-building methods don’t specify a type for <code class="docutils literal notranslate"><span class="pre">Expression</span></code> or <code class="docutils literal notranslate"><span class="pre">FinalResult</span></code>, they default to being the same as <code class="docutils literal notranslate"><span class="pre">Component</span></code>.</span><!--end_enstr-->
<span class="jpstr">
これら静的メソッドの説明は、３つの型をプレースホルダとして使います。型<code class="docutils literal notranslate"><span class="pre">Expression</span></code>はリザルトビルダーのもつ入力の型に対するプレースホルダです、<code class="docutils literal notranslate"><span class="pre">Component</span></code>は部分結果の型に対するプレースホルダです、そして<code class="docutils literal notranslate"><span class="pre">FinalResult</span></code>はリザルトビルダーが産み出す結果の型に対するプレースホルダです。あなたは、これらの型をあなたのリザルトビルダーが使う実際の型で置き換えます。あなたのリザリトビルドメソッドが<code class="docutils literal notranslate"><span class="pre">Expression</span></code>または<code class="docutils literal notranslate"><span class="pre">FinalResult</span></code>に対して型を指定しないならば、それらは初期状態で<code class="docutils literal notranslate"><span class="pre">Component</span></code>と同じになります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The result-building methods are as follows:</span><!--end_enstr-->
<span class="jpstr">
リザルビルドメソッドは、以下があります：
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildBlock(_</span> <span class="pre">components:</span> <span class="pre">Component...)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Combines an array of partial results into a single partial result. A result builder must implement this method.</span><!--end_enstr-->
<span class="jpstr">
部分的結果それらからなるある配列を単一の部分的結果へと結合します。リザルトビルダーは、このメソッドを実装しなければなりません。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildOptional(_</span> <span class="pre">component:</span> <span class="pre">Component?)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result from a partial result that can be <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Implement this method to support <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that don’t include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果を、<code class="docutils literal notranslate"><span class="pre">nil</span></code>であることが可能なある部分的結果から組み立てます。このメソッドを実装することで、<code class="docutils literal notranslate"><span class="pre">if</span></code>文をサポートしてください、それは<code class="docutils literal notranslate"><span class="pre">else</span></code>節を含まないものです。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildEither(first:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result whose value varies depending on some condition. Implement both this method and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> to support <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements and <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果を組み立てます、それの値はなんらかの条件に依存して変化するものです。このメソッドと<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>を両方とも実装することで、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文と、<code class="docutils literal notranslate"><span class="pre">if</span></code>文で<code class="docutils literal notranslate"><span class="pre">else</span></code>節を含むものをサポートしてください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildEither(second:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result whose value varies depending on some condition. Implement both this method and <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> to support <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements and <code class="docutils literal notranslate"><span class="pre">if</span></code> statements that include an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果を組み立てます、それの値はなんらかの条件に依存して変化するものです。このメソッドと<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>を両方とも実装することで、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文と、<code class="docutils literal notranslate"><span class="pre">if</span></code>文で<code class="docutils literal notranslate"><span class="pre">else</span></code>節を含むものをサポートしてください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildArray(_</span> <span class="pre">components:</span> <span class="pre">[Component])</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result from an array of partial results. Implement this method to support <code class="docutils literal notranslate"><span class="pre">for</span></code> loops.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果を、部分的結果それらからなるある配列から組み立てます。このメソッドを実装することで、<code class="docutils literal notranslate"><span class="pre">for</span></code>ループをサポートしてください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildExpression(_</span> <span class="pre">expression:</span> <span class="pre">Expression)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result from an expression. You can implement this method to perform preprocessing—for example, converting expressions to an internal type—or to provide additional information for type inference at use sites.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果をある式から組み立てます。あなたはこのメソッドを実装することで、処理 — 例えば、いくつかの式をある内部型へ変換すること — を実行します、または追加の情報を型推論に対してさまざまな現場で提供します。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildFinalResult(_</span> <span class="pre">component:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">FinalResult</span></code></dt>
<dd><span class="enstr">Builds a final result from a partial result. You can implement this method as part of a result builder that uses a different type for partial and final results, or to perform other postprocessing on a result before returning it.</span><!--end_enstr-->
<span class="jpstr">
ある最終的な結果をある部分的な結果から組み立てます。あなたはこのメソッドを、部分的および最終的結果に対して異なる型を使うあるリザルトビルダーの一部として、または他の処理をある結果上でそれが返る前に実行するために実装できます。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">func</span> <span class="pre">buildLimitedAvailability(_</span> <span class="pre">component:</span> <span class="pre">Component)</span> <span class="pre">-&gt;</span> <span class="pre">Component</span></code></dt>
<dd><span class="enstr">Builds a partial result that propagates or erases type information outside a compiler-control statement that performs an availability check. You can use this to erase type information that varies between the conditional branches.</span><!--end_enstr-->
<span class="jpstr">
ある部分的結果を組み立てます、それはある有効性検査を実行するコンパイラ制御文の外側に型情報を伝播または消去するものです。あなたはこれを使うことで、条件分岐の間でさまざまに変化する型情報を消去できます。
</span><!--end_jpstr-->
</dd>
</dl>
<p><span class="enstr">For example, the code below defines a simple result builder that builds an array of integers. This code defines <code class="docutils literal notranslate"><span class="pre">Compontent</span></code> and <code class="docutils literal notranslate"><span class="pre">Expression</span></code> as type aliases, to make it easier to match the examples below to the list of methods above.</span><!--end_enstr-->
<span class="jpstr">
例えば、下のコードはある単純なリザルトビルダーを定義します、それは整数それらからなるある配列を組み立てます。このコードは、<code class="docutils literal notranslate"><span class="pre">Compontent</span></code>と<code class="docutils literal notranslate"><span class="pre">Expression</span></code>を型エイリアスとして定義します、そうして下の例それらを上のメソッドそれらのリストにより合うようにしています。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">resultBuilder</span>
</li>
<li><span class="k">struct</span> <span class="nv">ArrayBuilder</span> {
</li>
<li>    <span class="k">typealias</span> <span class="nv">Component</span> = [<span class="nc">Int</span>]
</li>
<li>    <span class="k">typealias</span> <span class="nv">Expression</span> = <span class="nc">Int</span>
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildExpression</span>(<span class="k">_</span> <span class="nv">element</span>: <span class="nc">Expression</span>) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">return</span> [<span class="nv">element</span>]
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildOptional</span>(<span class="k">_</span> <span class="nv">component</span>: <span class="nc">Component</span>?) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">guard</span> <span class="k">let</span> <span class="nv">component</span> = <span class="nv">component</span> <span class="k">else</span> { <span class="k">return</span> [] }
</li>
<li>        <span class="k">return</span> <span class="nv">component</span>
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">first</span> <span class="nv">component</span>: <span class="nc">Component</span>) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">component</span>
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">second</span> <span class="nv">component</span>: <span class="nc">Component</span>) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">component</span>
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildArray</span>(<span class="k">_</span> <span class="nv">components</span>: [<span class="nc">Component</span>]) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Array</span>(<span class="nv">components</span>.<span class="nv">joined</span>())
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">Component</span>...) -&gt; <span class="nc">Component</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Array</span>(<span class="nv">components</span>.<span class="nv">joined</span>())
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID635">
<h4><span class="enstr">Result Transformations<a class="headerlink" href="#ID635" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
結果（リザルト）変換<a class="headerlink" href="#ID635" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">The following syntactic transformations are applied recursively to turn code that uses result-builder syntax into code that calls the static methods of the result builder type:</span><!--end_enstr-->
<span class="jpstr">
以下の構文的変換は、再帰的に適用されることで、リザルトビルダー構文を使うコードを、リザルトビルダー型の静的メソッドを呼び出すコードに転換します：
</span><!--end_jpstr-->
</p>
<ul>
<li>
<p class="first"><span class="enstr">If the result builder has a <code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code> method, each expression becomes a call to that method. This transformation is always first. For example, the following declarations are equivalent:</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダーがある<code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code>メソッドを持つならば、各々の式はそのメソッドへの呼び出しになります。この変換は、常に１番目です。例えば、以下の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderNumber</span>: [<span class="nc">Int</span>] { <span class="m">10</span> }
</li>
<li><span class="k">var</span> <span class="nv">manualNumber</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">10</span>)
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">An assignment statement is transformed like an expression, but is understood to evaluate to <code class="docutils literal notranslate"><span class="pre">()</span></code>. You can define an overload of <code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code> that takes an argument of type <code class="docutils literal notranslate"><span class="pre">()</span></code> to handle assignments specifically.</span><!--end_enstr-->
<span class="jpstr">
代入文は、式のように変換されます、しかし<code class="docutils literal notranslate"><span class="pre">()</span></code>を評価すると理解されます。あなたは<code class="docutils literal notranslate"><span class="pre">buildExpression(_:)</span></code>のあるオーバーロードを定義できます、それは型<code class="docutils literal notranslate"><span class="pre">()</span></code>の１つの引数を取ることで特に代入を取り扱うものです。
</span><!--end_jpstr-->
</p>
</li>
<li>
<p class="first"><span class="enstr">A branch statement that checks an availability condition becomes a call to the <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method. This transformation happens before the transformation into a call to <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>, <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>, or <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>. You use the <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method to erase type information that changes depending on which branch is taken. For example, the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods below use a generic type that captures type information about both branches.</span><!--end_enstr-->
<span class="jpstr">
ある有効性条件を検査する分岐文は、<code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code>メソッドへの呼び出しになります。この変換は、<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>、<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>、または<code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>への呼び出しへの変換の前に起こります。あなたは、<code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code>メソッドを使用することで、どの分岐が取られるかに依存して変化する型情報を消去します。例えば、下の<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>と<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>メソッドは、ある総称体型を使います、それは両方の分岐について型情報をキャプチャします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">protocol</span> <span class="nv">Drawable</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span>
</li>
<li>}
</li>
<li><span class="k">struct</span> <span class="nv">Text</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li>
<li>}
</li>
<li><span class="k">struct</span> <span class="nv">Line</span>&lt;<span class="nv">D</span>: <span class="nc">Drawable</span>&gt;: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">elements</span>: [<span class="nc">D</span>]
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">elements</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">draw</span>() }.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">""</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">struct</span> <span class="nv">DrawEither</span>&lt;<span class="nv">First</span>: <span class="nc">Drawable</span>, <span class="nv">Second</span>: <span class="nc">Drawable</span>&gt;: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>() }
</li>
<li>}
</li>
<li>
</li>
<li>@<span class="nv">resultBuilder</span>
</li>
<li><span class="k">struct</span> <span class="nv">DrawingBuilder</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>&lt;<span class="nv">D</span>: <span class="nc">Drawable</span>&gt;(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">D</span>...) -&gt; <span class="nc">Line</span>&lt;<span class="nc">D</span>&gt; {
</li>
<li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>&lt;<span class="nv">First</span>, <span class="nv">Second</span>&gt;(<span class="nv">first</span>: <span class="nc">First</span>)
</li>
<li>        -&gt; <span class="nc">DrawEither</span>&lt;<span class="nc">First</span>, <span class="nc">Second</span>&gt; {
</li>
<li>            <span class="k">return</span> <span class="nv">DrawEither</span>(<span class="nv">content</span>: <span class="nv">first</span>)
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>&lt;<span class="nv">First</span>, <span class="nv">Second</span>&gt;(<span class="nv">second</span>: <span class="nc">Second</span>)
</li>
<li>        -&gt; <span class="nc">DrawEither</span>&lt;<span class="nc">First</span>, <span class="nc">Second</span>&gt; {
</li>
<li>            <span class="k">return</span> <span class="nv">DrawEither</span>(<span class="nv">content</span>: <span class="nv">second</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">However, this approach causes a problem in code that has availability checks:</span><!--end_enstr-->
<span class="jpstr">
しかしながら、この取り組みは有効性検査を持つコードにおいて問題を引き起こします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">@available</span>(<span class="k">macOS</span> <span class="m">99</span>, *)
</li>
<li><span class="k">struct</span> <span class="nv">FutureText</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li>
<li>}
</li>
<li>@<span class="nv">DrawingBuilder</span> <span class="k">var</span> <span class="nv">brokenDrawing</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">if</span> <span class="k">#available</span>(<span class="k">macOS</span> <span class="m">99</span>, *) {
</li>
<li>        <span class="nv">FutureText</span>(<span class="s">"Inside.future"</span>)  <span class="c">// Problem</span>
</li>
<li>    } <span class="k">else</span> {
</li>
<li>        <span class="nv">Text</span>(<span class="s">"Inside.present"</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="c">// The type of brokenDrawing is Line&lt;DrawEither&lt;Line&lt;FutureText&gt;, Line&lt;Text&gt;&gt;&gt;</span>
</li>
</ol></div></div></div>
<p><span class="enstr">In the code above, <code class="docutils literal notranslate"><span class="pre">FutureText</span></code> appears as part of the type of <code class="docutils literal notranslate"><span class="pre">brokenDrawing</span></code> because it’s one of the types in the <code class="docutils literal notranslate"><span class="pre">DrawEither</span></code> generic type. This could cause your program to crash if <code class="docutils literal notranslate"><span class="pre">FutureText</span></code> isn’t available at runtime, even in the case where that type is explicitly not being used.</span><!--end_enstr-->
<span class="jpstr">
上のコードにおいて、<code class="docutils literal notranslate"><span class="pre">FutureText</span></code>は<code class="docutils literal notranslate"><span class="pre">brokenDrawing</span></code>の型の一部として現れます、なぜならそれは<code class="docutils literal notranslate"><span class="pre">DrawEither</span></code>総称体型の中の型のうちの１つだからです。これは、あなたのプログラムをクラッシュさせる可能性があります、もし<code class="docutils literal notranslate"><span class="pre">FutureText</span></code>が実行時に有効でないならば、はっきりその型が使われない場合でさえ。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To solve this problem, implement a <code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code> method to erase type information. For example, the code below builds an <code class="docutils literal notranslate"><span class="pre">AnyDrawable</span></code> value from its availability check.</span><!--end_enstr-->
<span class="jpstr">
この問題を解決するには、<code class="docutils literal notranslate"><span class="pre">buildLimitedAvailability(_:)</span></code>メソッドを実装して型情報を消去してください。例えば、下のコードは<code class="docutils literal notranslate"><span class="pre">AnyDrawable</span></code>値をそれの有効性検査から作り上げます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">AnyDrawable</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>() }
</li>
<li>}
</li>
<li><span class="k">extension</span> <span class="nc">DrawingBuilder</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildLimitedAvailability</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">AnyDrawable</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">AnyDrawable</span>(<span class="nv">content</span>: <span class="nv">content</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>@<span class="nv">DrawingBuilder</span> <span class="k">var</span> <span class="nv">typeErasedDrawing</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">if</span> <span class="k">#available</span>(<span class="k">macOS</span> <span class="m">99</span>, *) {
</li>
<li>        <span class="nv">FutureText</span>(<span class="s">"Inside.future"</span>)
</li>
<li>    } <span class="k">else</span> {
</li>
<li>        <span class="nv">Text</span>(<span class="s">"Inside.present"</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="c">// The type of typeErasedDrawing is Line&lt;DrawEither&lt;AnyDrawable, Line&lt;Text&gt;&gt;&gt;</span>
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">A branch statement becomes a series of nested calls to the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods. The statements’ conditions and cases are mapped onto the leaf nodes of a binary tree, and the statement becomes a nested call to the <code class="docutils literal notranslate"><span class="pre">buildEither</span></code> methods following the path to that leaf node from the root node.</span><!--end_enstr-->
<span class="jpstr">
ある分岐文は、一連の入れ子にされた<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>と<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>メソッドそれらへの呼び出しになります。その文のもつ条件と事例は、ある二分木のリーフノードそれらへとマップされます、そして文は<code class="docutils literal notranslate"><span class="pre">buildEither</span></code>メソッドそれらへのある入れ子にされた呼び出しになり、ルートノードからそのリーフノードへの経路をなぞっています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, if you write a switch statement that has three cases, the compiler uses a binary tree with three leaf nodes. Likewise, because the path from the root node to the second case is “second child” and then “first child”, that case becomes a nested call like <code class="docutils literal notranslate"><span class="pre">buildEither(first:</span> <span class="pre">buildEither(second:</span> <span class="pre">...</span> <span class="pre">))</span></code>. The following declarations are equivalent:</span><!--end_enstr-->
<span class="jpstr">
例えば、あなたが３つの事例を持つある切替文を書くならば、コンパイラは３つのリーフノードを備えるあるバイナリツリーを使います。同様に、ルートノードから２番目の事例への経路は “２番目の子” そしてそれゆえ “最初の子” であることから、その事例はある入れ子にされた呼び出しになります、<code class="docutils literal notranslate"><span class="pre">buildEither(first:</span> <span class="pre">buildEither(second:</span> <span class="pre">...</span> <span class="pre">))</span></code>のように。以下の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">someNumber</span> = <span class="m">19</span>
</li>
<li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderConditional</span>: [<span class="nc">Int</span>] {
</li>
<li>    <span class="k">if</span> <span class="nv">someNumber</span> &lt; <span class="m">12</span> {
</li>
<li>        <span class="m">31</span>
</li>
<li>    } <span class="k">else</span> <span class="k">if</span> <span class="nv">someNumber</span> == <span class="m">19</span> {
</li>
<li>        <span class="m">32</span>
</li>
<li>    } <span class="k">else</span> {
</li>
<li>        <span class="m">33</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">var</span> <span class="nv">manualConditional</span>: [<span class="nc">Int</span>]
</li>
<li><span class="k">if</span> <span class="nv">someNumber</span> &lt; <span class="m">12</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">31</span>)
</li>
<li>    <span class="k">let</span> <span class="nv">outerPartialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">partialResult</span>)
</li>
<li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">outerPartialResult</span>)
</li>
<li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">someNumber</span> == <span class="m">19</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">32</span>)
</li>
<li>    <span class="k">let</span> <span class="nv">outerPartialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">partialResult</span>)
</li>
<li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">outerPartialResult</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">33</span>)
</li>
<li>    <span class="nv">manualConditional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">partialResult</span>)
</li>
<li>}
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">A branch statement that might not produce a value, like an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement without an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause, becomes a call to <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>. If the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement’s condition is satisfied, its code block is transformed and passed as the argument; otherwise, <code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code> is called with <code class="docutils literal notranslate"><span class="pre">nil</span></code> as its argument. For example, the following declarations are equivalent:</span><!--end_enstr-->
<span class="jpstr">
値を生成しないかもしれない分岐文、たとえば<code class="docutils literal notranslate"><span class="pre">if</span></code>文で<code class="docutils literal notranslate"><span class="pre">else</span></code>節なしなどは、<code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>への呼び出しになります。<code class="docutils literal notranslate"><span class="pre">if</span></code>文のもつ条件が満たされるならば、それのコードブロックは変換されてそして引数として渡されます；そうでなければ、<code class="docutils literal notranslate"><span class="pre">buildOptional(_:)</span></code>が呼び出されます、<code class="docutils literal notranslate"><span class="pre">nil</span></code>をそれの引数として。例えば、以下の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderOptional</span>: [<span class="nc">Int</span>] {
</li>
<li>    <span class="k">if</span> (<span class="nv">someNumber</span> % <span class="m">2</span>) == <span class="m">1</span> { <span class="m">20</span> }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">var</span> <span class="nv">partialResult</span>: [<span class="nc">Int</span>]? = <span class="k">nil</span>
</li>
<li><span class="k">if</span> (<span class="nv">someNumber</span> % <span class="m">2</span>) == <span class="m">1</span> {
</li>
<li>    <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">20</span>)
</li>
<li>}
</li>
<li><span class="k">var</span> <span class="nv">manualOptional</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildOptional</span>(<span class="nv">partialResult</span>)
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">A code block or <code class="docutils literal notranslate"><span class="pre">do</span></code> statement becomes a call to the <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method. Each of the statements inside of the block is transformed, one at a time, and they become the arguments to the <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method. For example, the following declarations are equivalent:</span><!--end_enstr-->
<span class="jpstr">
コードブロックまたは<code class="docutils literal notranslate"><span class="pre">do</span></code>文は、<code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code>メソッドへの呼び出しになります。ブロックの内部の文のそれぞれは変換されます、一度に１つずつ、そしてそれらは<code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code>メソッドへの引数になります。例えば、以下の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderBlock</span>: [<span class="nc">Int</span>] {
</li>
<li>    <span class="m">100</span>
</li>
<li>    <span class="m">200</span>
</li>
<li>    <span class="m">300</span>
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">var</span> <span class="nv">manualBlock</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildBlock</span>(
</li>
<li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">100</span>),
</li>
<li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">200</span>),
</li>
<li>    <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">300</span>)
</li>
<li>)
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">A <code class="docutils literal notranslate"><span class="pre">for</span></code> loop becomes a temporary variable, a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, and call to the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method. The new <code class="docutils literal notranslate"><span class="pre">for</span></code> loop iterates over the sequence and appends each partial result to that array. The temporary array is passed as the argument in the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> call. For example, the following declarations are equivalent:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">for</span></code>ループは、ある一時的な変数、ある<code class="docutils literal notranslate"><span class="pre">for</span></code>ループ、そして<code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code>メソッドへの呼び出しになります。新しい<code class="docutils literal notranslate"><span class="pre">for</span></code>ループは、そのシーケンスのすべてにわたって反復します、そして部分的結果それぞれをその配列に追加します。一時的配列は、引数として<code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code>呼び出しにおいて渡されます。例えば、以下の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">ArrayBuilder</span> <span class="k">var</span> <span class="nv">builderArray</span>: [<span class="nc">Int</span>] {
</li>
<li>    <span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">5</span>...<span class="m">7</span> {
</li>
<li>        <span class="m">100</span> + <span class="nv">i</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">var</span> <span class="nv">temporary</span>: [[<span class="nc">Int</span>]] = []
</li>
<li><span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">5</span>...<span class="m">7</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">partialResult</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildExpression</span>(<span class="m">100</span> + <span class="nv">i</span>)
</li>
<li>    <span class="nv">temporary</span>.<span class="nv">append</span>(<span class="nv">partialResult</span>)
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">manualArray</span> = <span class="nv">ArrayBuilder</span>.<span class="nv">buildArray</span>(<span class="nv">temporary</span>)
</li>
</ol></div></div></div>
</li>
<li>
<p class="first"><span class="enstr">If the result builder has a <code class="docutils literal notranslate"><span class="pre">buildFinalResult(_:)</span></code> method, the final result becomes a call to that method. This transformation is always last.</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダーがある<code class="docutils literal notranslate"><span class="pre">buildFinalResult(_:)</span></code>メソッドを持つならば、最終的結果はそのメソッドへの呼び出しになります。この変換は、常に最後です。
</span><!--end_jpstr-->
</p>
</li>
</ul>
<p><span class="enstr">Although the transformation behavior is described in terms of temporary variables, using a result builder doesn’t actually create any new declarations that are visible from the rest of your code.</span><!--end_enstr-->
<span class="jpstr">
変換挙動は一時的な変数それらに基づいて記述されるとはいえ、リザルトビルダーを使うことは、あなたのコードの残りから可視であるどんな新しい宣言も実際は作成しません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can’t use <code class="docutils literal notranslate"><span class="pre">break</span></code>, <code class="docutils literal notranslate"><span class="pre">continue</span></code>, <code class="docutils literal notranslate"><span class="pre">defer</span></code>, <code class="docutils literal notranslate"><span class="pre">guard</span></code>, or <code class="docutils literal notranslate"><span class="pre">return</span></code> statements, <code class="docutils literal notranslate"><span class="pre">while</span></code> statements, or <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> statements in the code that a result builder transforms.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">break</span></code>、<code class="docutils literal notranslate"><span class="pre">continue</span></code>、<code class="docutils literal notranslate"><span class="pre">defer</span></code>、<code class="docutils literal notranslate"><span class="pre">guard</span></code>、または<code class="docutils literal notranslate"><span class="pre">return</span></code>文、<code class="docutils literal notranslate"><span class="pre">while</span></code>文、または<code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code>文をリザルトビルダーが変換するコードにおいて使用できません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The transformation process doesn’t change declarations in the code, which lets you use temporary constants and variables to build up expressions piece by piece. It also doesn’t change <code class="docutils literal notranslate"><span class="pre">throw</span></code> statements, compile-time diagnostic statements, or closures that contain a <code class="docutils literal notranslate"><span class="pre">return</span></code> statement.</span><!--end_enstr-->
<span class="jpstr">
変換処理は、コードの中の宣言を変更しません、それはあなたに一時的な定数と変数を使用して式それらを一つ一つ組み立てさせます。それはまた、<code class="docutils literal notranslate"><span class="pre">throw</span></code>文、コンパイル時診断文、または<code class="docutils literal notranslate"><span class="pre">return</span></code>文を含むクロージャを変更しません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Whenever possible, transformations are coalesced. For example, the expression <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span></code> becomes <code class="docutils literal notranslate"><span class="pre">buildExpression(4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6)</span></code> rather multiple calls to that function. Likewise, nested branch statements become a single binary tree of calls to the <code class="docutils literal notranslate"><span class="pre">buildEither</span></code> methods.</span><!--end_enstr-->
<span class="jpstr">
可能な時はいつでも、変換それらは合体させられます。例えば、式<code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6</span></code>は<code class="docutils literal notranslate"><span class="pre">buildExpression(4</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">6)</span></code>になります、その関数に対する複数の呼び出しではなく。同様に、入れ子にされた分岐文それらは、<code class="docutils literal notranslate"><span class="pre">buildEither</span></code>メソッドへの呼び出しいくつかからなるある単一の二分木になります。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID636">
<h4><span class="enstr">Custom Result-Builder Attributes<a class="headerlink" href="#ID636" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
あつらえのリザルトビルダー属性<a class="headerlink" href="#ID636" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">Creating a result builder type creates a custom attribute with the same name. You can apply that attribute in the following places:</span><!--end_enstr-->
<span class="jpstr">
あるリザルトビルダー型を作成することは、あるあつらえの属性を同じ名前で作成します。あなたは、その属性を以下の場所で適用できます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">On a function declaration, the result builder builds the body of the function.</span><!--end_enstr-->
<span class="jpstr">
ある関数宣言上で、リザルトビルダーはその関数の本文を組み立てます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">On a variable or subscript declaration that includes a getter, the result builder builds the body of the getter.</span><!--end_enstr-->
<span class="jpstr">
ゲッターを含んでいる、変数または添え字の宣言上で、リザルトビルダーはゲッターの本文を組み立てます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">On a parameter in a function declaration, the result builder builds the body of a closure that’s passed as the corresponding argument.</span><!--end_enstr-->
<span class="jpstr">
関数宣言のパラメータ上で、リザルトビルダーは、対応する引数として渡されるクロージャの本文を組み立てます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">Applying a result builder attribute doesn’t impact ABI compatibility. Applying a result builder attribute to a parameter makes that attribute part of the function’s interface, which can effect source compatibility.</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダー属性を適用することは、ABI互換性に影響を与えません。リザルトビルダー属性をあるパラメータに適用することは、その属性を関数のもつインターフェイスの一部にします、それはソース互換性に影響を及ぼす可能性があります。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID594">
<h3>requires_stored_property_inits<a class="headerlink" href="#ID594" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class declaration to require all stored properties within the class to provide default values as part of their definitions. This attribute is inferred for any class that inherits from <code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この属性をあるクラス宣言に適用することで、そのクラス内の全ての格納プロパティに、省略時の値をそれら宣言の一部として提供することを要求してください。この属性は、<code class="docutils literal notranslate"><span class="pre">NSManagedObject</span></code>から継承されるあらゆるクラスに対して伴われます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID595">
<h3>testable<a class="headerlink" href="#ID595" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to an <code class="docutils literal notranslate"><span class="pre">import</span></code> declaration to import that module with changes to its access control that simplify testing the module’s code. Entities in the imported module that are marked with the <code class="docutils literal notranslate"><span class="pre">internal</span></code> access-level modifier are imported as if they were declared with the <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier. Classes and class members that are marked with the <code class="docutils literal notranslate"><span class="pre">internal</span></code> or <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier are imported as if they were declared with the <code class="docutils literal notranslate"><span class="pre">open</span></code> access-level modifier. The imported module must be compiled with testing enabled.</span><!--end_enstr-->
<span class="jpstr">
この属性をある<code class="docutils literal notranslate"><span class="pre">import</span></code>宣言に適用することで、そのモジュールのインポートをそれのアクセス制御への、モジュールの持つコードを試験するのを簡単にする変更とともに行ってください。<code class="docutils literal notranslate"><span class="pre">internal</span></code>アクセス水準修飾子で印されるインポートされたモジュールの中の存在それらは、まるでそれらが<code class="docutils literal notranslate"><span class="pre">public</span></code>アクセス水準修飾子で宣言されたかのようにインポートされます。<code class="docutils literal notranslate"><span class="pre">internal</span></code>または<code class="docutils literal notranslate"><span class="pre">public</span></code>アクセス水準修飾子で印されるクラスまたはクラスメンバーは、まるでそれらが<code class="docutils literal notranslate"><span class="pre">open</span></code>アクセス水準修飾子で宣言されたかのようにインポートされます。インポートされたモジュールは、テストすることを可能にされてコンパイルされなければなりません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID596">
<h3>UIApplicationMain<a class="headerlink" href="#ID596" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a class to indicate that it’s the application delegate. Using this attribute is equivalent to calling the <code class="docutils literal notranslate"><span class="pre">UIApplicationMain</span></code> function and passing this class’s name as the name of the delegate class.</span><!--end_enstr-->
<span class="jpstr">
この属性をあるクラスに適用することで、それがアプリケーション委任先であることを指し示してください。この属性を使用することは、<code class="docutils literal notranslate"><span class="pre">UIApplicationMain</span></code>関数を呼んで、このクラスの名前を委任先クラスの名前として渡すことに相当します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you don’t use this attribute, supply a <code class="docutils literal notranslate"><span class="pre">main.swift</span></code> file with code at the top level that calls the <a class="reference external" href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain"><code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code></a> function. For example, if your app uses a custom subclass of <code class="docutils literal notranslate"><span class="pre">UIApplication</span></code> as its principal class, call the <code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code> function instead of using this attribute.</span><!--end_enstr-->
<span class="jpstr">
あなたがこの属性を使わないならば、<a class="reference external" href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain"><code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code></a>関数を呼ぶトップレベルでのコードを持つ<code class="docutils literal notranslate"><span class="pre">main.swift</span></code>ファイルを提供してください。例えば、あなたのアプリがそれの主役クラス（プリンシパルクラス）として<code class="docutils literal notranslate"><span class="pre">UIApplication</span></code>のあつらえのサブクラスを使うならば、<code class="docutils literal notranslate"><span class="pre">UIApplicationMain(_:_:_:_:)</span></code>関数をこの属性を使用する代わりに呼んでください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in <a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">Top-Level Code</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがコンパイルして実行可能にするSwiftコードは、最大で１つのトップレベルエントリポイントを持つことができます、<a class="reference internal" href="Declarations.html#ID352"><span class="std std-ref">トップレベル・コード</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID597">
<h3>usableFromInline<a class="headerlink" href="#ID597" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a function, method, computed property, subscript, initializer, or deinitializer declaration to allow that symbol to be used in inlinable code that’s defined in the same module as the declaration. The declaration must have the <code class="docutils literal notranslate"><span class="pre">internal</span></code> access-level modifier. A structure or class marked <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can use only types that are public or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> for its properties. An enumeration marked <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can use only types that are public or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> for the raw values and associated values of its cases.</span><!--end_enstr-->
<span class="jpstr">
この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、そのシンボルが、同じモジュールの中で宣言として定義されるインライン可能コードにおいて使用できるようにしてください。宣言は、<code class="docutils literal notranslate"><span class="pre">internal</span></code>アクセス水準修飾子を持たなければなりません。<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>で印される構造体またはクラスは、それのプロパティに対してパブリックまたは<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>である型のみに使用できます。<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>で印される列挙は、生の値およびそれの列挙節の関連値に対してパブリックまたは<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>である型のみに使用できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Like the <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier, this attribute exposes the declaration as part of the module’s public interface. Unlike <code class="docutils literal notranslate"><span class="pre">public</span></code>, the compiler doesn’t allow declarations marked with <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> to be referenced by name in code outside the module, even though the declaration’s symbol is exported. However, code outside the module might still be able to interact with the declaration’s symbol by using runtime behavior.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">public</span></code>アクセス水準修飾子のように、この属性は宣言をモジュールの公開インターフェイスの一部として露出します。<code class="docutils literal notranslate"><span class="pre">public</span></code>とは違い、コンパイラは<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>で印される宣言に名前によってモジュール外部のコードにおいて参照されるのを許しません、宣言のシンボルがエクスポートされるとしてもです。しかしながら、モジュール外部のコードは、依然として宣言のシンボルと実行時挙動を使うことによって相互作用可能かもしれません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Declarations marked with the <code class="docutils literal notranslate"><span class="pre">inlinable</span></code> attribute are implicitly usable from inlinable code. Although either <code class="docutils literal notranslate"><span class="pre">inlinable</span></code> or <code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code> can be applied to <code class="docutils literal notranslate"><span class="pre">internal</span></code> declarations, applying both attributes is an error.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">inlinable</span></code>属性で印される宣言は、暗黙的にインライン可能コードから利用可能です。けれども<code class="docutils literal notranslate"><span class="pre">inlinable</span></code>または<code class="docutils literal notranslate"><span class="pre">usableFromInline</span></code>のどちらかは、<code class="docutils literal notranslate"><span class="pre">internal</span></code>宣言に適用できます、両方の属性を適用することはエラーです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID598">
<h3>warn_unqualified_access<a class="headerlink" href="#ID598" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a top-level function, instance method, or class or static method to trigger warnings when that function or method is used without a preceding qualifier, such as a module name, type name, or instance variable or constant. Use this attribute to help discourage ambiguity between functions with the same name that are accessible from the same scope.</span><!--end_enstr-->
<span class="jpstr">
この属性をトップレベルの関数、インスタンスメソッド、もしくはクラスまたは静的メソッドに適用することで、その関数またはメソッドが、例えばモジュール名、型名、またはインスタンス変数や定数など、先行する修飾語無しで使われる場合に警告を引き起こしてください。この属性を使って、関数とその同じスコープからアクセス可能な同じ名前との間の曖昧さを防止するのに役立ててください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, the Swift standard library includes both a top-level <a class="reference external" href="../../../developer.apple.com/documentation/swift/1538339-min.html"><code class="docutils literal notranslate"><span class="pre">min(_:_:)</span></code></a> function and a <a class="reference external" href="../../../developer.apple.com/documentation/swift/sequence/1641174-min.html"><code class="docutils literal notranslate"><span class="pre">min()</span></code></a> method for sequences with comparable elements. The sequence method is declared with the <code class="docutils literal notranslate"><span class="pre">warn_unqualified_access</span></code> attribute to help reduce confusion when attempting to use one or the other from within a <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> extension.</span><!--end_enstr-->
<span class="jpstr">
例えば、Swift標準ライブラリはトップレベルの<a class="reference external" href="../../../developer.apple.com/documentation/swift/1538339-min.html"><code class="docutils literal notranslate"><span class="pre">min(_:_:)</span></code></a>関数と比較可能要素を持つシーケンスに対する<a class="reference external" href="../../../developer.apple.com/documentation/swift/sequence/1641174-min.html"><code class="docutils literal notranslate"><span class="pre">min()</span></code></a>メソッドの両方を持ちます。シーケンスメソッドは、<code class="docutils literal notranslate"><span class="pre">warn_unqualified_access</span></code>属性で宣言されることで、一方または他方を使うことをある<code class="docutils literal notranslate"><span class="pre">Sequence</span></code>拡張内から試みる時に混乱を減らすのを助けます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID349">
<h3><span class="enstr">Declaration Attributes Used by Interface Builder<a class="headerlink" href="#ID349" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
インターフェイスビルダーで使用される宣言属性<a class="headerlink" href="#ID349" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode. Swift provides the following Interface Builder attributes: <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, and <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>. These attributes are conceptually the same as their Objective-C counterparts.</span><!--end_enstr-->
<span class="jpstr">
いくつかのインターフェイスビルダー属性は、Xcodeと同期するためにインターフェイスビルダーによって使用される宣言属性です。スウィフトは、以下のインターフェイスビルダー属性を提供します：<code class="docutils literal notranslate"><span class="pre">IBAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>、<code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>、そして<code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>。これらの属性は、概念的にそれらのObjective-Cでの対応物と同じものです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You apply the <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code> and <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code> attributes to property declarations of a class. You apply the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code> and <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code> attribute to method declarations of a class and the <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code> attribute to class declarations.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>と<code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>属性をクラスのプロパティ宣言に適用します。あなたは、<code class="docutils literal notranslate"><span class="pre">IBAction</span></code>と<code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>属性をクラスのメソッド宣言に、そして<code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>属性をクラス宣言に適用します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Applying the <code class="docutils literal notranslate"><span class="pre">IBAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>, <code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>, <code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>, or <code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code> attribute also implies the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">IBAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBSegueAction</span></code>、<code class="docutils literal notranslate"><span class="pre">IBOutlet</span></code>、<code class="docutils literal notranslate"><span class="pre">IBDesignable</span></code>、または<code class="docutils literal notranslate"><span class="pre">IBInspectable</span></code>属性を適用することはまた、暗黙的に<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性を伴います。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID350">
<h2><span class="enstr">Type Attributes<a class="headerlink" href="#ID350" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型属性<a class="headerlink" href="#ID350" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can apply type attributes to types only.</span><!--end_enstr-->
<span class="jpstr">
あなたは、型属性を型だけに適用することができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID599">
<h3>autoclosure<a class="headerlink" href="#ID599" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments. You apply it to a parameter’s type in a function or method declaration, for a parameter whose type is a function type that takes no arguments and that returns a value of the type of the expression. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">autoclosure</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID543"><span class="std std-ref">Autoclosures</span></a> and <a class="reference internal" href="Types.html#ID449"><span class="std std-ref">Function Type</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この属性を適用することで、ある式の評価の延期を、自動的にその式を引数なしクロージャの中にラップすることによって行ってください。あなたはそれを、関数またはメソッドの宣言の中であるパラメータの持つ型へと適用します、あるパラメータでそれの型が関数型のものに対して、それは引数を取らずそしてそれは式の型のひとつの値を返すものです。<code class="docutils literal notranslate"><span class="pre">autoclosure</span></code>属性を使用する方法の例として、<a class="reference internal" href="../LanguageGuide/Closures.html#ID543"><span class="std std-ref">自動クロージャ</span></a>と<a class="reference internal" href="Types.html#ID449"><span class="std std-ref">関数型</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID600">
<h3>convention<a class="headerlink" href="#ID600" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to the type of a function to indicate its calling conventions.</span><!--end_enstr-->
<span class="jpstr">
この属性を関数の型に適用して、それの呼出規約を示してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">convention</span></code> attribute always appears with one of the following arguments:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">convention</span></code>属性は常に以下の引数の１つと共に現れます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">swift</span></code> argument indicates a Swift function reference. This is the standard calling convention for function values in Swift.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">swift</span></code>引数はあるスウィフト関数参照を指し示します。これは、スウィフトにおける関数値のための標準的な呼出規約です。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">block</span></code> argument indicates an Objective-C compatible block reference. The function value is represented as a reference to the block object, which is an <code class="docutils literal notranslate"><span class="pre">id</span></code>-compatible Objective-C object that embeds its invocation function within the object. The invocation function uses the C calling convention.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">block</span></code>引数は、Objective-C互換ブロック参照を指し示します。この関数値はそのブロックオブジェクトへの参照として表現されます、それは<code class="docutils literal notranslate"><span class="pre">id</span></code>互換Objective-Cオブジェクトで、それの呼出関数がそのオブジェクト内部に埋め込まれます。この呼出関数はC呼出規約を使います。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">c</span></code> argument indicates a C function reference. The function value carries no context and uses the C calling convention.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">c</span></code>引数は、C関数参照を指し示します。関数値は、コンテキストを持ち運びません、そしてC呼出規約を使います。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">With a few exceptions, a function of any calling convention can be used when a function any other calling convention is needed. A nongeneric global function, a local function that doesn’t capture any local variables, or a closure that doesn’t capture any local variables can be converted to the C calling convention. Other Swift functions can’t be converted to the C calling convention. A function with the Objective-C block calling convention can’t be converted to the C calling convention.</span><!--end_enstr-->
<span class="jpstr">
2、3の例外がありますが、何らかの呼出規約の関数は、何らかの他の呼出規約の関数が必要とされる場合に使用可能です。非総称体グローバル関数、何らローカル変数をキャプチャしないローカル関数、または何らローカル変数をキャプチャしないクロージャは、C呼出規約に変換されることが可能です。他のスウィフト関数は、C呼出規約に変換されることはできません。Objective-Cブロック呼出規約での関数は、C呼出規約に変換されることはできません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID601">
<h3>escaping<a class="headerlink" href="#ID601" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a parameter’s type in a function or method declaration to indicate that the parameter’s value can be stored for later execution. This means that the value is allowed to outlive the lifetime of the call. Function type parameters with the <code class="docutils literal notranslate"><span class="pre">escaping</span></code> type attribute require explicit use of <code class="docutils literal notranslate"><span class="pre">self.</span></code> for properties or methods. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">escaping</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">Escaping Closures</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この属性をパラメータのもつ型に対して関数やメソッドの宣言において適用して、そのパラメータのもつ値がその後の実行のために保管されることができるのを指し示してください。これは、その値が呼び出しのライフタイムより長生きするのを許されることを意味します。<code class="docutils literal notranslate"><span class="pre">escaping</span></code>型属性を持つ関数型パラメーターは、明示的な<code class="docutils literal notranslate"><span class="pre">self.</span></code>の使用をプロパティやメソッドに対して必要とします。<code class="docutils literal notranslate"><span class="pre">escaping</span></code>属性を使う方法の例として、<a class="reference internal" href="../LanguageGuide/Closures.html#ID546"><span class="std std-ref">脱出クロージャ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID604">
<h2><span class="enstr">Switch Case Attributes<a class="headerlink" href="#ID604" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
スイッチケース節属性<a class="headerlink" href="#ID604" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can apply switch case attributes to switch cases only.</span><!--end_enstr-->
<span class="jpstr">
あなたは、スイッチケース節属性をスイッチケース節のみに適用できます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID605">
<h3>unknown<a class="headerlink" href="#ID605" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">Apply this attribute to a switch case to indicate that it isn’t expected to be matched by any case of the enumeration that’s known at the time the code is compiled. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">unknown</span></code> attribute, see <a class="reference internal" href="Statements.html#ID602"><span class="std std-ref">Switching Over Future Enumeration Cases</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この属性をスイッチケース節に適用して、コードがコンパイルされる時点で既知である列挙のどんなケース節によってもそれが合致されることは期待されないことを指し示してください。<code class="docutils literal notranslate"><span class="pre">unknown</span></code>属性を使う方法の例のために、<a class="reference internal" href="Statements.html#ID602"><span class="std std-ref">未来列挙ケース節に対してスイッチする</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar">
<p class="first admonition-title"><span class="enstr">Grammar of an attribute</span><!--end_enstr-->
<span class="jpstr">
属性の文法
</span><!--end_jpstr-->
</p>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute"></a>attribute</span><span class="arrow"> → </span> <code>@</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attribute-name">attribute-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attribute-argument-clause">attribute-argument-clause</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute-name"></a>attribute-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attribute-argument-clause"></a>attribute-argument-clause</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_attributes"></a>attributes</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attribute">attribute</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub></p>
</div>
<div class="syntax-group">
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-tokens"></a>balanced-tokens</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-token">balanced-token</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token"></a>balanced-token</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>)</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1004"></a>balanced-token</span><span class="arrow"> → </span> <code>[</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>]</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1005"></a>balanced-token</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_balanced-tokens">balanced-tokens</a></span> <sub>opt</sub> <code>}</code></p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1006"></a>balanced-token</span><span class="arrow"> → </span><span class="enstr">Any identifier, keyword, literal, or operator</span><!--end_enstr-->
<span class="jpstr">
任意の識別子、キーワード、リテラル、または演算子
</span><!--end_jpstr-->
</p>
<p class="syntax-def"><span class="syntax-def-name"><a id="grammar_balanced-token_1007"></a>balanced-token</span><span class="arrow"> → </span><span class="enstr">Any punctuation except  <code>(</code>,  <code>)</code>,  <code>[</code>,  <code>]</code>,  <code>{</code>, or  <code>}</code></span><!--end_enstr-->
<span class="jpstr">
任意の句読点、しかし<code>(</code>,  <code>)</code>,  <code>[</code>,  <code>]</code>,  <code>{</code>, または  <code>}</code>を除く
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Declarations.html"><span class="enstr">Declarations</span><!--end_enstr-->
<span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Patterns.html"><span class="enstr">Patterns</span><!--end_enstr-->
<span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
