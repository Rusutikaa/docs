

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Declarations &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="AboutTheLanguageReference.html">About the Language Reference<br><span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="LexicalStructure.html">Lexical Structure<br><span class="jpstr">
語彙の構造
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Types.html">Types<br><span class="jpstr">
型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Expressions.html">Expressions<br><span class="jpstr">
式
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Statements.html">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Attributes.html">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Patterns.html">Patterns<br><span class="jpstr">
パターン
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="GenericParametersAndArguments.html">Generic Parameters and Arguments<br><span class="jpstr">
総称体パラメータと引数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="zzSummaryOfTheGrammar.html">Summary of the Grammar<br><span class="jpstr">
文法の概要
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Declarations<br><span class="jpstr">
宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID352">Top-Level Code<br><span class="jpstr">
トップレベル・コード
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID353">Code Blocks<br><span class="jpstr">
コード・ブロック
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID354">Import Declaration<br><span class="jpstr">
インポート宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID355">Constant Declaration<br><span class="jpstr">
定数宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID356">Variable Declaration<br><span class="jpstr">
変数の宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID357">Stored Variables and Stored Variable Properties<br><span class="jpstr">
格納変数と格納変数プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID358">Computed Variables and Computed Properties<br><span class="jpstr">
計算変数と計算プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID359">Stored Variable Observers and Property Observers<br><span class="jpstr">
格納された変数オブザーバーとプロパティオブザーバー
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID483">Type Variable Properties<br><span class="jpstr">
型変数プロパティ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID361">Type Alias Declaration<br><span class="jpstr">
型エイリアス宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID362">Function Declaration<br><span class="jpstr">
関数宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID471">Parameter Names<br><span class="jpstr">
パラメータ名
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID545">In-Out Parameters<br><span class="jpstr">
In-Outパラメータ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID472">Special Kinds of Parameters<br><span class="jpstr">
特別な種類のパラメータ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID473">Special Kinds of Methods<br><span class="jpstr">
特別な種類のメソッド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID530">Throwing Functions and Methods<br><span class="jpstr">
スローを行う関数とメソッド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID531">Rethrowing Functions and Methods<br><span class="jpstr">
再スローを行う関数とメソッド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID551">Functions that Never Return<br><span class="jpstr">
決して返らない関数
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID364">Enumeration Declaration<br><span class="jpstr">
列挙宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID365">Enumerations with Cases of Any Type<br><span class="jpstr">
随意の型のケース節をもつ列挙
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID537">Enumerations with Indirection<br><span class="jpstr">
間接参照を持つ列挙
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID366">Enumerations with Cases of a Raw-Value Type<br><span class="jpstr">
「生の値」型のケース節を持つ列挙
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID474">Accessing Enumeration Cases<br><span class="jpstr">
列挙ケース節にアクセスする
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID367">Structure Declaration<br><span class="jpstr">
構造体宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID368">Class Declaration<br><span class="jpstr">
クラス宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID369">Protocol Declaration<br><span class="jpstr">
プロトコル宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID370">Protocol Property Declaration<br><span class="jpstr">
プロトコルプロパティ宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID371">Protocol Method Declaration<br><span class="jpstr">
プロトコルメソッド宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID372">Protocol Initializer Declaration<br><span class="jpstr">
プロトコルイニシャライザ宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID373">Protocol Subscript Declaration<br><span class="jpstr">
プロトコル添え字宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID374">Protocol Associated Type Declaration<br><span class="jpstr">
プロトコル関連型宣言
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID375">Initializer Declaration<br><span class="jpstr">
イニシャライザ宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID376">Failable Initializers<br><span class="jpstr">
失敗できるイニシャライザ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID377">Deinitializer Declaration<br><span class="jpstr">
デイニシャライザ宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID378">Extension Declaration<br><span class="jpstr">
拡張宣言
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID576">Conditional Conformance<br><span class="jpstr">
条件準拠
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID577">Overridden Requirements Aren’t Used in Some Generic Contexts<br><span class="jpstr">
オーバーライドされた要件はいくつかの総称体文脈では使われません
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID578">Protocol Conformance Must Not Be Redundant<br><span class="jpstr">
プロトコル準拠は冗長であってはいけません
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID579">Resolving Explicit Redundancy<br><span class="jpstr">
明示的な冗長性を解決する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID580">Resolving Implicit Redundancy<br><span class="jpstr">
暗黙的な冗長性を解決する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#ID379">Subscript Declaration<br><span class="jpstr">
添え字宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID380">Operator Declaration<br><span class="jpstr">
演算子宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID550">Precedence Group Declaration<br><span class="jpstr">
優先順位グループ定義
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID381">Declaration Modifiers<br><span class="jpstr">
宣言修飾子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID382">Access Control Levels<br><span class="jpstr">
アクセス制御水準
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="declarations">
<h1>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a><br><span class="jpstr">
宣言<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p>A <em>declaration</em> introduces a new name or construct into your program. For example, you use declarations to introduce functions and methods, to introduce variables and constants, and to define enumeration, structure, class, and protocol types. You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.<br><span class="jpstr">
<em>宣言</em>は、新しい名前または構造物をあなたのプログラムに導入します。例えば、あなたは宣言を使うことで、関数やメソッドを導入したり、変数や定数を導入したり、そして列挙、構造体、クラス、そしてプロトコル型を定義します。あなたは、また、ある宣言を使うことで、既存の名前付きの型の振るまいを拡張することや、どこか他で宣言されるシンボルをあなたのプログラムへインポートすることができます。
</span><!--end_jpstr-->
</p>
<p>In Swift, most declarations are also definitions in the sense that they are implemented or initialized at the same time they are declared. That said, because protocols don’t implement their members, most protocol members are declarations only. For convenience and because the distinction isn’t that important in Swift, the term <em>declaration</em> covers both declarations and definitions.<br><span class="jpstr">
スウィフトにおいて、大部分の宣言はまた、それらが宣言されるのと同時にそれらが実装または初期化されるという意味で定義されます。とは言え、プロトコルがそれらのメンバーを実装しないので、大部分のプロトコル・メンバーは宣言だけです。便利さとその区別がスウィフトにおいてそんなに重要でないことから、用語<em>宣言</em>は、宣言と定義を含みます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a declaration<br><span class="jpstr">
宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-declaration">import-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1008"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_constant-declaration">constant-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1009"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration">variable-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1010"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-declaration">typealias-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1011"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-declaration">function-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1012"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_enum-declaration">enum-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1013"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-declaration">struct-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1014"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-declaration">class-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1015"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-declaration">protocol-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1016"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-declaration">initializer-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1017"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_deinitializer-declaration">deinitializer-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1018"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_extension-declaration">extension-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1019"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-declaration">subscript-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1020"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_operator-declaration">operator-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration_1021"></a>declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-declaration">precedence-group-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declarations"></a>declarations</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declarations">declarations</a></span> <sub>opt</sub></p></div></div><div class="section" id="ID352">
<h2>Top-Level Code<a class="headerlink" href="#ID352" title="Permalink to this headline">¶</a><br><span class="jpstr">
トップレベル・コード<a class="headerlink" href="#ID352" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions. By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that is part of the same module. You can override this default behavior by marking the declaration with an access-level modifier, as described in <a class="reference internal" href="#ID382"><span class="std std-ref">Access Control Levels</span></a>.<br><span class="jpstr">
あるスウィフトソースコードにおけるトップレベル・コードは、０個以上の文、宣言、そして式から成ります。初期状態では、あるソースファイルのトップレベルで宣言される変数、定数、そして他の名前をつけられる宣言は、同じモジュールの一部であるすべてのソースファイルの中のコードにアクセス可能です。あなたは、<a class="reference internal" href="#ID382"><span class="std std-ref">アクセス制御ラベル</span></a>で記述されるように、この初期状態のふるまいをその宣言をアクセス水準修飾子で印することによってオーバーライドすることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a top-level declaration<br><span class="jpstr">
トップレベル宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_top-level-declaration"></a>top-level-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_statements">statements</a></span> <sub>opt</sub></p></div></div></div>
<div class="section" id="ID353">
<h2>Code Blocks<a class="headerlink" href="#ID353" title="Permalink to this headline">¶</a><br><span class="jpstr">
コード・ブロック<a class="headerlink" href="#ID353" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>code block</em> is used by a variety of declarations and control structures to group statements together. It has the following form:<br><span class="jpstr">
<em>コード・ブロック</em>は、いくつかの文をまとめるために、いろいろな宣言や制御構造で使われます。それは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>{
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>statements</em> inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.<br><span class="jpstr">
コード・ブロックの内側の<em>文</em>は、宣言、式、そして他の種類の文を含みます、そしてソース・コードにおいてそれらの現れる順に実行されます。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a code block<br><span class="jpstr">
コードブロックの文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_code-block"></a>code-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_statements">statements</a></span> <sub>opt</sub> <code>}</code></p></div></div></div>
<div class="section" id="ID354">
<h2>Import Declaration<a class="headerlink" href="#ID354" title="Permalink to this headline">¶</a><br><span class="jpstr">
インポート宣言<a class="headerlink" href="#ID354" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>An <em>import declaration</em> lets you access symbols that are declared outside the current file. The basic form imports the entire module; it consists of the <code class="docutils literal notranslate"><span class="pre">import</span></code> keyword followed by a module name:<br><span class="jpstr">
<em>インポート宣言</em>は、あなたに現在のファイルの外側で宣言されるシンボルにアクセスさせます。基本の形式は、そのモジュール全体をインポートします；それは、<code class="docutils literal notranslate"><span class="pre">import</span></code>キーワードとそれに続くモジュール名から成ります：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">import</span> <span class="gi">module</span>
</li></ol></div></div></div>
<p>Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule. When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.<br><span class="jpstr">
より詳細な記述を提供することは、どのシンボルがインポートされるかを制限します ― あなたは、あるモジュールまたはサブモジュール内で、特定のサブモジュールまたは特定の宣言を指定することができます。この詳細な書式が使われるとき、インポートされたシンボルだけが（そしてそれを宣言するモジュールでなく）、現在のスコープにおいて利用可能にされます。
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">import</span> <span class="gi">import kind</span> <span class="gi">module</span>.<span class="gi">symbol name</span>
</li><li><span class="k">import</span> <span class="gi">module</span>.<span class="gi">submodule</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an import declaration<br><span class="jpstr">
インポート宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_import-declaration"></a>import-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>import</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-kind">import-kind</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-path">import-path</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_import-kind"></a>import-kind</span><span class="arrow"> → </span> <code>typealias</code> |  <code>struct</code> |  <code>class</code> |  <code>enum</code> |  <code>protocol</code> |  <code>let</code> |  <code>var</code> |  <code>func</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_import-path"></a>import-path</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-path-identifier">import-path-identifier</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-path-identifier">import-path-identifier</a></span>  <code>.</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_import-path">import-path</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_import-path-identifier"></a>import-path-identifier</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p></div></div></div>
<div class="section" id="ID355">
<h2>Constant Declaration<a class="headerlink" href="#ID355" title="Permalink to this headline">¶</a><br><span class="jpstr">
定数宣言<a class="headerlink" href="#ID355" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>constant declaration</em> introduces a constant named value into your program. Constant declarations are declared using the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword and have the following form:<br><span class="jpstr">
<em>定数宣言</em>は、名前をつけられた一定不変の値をあなたのプログラムにもたらします。定数宣言は、<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードを使用して宣言され、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="gi">constant name</span>: <span class="gi">type</span> = <span class="gi">expression</span>
</li></ol></div></div></div>
<p>A constant declaration defines an immutable binding between the <em>constant name</em> and the value of the initializer <em>expression</em>; after the value of a constant is set, it cannot be changed. That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can’t.<br><span class="jpstr">
定数宣言は、<em>定数名</em>とイニシャライザ<em>式</em>の値の間の不変の束縛を定義します；定数の値が設定されたあと、それは変わることができません。そうは言っても、定数がクラスオブジェクトで初期化されるならば、そのオブジェクト自体は変わることができます、しかし、定数名とそれが言及するオブジェクトの間の束縛はそうすることができません。
</span><!--end_jpstr-->
</p>
<p>When a constant is declared at global scope, it must be initialized with a value. When a constant declaration occurs in the context of a function or method, it can be initialized later, as long as it is guaranteed to have a value set before the first time its value is read. When a constant declaration occurs in the context of a class or structure declaration, it is considered a <em>constant property</em>. Constant declarations are not computed properties and therefore do not have getters or setters.<br><span class="jpstr">
定数がグローバルなスコープで宣言されるとき、それはひとつの値で初期化されなければなりません。定数宣言が関数またはメソッドの文脈において現れるとき、それは後で初期化されることができます、それがある値をその値が読み出される最初の時の前に設定されてしまっているよう保証する限りは。定数宣言がクラスまたは構造体宣言の文脈において起こるとき、それは<em>定数プロパティ</em>とみなされます。定数宣言は、計算プロパティではなく、したがって、ゲッターまたはセッターを持ちません。
</span><!--end_jpstr-->
</p>
<p>If the <em>constant name</em> of a constant declaration is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer <em>expression</em>.<br><span class="jpstr">
定数宣言の<em>定数名</em>がタプルパターンであるならば、タプルの中の各項目の名前は、イニシャライザ<em>式</em>の中の対応する値に縛りつけられます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> (<span class="nv">firstNumber</span>, <span class="nv">secondNumber</span>) = (<span class="m">10</span>, <span class="m">42</span>)
</li></ol></div></div></div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">firstNumber</span></code> is a named constant for the value <code class="docutils literal notranslate"><span class="pre">10</span></code>, and <code class="docutils literal notranslate"><span class="pre">secondNumber</span></code> is a named constant for the value <code class="docutils literal notranslate"><span class="pre">42</span></code>. Both constants can now be used independently:<br><span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">firstNumber</span></code>は、値<code class="docutils literal notranslate"><span class="pre">10</span></code>のための名前をつけられた定数です、そして、<code class="docutils literal notranslate"><span class="pre">secondNumber</span></code>は値<code class="docutils literal notranslate"><span class="pre">42</span></code>のための名前をつけられた定数です。両方の定数は、今や独立して使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">&quot;The first number is </span>\<span class="p">(</span><span class="nv">firstNumber</span><span class="p">)</span><span class="s">.&quot;</span>)
</li><li><span class="c">// Prints &quot;The first number is 10.&quot;&nbsp;<span class="jpstr">（「最初の数は、10です。」を出力します）</span><!--end_jpstr-->
</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;The second number is </span>\<span class="p">(</span><span class="nv">secondNumber</span><span class="p">)</span><span class="s">.&quot;</span>)
</li><li><span class="c">// Prints &quot;The second number is 42.&quot;&nbsp;<span class="jpstr">（２番目の数は、42です。」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>The type annotation (<code class="docutils literal notranslate"><span class="pre">:</span></code> <em>type</em>) is optional in a constant declaration when the type of the <em>constant name</em> can be inferred, as described in <a class="reference internal" href="Types.html#ID457"><span class="std std-ref">Type Inference</span></a>.<br><span class="jpstr">
<em>定数名</em>の型が推論されることができるとき、<a class="reference internal" href="Types.html#ID457"><span class="std std-ref">型推論</span></a>で記述されるように、型注釈（<code class="docutils literal notranslate"><span class="pre">:</span></code> <em>type</em>）は定数宣言において任意です。
</span><!--end_jpstr-->
</p>
<p>To declare a constant type property, mark the declaration with the <code class="docutils literal notranslate"><span class="pre">static</span></code> declaration modifier. Type properties are discussed in <a class="reference internal" href="../LanguageGuide/Properties.html#ID264"><span class="std std-ref">Type Properties</span></a>.<br><span class="jpstr">
定数型プロパティを宣言するために、宣言に<code class="docutils literal notranslate"><span class="pre">static</span></code>宣言修飾子で印をつけてください。型プロパティは、<a class="reference internal" href="../LanguageGuide/Properties.html#ID264"><span class="std std-ref">型プロパティ</span></a>で議論されます。
</span><!--end_jpstr-->
</p>
<p>For more information about constants and for guidance about when to use them, see <a class="reference internal" href="../LanguageGuide/TheBasics.html#ID310"><span class="std std-ref">Constants and Variables</span></a> and <a class="reference internal" href="../LanguageGuide/Properties.html#ID255"><span class="std std-ref">Stored Properties</span></a>.<br><span class="jpstr">
定数の詳細について、そしていつそれらを使うべきかの手引きとして、<a class="reference internal" href="../LanguageGuide/TheBasics.html#ID310"><span class="std std-ref">定数と変数</span></a>および<a class="reference internal" href="../LanguageGuide/Properties.html#ID255"><span class="std std-ref">格納プロパティ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a constant declaration<br><span class="jpstr">
定数宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_constant-declaration"></a>constant-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>let</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_pattern-initializer-list">pattern-initializer-list</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_pattern-initializer-list"></a>pattern-initializer-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_pattern-initializer">pattern-initializer</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_pattern-initializer">pattern-initializer</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_pattern-initializer-list">pattern-initializer-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_pattern-initializer"></a>pattern-initializer</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Patterns.html#grammar_pattern">pattern</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer">initializer</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer"></a>initializer</span><span class="arrow"> → </span> <code>=</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p></div></div></div>
<div class="section" id="ID356">
<h2>Variable Declaration<a class="headerlink" href="#ID356" title="Permalink to this headline">¶</a><br><span class="jpstr">
変数の宣言<a class="headerlink" href="#ID356" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>variable declaration</em> introduces a variable named value into your program and is declared using the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword.<br><span class="jpstr">
<em>変数宣言</em>は、名前をつけられた変えられる値をあなたのプログラムにもたらします、そしてキーワード<code class="docutils literal notranslate"><span class="pre">var</span></code>を使って宣言されます。
</span><!--end_jpstr-->
</p>
<p>Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties. The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.<br><span class="jpstr">
変数宣言はいくつかの形式を持ちます、それらは、格納および計算の変数およびプロパティ、格納である変数およびプロパティのオブザーバー、そして静的変数プロパティを含む、異なる種類の名前をつけられた可変の値を宣言します。使用するのに適切な形式は、その変数が宣言されるスコープとあなたが宣言するつもりである変数の種類に依存します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">You can also declare properties in the context of a protocol declaration, as described in <a class="reference internal" href="#ID370"><span class="std std-ref">Protocol Property Declaration</span></a>.<br><span class="jpstr">
<a class="reference internal" href="#ID370"><span class="std std-ref">プロトコルプロパティ宣言</span></a>で記述されるように、あなたはまた、プロトコル宣言の文脈において、プロパティを宣言することができます。
</span><!--end_jpstr-->
</p>
</div>
<p>You can override a property in a subclass by marking the subclass’s property declaration with the <code class="docutils literal notranslate"><span class="pre">override</span></code> declaration modifier, as described in <a class="reference internal" href="../LanguageGuide/Inheritance.html#ID196"><span class="std std-ref">Overriding</span></a>.<br><span class="jpstr">
あなたは、<a class="reference internal" href="../LanguageGuide/Inheritance.html#ID196"><span class="std std-ref">オーバーライド</span></a>で記述されるように、、サブクラスのプロパティ宣言を<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印することによってサブクラスの中のプロパティをオーバーライドすることができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID357">
<h3>Stored Variables and Stored Variable Properties<a class="headerlink" href="#ID357" title="Permalink to this headline">¶</a><br><span class="jpstr">
格納変数と格納変数プロパティ<a class="headerlink" href="#ID357" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The following form declares a stored variable or stored variable property:<br><span class="jpstr">
以下の形式は、格納変数または格納変数プロパティを宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="gi">variable name</span>: <span class="gi">type</span> = <span class="gi">expression</span>
</li></ol></div></div></div>
<p>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a <em>stored variable</em>. When it is declared in the context of a class or structure declaration, it is referred to as a <em>stored variable property</em>.<br><span class="jpstr">
あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは<em>格納変数</em>と呼ばれます。それがクラスまたは構造体宣言の文脈において宣言されるとき、それは<em>格納変数プロパティ</em>と呼ばれます。
</span><!--end_jpstr-->
</p>
<p>The initializer <em>expression</em> can’t be present in a protocol declaration, but in all other contexts, the initializer <em>expression</em> is optional. That said, if no initializer <em>expression</em> is present, the variable declaration must include an explicit type annotation (<code class="docutils literal notranslate"><span class="pre">:</span></code> <em>type</em>).<br><span class="jpstr">
イニシャライザ<em>式</em>はプロトコル宣言に含まれることはできません、しかし全ての他の文脈ではそうではありません、イニシャライザ<em>式</em>は任意です。とは言え、イニシャライザ<em>式</em>が存在しないならば、変数の宣言は明確な型注釈（<code class="docutils literal notranslate"><span class="pre">:</span></code> <em>type</em>）を含まなければなりません。
</span><!--end_jpstr-->
</p>
<p>As with constant declarations, if the <em>variable name</em> is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer <em>expression</em>.<br><span class="jpstr">
定数宣言と同様に、<em>変数名</em>がタプルパターンであるならば、タプルの中の各項目の名前はイニシャライザ<em>式</em>の対応する値に縛りつけられます。
</span><!--end_jpstr-->
</p>
<p>As their names suggest, the value of a stored variable or a stored variable property is stored in memory.<br><span class="jpstr">
それらの名前が示すように、格納変数または格納変数プロパティの値はメモリに格納されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID358">
<h3>Computed Variables and Computed Properties<a class="headerlink" href="#ID358" title="Permalink to this headline">¶</a><br><span class="jpstr">
計算変数と計算プロパティ<a class="headerlink" href="#ID358" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The following form declares a computed variable or computed property:<br><span class="jpstr">
以下の形式は、計算変数または計算プロパティを宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="gi">variable name</span>: <span class="gi">type</span> {
</li><li>    <span class="k">get</span> {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>    <span class="k">set</span>(<span class="gi">setter name</span>) {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a <em>computed variable</em>. When it is declared in the context of a class, structure, or extension declaration, it is referred to as a <em>computed property</em>.<br><span class="jpstr">
あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラス、構造体、列挙、および拡張宣言の文脈において定義します。この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは<em>計算変数</em>と呼ばれます。それがクラス、構造体、または拡張宣言の文脈において宣言されるとき、それは<em>計算プロパティ</em>と呼ばれます。
</span><!--end_jpstr-->
</p>
<p>The getter is used to read the value, and the setter is used to write the value. The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in <a class="reference internal" href="../LanguageGuide/Properties.html#ID261"><span class="std std-ref">Read-Only Computed Properties</span></a>. But if you provide a setter clause, you must also provide a getter clause.<br><span class="jpstr">
ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。セッター節は任意です、そして、ゲッターだけが必要なとき、あなたは両方の節を省略することができます、そして<a class="reference internal" href="../LanguageGuide/Properties.html#ID261"><span class="std std-ref">読み出し専用の計算プロパティ</span></a>で記述されるように、単に直接に要請された値を返すことができます。しかしあなたがセッター節を提供するならば、あなた同様にゲッター節を提供しなければなりません。
</span><!--end_jpstr-->
</p>
<p>The <em>setter name</em> and enclosing parentheses is optional. If you provide a setter name, it is used as the name of the parameter to the setter. If you do not provide a setter name, the default parameter name to the setter is <code class="docutils literal notranslate"><span class="pre">newValue</span></code>, as described in <a class="reference internal" href="../LanguageGuide/Properties.html#ID260"><span class="std std-ref">Shorthand Setter Declaration</span></a>.<br><span class="jpstr">
<em>セッター名</em>、そして囲んでいる丸括弧は任意です。あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。あなたがセッター名を提供しないならば、<a class="reference internal" href="../LanguageGuide/Properties.html#ID260"><span class="std std-ref">短縮形セッター宣言</span></a>で記述されるように、セッターへの省略時のパラメータ名は<code class="docutils literal notranslate"><span class="pre">newValue</span></code>です。
</span><!--end_jpstr-->
</p>
<p>Unlike stored named values and stored variable properties, the value of a computed named value or a computed property is not stored in memory.<br><span class="jpstr">
格納される名前を付けられた値および格納変数プロパティと違って、計算される名前を付けられた値または計算プロパティの値は、メモリに格納されません。
</span><!--end_jpstr-->
</p>
<p>For more information and to see examples of computed properties, see <a class="reference internal" href="../LanguageGuide/Properties.html#ID259"><span class="std std-ref">Computed Properties</span></a>.<br><span class="jpstr">
より多くの情報のために、そして、<a class="reference internal" href="../LanguageGuide/Properties.html#ID259"><span class="std std-ref">計算プロパティ</span></a>の例を見るために、計算プロパティを見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID359">
<h3>Stored Variable Observers and Property Observers<a class="headerlink" href="#ID359" title="Permalink to this headline">¶</a><br><span class="jpstr">
格納された変数オブザーバーとプロパティオブザーバー<a class="headerlink" href="#ID359" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>You can also declare a stored variable or property with <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers. A stored variable or property declared with observers has the following form:<br><span class="jpstr">
あなたは、また、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーをもつ格納変数やプロパティを宣言することができます。オブザーバーとともに宣言される格納変数やプロパティは、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="gi">variable name</span>: <span class="gi">type</span> = <span class="gi">expression</span> {
</li><li>    <span class="k">willSet</span>(<span class="gi">setter name</span>) {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>    <span class="k">didSet</span>(<span class="gi">setter name</span>) {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration. When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as <em>stored variable observers</em>. When it is declared in the context of a class or structure declaration, the observers are referred to as <em>property observers</em>.<br><span class="jpstr">
あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。この形式の変数の宣言がグローバルなスコープまたは関数のローカルスコープで宣言されるとき、オブザーバーは<em>格納変数オブザーバー</em>と呼ばれます。それがクラスまたは構造体宣言の文脈において宣言されるとき、オブザーバーは<em>プロパティオブザーバー</em>と呼ばれます。
</span><!--end_jpstr-->
</p>
<p>You can add property observers to any stored property. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in <a class="reference internal" href="../LanguageGuide/Inheritance.html#ID201"><span class="std std-ref">Overriding Property Observers</span></a>.<br><span class="jpstr">
あなたは、プロパティオブザーバーをどんな格納プロパティにでも加えることができます。あなたは、また、プロパティオブザーバーをあらゆる継承されたプロパティ（格納されるか、計算されるかに関係なく）にでも加えることが、サブクラスの内部でプロパティをオーバーライドすることによって、<a class="reference internal" href="../LanguageGuide/Inheritance.html#ID201"><span class="std std-ref">プロパティオブザーバーのオーバーライド</span></a>で記述されるように、可能です。
</span><!--end_jpstr-->
</p>
<p>The initializer <em>expression</em> is optional in the context of a class or structure declaration, but required elsewhere. The <em>type</em> annotation is optional when the type can be inferred from the initializer <em>expression</em>.<br><span class="jpstr">
イニシャライザ<em>式</em>は、クラスまたは構造体宣言の文脈では任意です、しかしその他では必須です。<em>型</em>注釈は、その型が初期化<em>式</em>から推論されることができる場合は随意です。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set. The observers are not called when the variable or property is first initialized. Instead, they are called only when the value is set outside of an initialization context.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、変数またはプロパティの値が設定されている時に監視する（そして適切に応答する）方法を提供します。オブザーバーは、変数またはプロパティが最初に初期化されるときには呼ばれません。そうではなく、値が初期化の文脈の外で設定されるときにだけ、それらは呼ばれます。
</span><!--end_jpstr-->
</p>
<p>A <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer is called just before the value of the variable or property is set. The new value is passed to the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer as a constant, and therefore it can’t be changed in the implementation of the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> clause. The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer is called immediately after the new value is set. In contrast to the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer, the old value of the variable or property is passed to the <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer in case you still need access to it. That said, if you assign a value to a variable or property within its own <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer clause, that new value that you assign will replace the one that was just set and passed to the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーは、変数またはプロパティの値が設定される直前に呼ばれます。新しい値は、定数として<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーに渡されます、したがって、それ<code class="docutils literal notranslate"><span class="pre">はwillSet</span></code>節の実装の中で変更されることができません。<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、新しい値が設定された直後に呼ばれます。<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーと対照的に、変数またはプロパティの古い値が、あなたがまだそれへのアクセスを必要とする場合に備えて<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーに渡されます。とは言え、あなたが<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバー節自身の内部である値を変数またはプロパティに代入するならば、あなたが代入するその新しい値は、ちょうど設定されたばかりの<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーに渡されたものを置き換えることになります。
</span><!--end_jpstr-->
</p>
<p>The <em>setter name</em> and enclosing parentheses in the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> clauses are optional. If you provide setter names, they are used as the parameter names to the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers. If you do not provide setter names, the default parameter name to the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer is <code class="docutils literal notranslate"><span class="pre">newValue</span></code> and the default parameter name to the <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer is <code class="docutils literal notranslate"><span class="pre">oldValue</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>節の中の<em>セッター名</em>と囲んでいる丸括弧は任意です。あなたがセッター名を提供するならば、それらが<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーへのパラメータ名として使われます。あなたがセッター名を提供しないならば、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーへの初期状態でのパラメータ名は<code class="docutils literal notranslate"><span class="pre">newValue</span></code>です、そして、<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーへの初期状態でのパラメータ名は<code class="docutils literal notranslate"><span class="pre">oldValue</span></code>です。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> clause is optional when you provide a <code class="docutils literal notranslate"><span class="pre">willSet</span></code> clause. Likewise, the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> clause is optional when you provide a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> clause.<br><span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">willSet</span></code>節を提供するとき、<code class="docutils literal notranslate"><span class="pre">didSet</span></code>節は任意です。同様に、あなたが<code class="docutils literal notranslate"><span class="pre">didSet</span></code>節を提供するとき、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>節は任意です。
</span><!--end_jpstr-->
</p>
<p>For more information and to see an example of how to use property observers, see <a class="reference internal" href="../LanguageGuide/Properties.html#ID262"><span class="std std-ref">Property Observers</span></a>.<br><span class="jpstr">
より多くの情報のために、そして、プロパティオブザーバーを使う方法の例を見るために、<a class="reference internal" href="../LanguageGuide/Properties.html#ID262"><span class="std std-ref">プロパティオブザーバー</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID483">
<h3>Type Variable Properties<a class="headerlink" href="#ID483" title="Permalink to this headline">¶</a><br><span class="jpstr">
型変数プロパティ<a class="headerlink" href="#ID483" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>To declare a type variable property, mark the declaration with the <code class="docutils literal notranslate"><span class="pre">static</span></code> declaration modifier. Classes may mark type computed properties with the <code class="docutils literal notranslate"><span class="pre">class</span></code> declaration modifier instead to allow subclasses to override the superclass’s implementation. Type properties are discussed in <a class="reference internal" href="../LanguageGuide/Properties.html#ID264"><span class="std std-ref">Type Properties</span></a>.<br><span class="jpstr">
型変数プロパティを宣言するために、宣言に<code class="docutils literal notranslate"><span class="pre">static</span></code>宣言修飾子で印をつけてください。クラスは型計算プロパティを代わりに<code class="docutils literal notranslate"><span class="pre">class</span></code>宣言修飾子で印をつけて、サブクラスがスーパークラスの実装をオーバーライドすることを許可することができます。型プロパティは、<a class="reference internal" href="../LanguageGuide/Properties.html#ID264"><span class="std std-ref">型プロパティ</span></a>で議論されます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">In a class declaration, the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword has the same effect as marking the declaration with both the <code class="docutils literal notranslate"><span class="pre">class</span></code> and <code class="docutils literal notranslate"><span class="pre">final</span></code> declaration modifiers.<br><span class="jpstr">
クラス宣言において、キーワード<code class="docutils literal notranslate"><span class="pre">static</span></code>は宣言を<code class="docutils literal notranslate"><span class="pre">class</span></code>と<code class="docutils literal notranslate"><span class="pre">final</span></code>宣言修飾子の両方で印することと同じ効果を持ちます。
</span><!--end_jpstr-->
</p>
</div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a variable declaration<br><span class="jpstr">
変数宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_pattern-initializer-list">pattern-initializer-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration_1022"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration_1023"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-block">getter-setter-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration_1024"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-keyword-block">getter-setter-keyword-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration_1025"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer">initializer</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_willSet-didSet-block">willSet-didSet-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration_1026"></a>variable-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer">initializer</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_willSet-didSet-block">willSet-didSet-block</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-declaration-head"></a>variable-declaration-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>var</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_variable-name"></a>variable-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-setter-block"></a>getter-setter-block</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-setter-block_1027"></a>getter-setter-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-clause">getter-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-clause">setter-clause</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-setter-block_1028"></a>getter-setter-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-clause">setter-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-clause">getter-clause</a></span>  <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-clause"></a>getter-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_mutation-modifier">mutation-modifier</a></span> <sub>opt</sub> <code>get</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_setter-clause"></a>setter-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_mutation-modifier">mutation-modifier</a></span> <sub>opt</sub> <code>set</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-name">setter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_setter-name"></a>setter-name</span><span class="arrow"> → </span> <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  <code>)</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-setter-keyword-block"></a>getter-setter-keyword-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-keyword-clause">getter-keyword-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-keyword-clause">setter-keyword-clause</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-setter-keyword-block_1029"></a>getter-setter-keyword-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-keyword-clause">setter-keyword-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-keyword-clause">getter-keyword-clause</a></span>  <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_getter-keyword-clause"></a>getter-keyword-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_mutation-modifier">mutation-modifier</a></span> <sub>opt</sub> <code>get</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_setter-keyword-clause"></a>setter-keyword-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_mutation-modifier">mutation-modifier</a></span> <sub>opt</sub> <code>set</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_willSet-didSet-block"></a>willSet-didSet-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_willSet-clause">willSet-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_didSet-clause">didSet-clause</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_willSet-didSet-block_1030"></a>willSet-didSet-block</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_didSet-clause">didSet-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_willSet-clause">willSet-clause</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_willSet-clause"></a>willSet-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>willSet</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-name">setter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_didSet-clause"></a>didSet-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>didSet</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_setter-name">setter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p></div></div></div>
</div>
<div class="section" id="ID361">
<h2>Type Alias Declaration<a class="headerlink" href="#ID361" title="Permalink to this headline">¶</a><br><span class="jpstr">
型エイリアス宣言<a class="headerlink" href="#ID361" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>type alias declaration</em> introduces a named alias of an existing type into your program. Type alias declarations are declared using the <code class="docutils literal notranslate"><span class="pre">typealias</span></code> keyword and have the following form:<br><span class="jpstr">
<em>型エイリアス宣言</em>は、あなたのプログラムに既存の型の名前をつけられたエイリアスを導入します。型エイリアス宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">typealias</span></code>を使って宣言されます、そして以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="gi">name</span> = <span class="gi">existing type</span>
</li></ol></div></div></div>
<p>After a type alias is declared, the aliased <em>name</em> can be used instead of the <em>existing type</em> everywhere in your program. The <em>existing type</em> can be a named type or a compound type. Type aliases do not create new types; they simply allow a name to refer to an existing type.<br><span class="jpstr">
型エイリアスが宣言されたあと、エイリアス（別名）にされた<em>名前</em>は、あなたのプログラムの至る所で<em>既存の型</em>の代わりに使われることができます。<em>既存の型</em>は、名前付きの型または複合の型でありえます。型エイリアスは、新しい型を作成しません；それらは、単にある名前が既存の型に言及できるようにします。
</span><!--end_jpstr-->
</p>
<p>A type alias declaration can use generic parameters to give a name to an existing generic type. The type alias can provide concrete types for some or all of the generic parameters of the existing type. For example:<br><span class="jpstr">
型エイリアス宣言は、総称体パラメータを使ってある名前を既存の総称体型に与えることができます。型エイリアスは、既存の型の総称体パラメータの一部またはすべてに具象型を提供できます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">StringDictionary</span>&lt;<span class="nv">Value</span>&gt; = <span class="nc">Dictionary</span>&lt;<span class="nc">String</span>, <span class="nc">Value</span>&gt;
</li><li>
</li><li><span class="c">// The following dictionaries have the same type.&nbsp;<span class="jpstr">（以下の辞書は同じ型を持ちます。）</span><!--end_jpstr-->
</span>
</li><li><span class="k">var</span> <span class="nv">dictionary1</span>: <span class="nc">StringDictionary</span>&lt;<span class="nc">Int</span>&gt; = [:]
</li><li><span class="k">var</span> <span class="nv">dictionary2</span>: <span class="nc">Dictionary</span>&lt;<span class="nc">String</span>, <span class="nc">Int</span>&gt; = [:]
</li></ol></div></div></div>
<p>When a type alias is declared with generic parameters, the constraints on those parameters must match exactly the constraints on the existing type’s generic parameters. For example:<br><span class="jpstr">
ある型エイリアスが総称体パラメータで宣言されるとき、それらのパラメータ上の制約は厳密に既存の型の持つ総称体パラメータ上の制約に一致しなければなりません。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">DictionaryOfInts</span>&lt;<span class="nv">Key</span>: <span class="nc">Hashable</span>&gt; = <span class="nc">Dictionary</span>&lt;<span class="nc">Key</span>, <span class="nc">Int</span>&gt;
</li></ol></div></div></div>
<p>Because the type alias and the existing type can be used interchangeably, the type alias can’t introduce additional generic constraints.<br><span class="jpstr">
型エイリアスと既存の型は交換可能に使われることができるので、型エイリアスは追加的な総称体制約を導入することはできません。
</span><!--end_jpstr-->
</p>
<p>A type alias can forward an existing type’s generic parameters by omitting all generic parameters from the declaration. For example, the <code class="docutils literal notranslate"><span class="pre">Diccionario</span></code> type alias declared here has the same generic parameters and constraints as <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>.<br><span class="jpstr">
型エイリアスは、既存の型の持つ総称体パラメータを、全ての総称体パラメータを宣言から省略することによって、転送できます。例えば、ここで宣言される<code class="docutils literal notranslate"><span class="pre">Diccionario</span></code>型エイリアスは、<code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>と同じ総称体パラメータと制約を持ちます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">typealias</span> <span class="nv">Diccionario</span> = <span class="nc">Dictionary</span>
</li></ol></div></div></div>
<p>Inside a protocol declaration, a type alias can give a shorter and more convenient name to a type that is used frequently. For example:<br><span class="jpstr">
プロトコル宣言の内部で、型エイリアスはより短くより便利な名前を頻繁に使われる型に提供できます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Sequence</span> {
</li><li>    <span class="k">associatedtype</span> <span class="nv">Iterator</span>: <span class="nc">IteratorProtocol</span>
</li><li>    <span class="k">typealias</span> <span class="nv">Element</span> = <span class="nc">Iterator</span>.<span class="nc">Element</span>
</li><li>}
</li><li>
</li><li><span class="k">func</span> <span class="nv">sum</span>&lt;<span class="nv">T</span>: <span class="nc">Sequence</span>&gt;(<span class="k">_</span> <span class="nv">sequence</span>: <span class="nc">T</span>) -&gt; <span class="nc">Int</span> <span class="k">where</span> <span class="nc">T</span>.<span class="nc">Element</span> == <span class="nc">Int</span> {
</li><li>    <span class="c">// ...</span>
</li><li>}
</li></ol></div></div></div>
<p>Without this type alias, the <code class="docutils literal notranslate"><span class="pre">sum</span></code> function would have to refer to the associated type as <code class="docutils literal notranslate"><span class="pre">T.Iterator.Element</span></code> instead of <code class="docutils literal notranslate"><span class="pre">T.Element</span></code>.<br><span class="jpstr">
この型エイリアスな時では、<code class="docutils literal notranslate"><span class="pre">sum</span></code>関数は関連値を<code class="docutils literal notranslate"><span class="pre">T.Iterator.Element</span></code>のように参照しなければならないでしょう、<code class="docutils literal notranslate"><span class="pre">T.Element</span></code>ではなく。
</span><!--end_jpstr-->
</p>
<p>See also <a class="reference internal" href="#ID374"><span class="std std-ref">Protocol Associated Type Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID374"><span class="std std-ref">プロトコル関連型宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a type alias declaration<br><span class="jpstr">
型エイリアス宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_typealias-declaration"></a>typealias-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>typealias</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-name">typealias-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-assignment">typealias-assignment</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_typealias-name"></a>typealias-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_typealias-assignment"></a>typealias-assignment</span><span class="arrow"> → </span> <code>=</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p></div></div></div>
<div class="section" id="ID362">
<h2>Function Declaration<a class="headerlink" href="#ID362" title="Permalink to this headline">¶</a><br><span class="jpstr">
関数宣言<a class="headerlink" href="#ID362" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>function declaration</em> introduces a function or method into your program. A function declared in the context of class, structure, enumeration, or protocol is referred to as a <em>method</em>. Function declarations are declared using the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword and have the following form:<br><span class="jpstr">
<em>関数宣言</em>は、あなたのプログラムに関数またはメソッドをもたらします。クラス、構造体、列挙、またはプロトコルの文脈において宣言される関数は、<em>メソッド</em>として言及されることができます。関数宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">func</span></code>を使って宣言されます、そして以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="gi">function name</span>(<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>If the function has a return type of <code class="docutils literal notranslate"><span class="pre">Void</span></code>, the return type can be omitted as follows:<br><span class="jpstr">
関数が<code class="docutils literal notranslate"><span class="pre">Void</span></code>の戻り型を持つならば、次のように戻り型は省略されることができます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="gi">function name</span>(<span class="gi">parameters</span>) {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>The type of each parameter must be included—it can’t be inferred. If you write <code class="docutils literal notranslate"><span class="pre">inout</span></code> in front of a parameter’s type, the parameter can be modified inside the scope of the function. In-out parameters are discussed in detail in <a class="reference internal" href="#ID545"><span class="std std-ref">In-Out Parameters</span></a>, below.<br><span class="jpstr">
各パラメータの型は、含められなければなりません ― それは、推論されることができません。あなたが<code class="docutils literal notranslate"><span class="pre">inout</span></code>をパラメータの型のすぐ前に書くならば、そのパラメータは関数のスコープ内部において修正されることができます。in-outパラメータは詳細に、下で、<a class="reference internal" href="#ID545"><span class="std std-ref">in-outパラメータ</span></a>において議論されます。
</span><!--end_jpstr-->
</p>
<p>Functions can return multiple values using a tuple type as the return type of the function.<br><span class="jpstr">
関数は、関数の戻り型としてタプル型を使って、複数の値を返すことができます。
</span><!--end_jpstr-->
</p>
<p>A function definition can appear inside another function declaration. This kind of function is known as a <em>nested function</em>.<br><span class="jpstr">
関数定義は、別の関数宣言の内部に現れることができます。この種類の関数は、<em>入れ子にされた関数</em>として知られています。
</span><!--end_jpstr-->
</p>
<p>A nested function is nonescaping if it captures a value that is guaranteed to never escape—such as an in-out parameter—or passed as a nonescaping function argument. Otherwise, the nested function is an escaping function.<br><span class="jpstr">
入れ子にされた関数は、決して脱出しないことを保証される値 — 例えばin-outパラメータ — を、または非脱出関数引数として渡される値を、もしそれがキャプチャするならば非脱出です。それ以外では、入れ子にされた関数は脱出関数です。
</span><!--end_jpstr-->
</p>
<p>For a discussion of nested functions, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID178"><span class="std std-ref">Nested Functions</span></a>.<br><span class="jpstr">
入れ子にされた関数の議論のために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID178"><span class="std std-ref">入れ子にされた関数</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID471">
<h3>Parameter Names<a class="headerlink" href="#ID471" title="Permalink to this headline">¶</a><br><span class="jpstr">
パラメータ名<a class="headerlink" href="#ID471" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Function parameters are a comma-separated list where each parameter has one of several forms. The order of arguments in a function call must match the order of parameters in the function’s declaration. The simplest entry in a parameter list has the following form:<br><span class="jpstr">
関数パラメータはひとつの「コンマ区切り」のリストです、そこにおいて各パラメータはいくつかの書式のうちの１つを持ちます。関数呼び出しにおける引数の順序は、関数の宣言におけるパラメータの順番と一致しなければなりません。パラメータ・リストの中の最も単純な項目は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">parameter name</span>: <span class="gi">parameter type</span>
</li></ol></div></div></div>
<p>A parameter has a name, which is used within the function body, as well as an argument label, which is used when calling the function or method. By default, parameter names are also used as argument labels. For example:<br><span class="jpstr">
パラメータは名前を持ちます、それは関数本文内部で使われます、それだけでなく引数ラベルも、それは関数やメソッドが呼ばれる時に使われます。特に何もしなければ、パラメータ名はまた引数ラベルとしても使われます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">f</span>(<span class="nv">x</span>: <span class="nc">Int</span>, <span class="nv">y</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> { <span class="k">return</span> <span class="nv">x</span> + <span class="nv">y</span> }
</li><li><span class="nv">f</span>(<span class="nv">x</span>: <span class="m">1</span>, <span class="nv">y</span>: <span class="m">2</span>) <span class="c">// both x and y are labeled&nbsp;<span class="jpstr"><span class="c">（xとyの両方ともラベルをつけられます）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p>You can override the default behavior for argument labels with one of the following forms:<br><span class="jpstr">
あなたは引数ラベルに対する初期状態の挙動をオーバーライドすることが以下の形式の１つで可能です：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="gi">argument label</span> <span class="gi">parameter name</span>: <span class="gi">parameter type</span>
</li><li><span class="k">_</span> <span class="gi">parameter name</span>: <span class="gi">parameter type</span>
</li></ol></div></div></div>
<p>A name before the parameter name gives the parameter an explicit argument label, which can be different from the parameter name. The corresponding argument must use the given argument label in function or method calls.<br><span class="jpstr">
パラメータ名の前の名前は、そのパラメータに明示的な引数ラベルを与えます、それはパラメーター名と異なるものにできます。対応する引数は、この引数ラベルを関数またはメソッドの呼び出しにおいて使わなければなりません。
</span><!--end_jpstr-->
</p>
<p>An underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) before a parameter name suppresses the argument label. The corresponding argument must have no label in function or method calls.<br><span class="jpstr">
パラメーター名の前のアンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）は、引数ラベルを抑制します。対応する引数には、関数またはメソッドの呼び出しにおいてラベルがあってはなりません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">repeatGreeting</span>(<span class="k">_</span> <span class="nv">greeting</span>: <span class="nc">String</span>, <span class="nv">count</span> <span class="nv">n</span>: <span class="nc">Int</span>) { <span class="c">/* Greet n times &nbsp;<span class="jpstr">（n回あいさつします）</span><!--end_jpstr-->*/</span> }
</li><li><span class="nv">repeatGreeting</span>(<span class="s">&quot;Hello, world!&quot;</span>, <span class="nv">count</span>: <span class="m">2</span>) <span class="c">//  count is labeled, greeting is not&nbsp;<span class="jpstr"><span class="c">（countはラベルを付けられます、greetingは違います）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID545">
<h3>In-Out Parameters<a class="headerlink" href="#ID545" title="Permalink to this headline">¶</a><br><span class="jpstr">
In-Outパラメータ<a class="headerlink" href="#ID545" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>In-out parameters are passed as follows:<br><span class="jpstr">
in-outパラメータは、以下のように渡されます：
</span><!--end_jpstr-->
</p>
<ol class="arabic simple">
<li>When the function is called, the value of the argument is copied.<br><span class="jpstr">
関数が呼ばれる時、その引数の値はコピー（複製）をつくられます。
</span><!--end_jpstr-->
</li>
<li>In the body of the function, the copy is modified.<br><span class="jpstr">
関数の本体において、そのコピーが修正されます。
</span><!--end_jpstr-->
</li>
<li>When the function returns, the copy’s value is assigned to the original argument.<br><span class="jpstr">
関数が戻る時、コピーの値はそのオリジナルの（元の）引数に代入されます。
</span><!--end_jpstr-->
</li>
</ol>
<p>This behavior is known as <em>copy-in copy-out</em> or <em>call by value result</em>. For example, when a computed property or a property with observers is passed as an in-out parameter, its getter is called as part of the function call and its setter is called as part of the function return.<br><span class="jpstr">
この挙動は、<em>コピーイン・コピーアウト</em>または<em>結果値による呼び出し</em>として知られます。例えば、計算プロパティまたはオブザーバを持つプロパティがin-outパラメータとして渡される時、それのゲッターは関数呼び出しの一部として呼び出され、それのセッターは関数の戻りの一部として呼び出されます。
</span><!--end_jpstr-->
</p>
<p>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body. The optimized behavior is known as <em>call by reference</em>; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying. Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.<br><span class="jpstr">
ひとつの最適化として、引数がメモリにおいて物理的番地に格納される値である時、同じメモリ位置は関数本体の内側と外側の両方で使われます。この最適化挙動は、<em>参照呼び出し</em>として知られます；それはコピーイン・コピーアウトモデルの要件の全てを満足させる一方でコピーすることのオーバーヘッド（間接的経費）を取り除きます。あなたのコードをコピーイン・コピーアウトによって与えられるモデルを使って描いてください、参照呼び出し最適化に依存することなしに、そうすることでそれは最適化があってもなくても正しく振舞います。
</span><!--end_jpstr-->
</p>
<p>Within a function, don’t access a value that was passed as an in-out argument, even if the original value is available in the current scope. Accessing the original is a simultaneous access of the value, which violates Swift’s memory exclusivity guarantee. For the same reason, you can’t pass the same value to multiple in-out parameters.<br><span class="jpstr">
関数内部で、in-out引数として渡された値にアクセスしないでください、たとえその元の値が現在のスコープにおいて利用可能であるとしてもです。元のものにアクセスすることは、その値に対する同時的なアクセスです、それはスウィフトのメモリ排他保証を破ります。同じ理由のために、あなたは複数のin-outパラメータに対して同じ値を渡すことができません。
</span><!--end_jpstr-->
</p>
<p>For more information about memory safety and memory exclusivity, see <a class="reference internal" href="../LanguageGuide/MemorySafety.html"><span class="doc">Memory Safety</span></a>.<br><span class="jpstr">
メモリ安全とメモリ排他についての更なる情報として、<a class="reference internal" href="../LanguageGuide/MemorySafety.html"><span class="doc">メモリ安全</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>A closure or nested function that captures an in-out parameter must be nonescaping. If you need to capture an in-out parameter without mutating it or to observe changes made by other code, use a capture list to explicitly capture the parameter immutably.<br><span class="jpstr">
in-outパラメータをキャプチャするクロージャまたは入れ子にされた関数は、非脱出でなければなりません。あなたがin-outパラメータをキャプチャする必要がそれを変化させることなしにまたは他のコードによってなされる変更を監視するためにあるならば、キャプチャリストを使うことで明示的にそのパラメータを不変にキャプチャしてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">a</span>: <span class="k">inout</span> <span class="nc">Int</span>) -&gt; () -&gt; <span class="nc">Int</span> {
</li><li>    <span class="k">return</span> { [<span class="nv">a</span>] <span class="k">in</span> <span class="k">return</span> <span class="nv">a</span> + <span class="m">1</span> }
</li><li>}
</li></ol></div></div></div>
<p>If you need to capture and mutate an in-out parameter, use an explicit local copy, such as in multithreaded code that ensures all mutation has finished before the function returns.<br><span class="jpstr">
あなたがin-outパラメータをキャプチャして変化させる必要があるならば、明示的なローカルコピーを使ってください、例えばすべての変化がその関数が返るまえに完了してしまっていることを保証するマルチスレッド化されたコードにおいてなど。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">multithreadedFunction</span>(<span class="nv">queue</span>: <span class="nc">DispatchQueue</span>, <span class="nv">x</span>: <span class="k">inout</span> <span class="nc">Int</span>) {
</li><li>    <span class="c">// Make a local copy and manually copy it back.&nbsp;<span class="jpstr">（ローカルコピーを作って手動でそれを元へコピーする）</span><!--end_jpstr-->
</span>
</li><li>    <span class="k">var</span> <span class="nv">localX</span> = <span class="nv">x</span>
</li><li>    <span class="k">defer</span> { <span class="nv">x</span> = <span class="nv">localX</span> }
</li><li>
</li><li>    <span class="c">// Operate on localX asynchronously, then wait before returning.&nbsp;<span class="jpstr">（非同期にlocalXを処理を施す、それから返すまえに待機する）</span><!--end_jpstr-->
</span>
</li><li>    <span class="nv">queue</span>.<span class="nv">async</span> { <span class="nv">someMutatingOperation</span>(&amp;<span class="nv">localX</span>) }
</li><li>    <span class="nv">queue</span>.<span class="nv">sync</span> {}
</li><li>}
</li></ol></div></div></div>
<p>For more discussion and examples of in-out parameters, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">In-Out Parameters</span></a>.<br><span class="jpstr">
in-outパラメータの議論と例のために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID173"><span class="std std-ref">in-outパラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID472">
<h3>Special Kinds of Parameters<a class="headerlink" href="#ID472" title="Permalink to this headline">¶</a><br><span class="jpstr">
特別な種類のパラメータ<a class="headerlink" href="#ID472" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Parameters can be ignored, take a variable number of values, and provide default values using the following forms:<br><span class="jpstr">
パラメータは、無視されること、可変の数の値をとること、そして以下の形式を使って省略時の値を提供することができます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">_</span> : <span class="gi">parameter type</span>
</li><li><span class="gi">parameter name</span>: <span class="gi">parameter type</span>...
</li><li><span class="gi">parameter name</span>: <span class="gi">parameter type</span> = <span class="gi">default argument value</span>
</li></ol></div></div></div>
<p>An underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) parameter is explicitly ignored and can’t be accessed within the body of the function.<br><span class="jpstr">
ひとつのアンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）のパラメータは、明確に無視されます、そして関数の本体内でアクセスされることができません。
</span><!--end_jpstr-->
</p>
<p>A parameter with a base type name followed immediately by three dots (<code class="docutils literal notranslate"><span class="pre">...</span></code>) is understood as a variadic parameter. A function can have at most one variadic parameter. A variadic parameter is treated as an array that contains elements of the base type name. For instance, the variadic parameter <code class="docutils literal notranslate"><span class="pre">Int...</span></code> is treated as <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>. For an example that uses a variadic parameter, see <a class="reference internal" href="../LanguageGuide/Functions.html#ID171"><span class="std std-ref">Variadic Parameters</span></a>.<br><span class="jpstr">
基本の型の名前に直ちに３つの点（<code class="docutils literal notranslate"><span class="pre">...</span></code>）が続くパラメータは、可変長パラメータとして理解されます。関数は最大で１つの可変長パラメータしか持つことができません。可変長パラメータは、基本の型の名前の要素たちが入っている配列とみなされます。たとえば、可変長パラメータ<code class="docutils literal notranslate"><span class="pre">Int...</span></code>は<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>とみなされます。可変長パラメータを使う例のために、<a class="reference internal" href="../LanguageGuide/Functions.html#ID171"><span class="std std-ref">可変長パラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>A parameter with an equals sign (<code class="docutils literal notranslate"><span class="pre">=</span></code>) and an expression after its type is understood to have a default value of the given expression. The given expression is evaluated when the function is called. If the parameter is omitted when calling the function, the default value is used instead.<br><span class="jpstr">
その型の後に等号（<code class="docutils literal notranslate"><span class="pre">=</span></code>）と式をもつパラメータは、与えられた式からなる省略時の値を持つと理解されます。与えられた式は、関数が呼び出される時に評価されます。パラメーターが関数呼び出し時に省略されるならば、省略時の値が代わりに使われます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">f</span>(<span class="nv">x</span>: <span class="nc">Int</span> = <span class="m">42</span>) -&gt; <span class="nc">Int</span> { <span class="k">return</span> <span class="nv">x</span> }
</li><li><span class="nv">f</span>()       <span class="c">// Valid, uses default value&nbsp;<span class="jpstr"><span class="c">（有効、省略時の値を使う）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">f</span>(<span class="nv">x</span>: <span class="m">7</span>)   <span class="c">// Valid, uses the value provided&nbsp;<span class="jpstr"><span class="c">（有効、提供された値を使う）</span></span><!--end_jpstr--></span>
</li><li><span class="nv">f</span>(<span class="m">7</span>)      <span class="c">// Invalid, missing argument label&nbsp;<span class="jpstr"><span class="c">（無効、引数ラベルが欠けている）</span></span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID473">
<h3>Special Kinds of Methods<a class="headerlink" href="#ID473" title="Permalink to this headline">¶</a><br><span class="jpstr">
特別な種類のメソッド<a class="headerlink" href="#ID473" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Methods on an enumeration or a structure that modify <code class="docutils literal notranslate"><span class="pre">self</span></code> must be marked with the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> declaration modifier.<br><span class="jpstr">
列挙または構造体での<code class="docutils literal notranslate"><span class="pre">self</span></code>を修正するメソッドは、<code class="docutils literal notranslate"><span class="pre">mutating</span></code>宣言修飾子で印されなければなりません。
</span><!--end_jpstr-->
</p>
<p>Methods that override a superclass method must be marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> declaration modifier. It’s a compile-time error to override a method without the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier or to use the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier on a method that doesn’t override a superclass method.<br><span class="jpstr">
スーパークラスのメソッドをオーバーライドするメソッドは、<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印されなければなりません。<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子なしでメソッドをオーバーライドするか、スーパークラスメソッドをオーバーライドしないメソッドで<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子を使用することは、コンパイル時エラーです。
</span><!--end_jpstr-->
</p>
<p>Methods associated with a type rather than an instance of a type must be marked with the <code class="docutils literal notranslate"><span class="pre">static</span></code> declaration modifier for enumerations and structures, or with either the <code class="docutils literal notranslate"><span class="pre">static</span></code> or <code class="docutils literal notranslate"><span class="pre">class</span></code> declaration modifier for classes. A class type method marked with the <code class="docutils literal notranslate"><span class="pre">class</span></code> declaration modifier can be overridden by a subclass implementation; a class type method marked with <code class="docutils literal notranslate"><span class="pre">static</span></code> can’t be overridden.<br><span class="jpstr">
ある型のインスタンスとではなく、ある型と結び付けられるメソッドは、列挙と構造体では<code class="docutils literal notranslate"><span class="pre">static</span></code>宣言修飾子で、またクラスでは<code class="docutils literal notranslate"><span class="pre">static</span></code>または<code class="docutils literal notranslate"><span class="pre">class</span></code>どちらかの宣言修飾子で印されなければなりません。<code class="docutils literal notranslate"><span class="pre">class</span></code>宣言修飾子で印されるクラス型メソッドは、サブクラス実装によってオーバーライドされることができます；<code class="docutils literal notranslate"><span class="pre">static</span></code>で印されるクラス型メソッドはオーバーライドされることができません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID530">
<h3>Throwing Functions and Methods<a class="headerlink" href="#ID530" title="Permalink to this headline">¶</a><br><span class="jpstr">
スローを行う関数とメソッド<a class="headerlink" href="#ID530" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Functions and methods that can throw an error must be marked with the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword. These functions and methods are known as <em>throwing functions</em> and <em>throwing methods</em>. They have the following form:<br><span class="jpstr">
エラーをスローできる関数とメソッドは、<code class="docutils literal notranslate"><span class="pre">throws</span></code>キーワードで印されなければなりません。これらの関数とメソッドは<em>スロー関数</em>および<em>スローメソッド</em>として知られます。これらは以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="gi">function name</span>(<span class="gi">parameters</span>) <span class="k">throws</span> -&gt; <span class="gi">return type</span> {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>Calls to a throwing function or method must be wrapped in a <code class="docutils literal notranslate"><span class="pre">try</span></code> or <code class="docutils literal notranslate"><span class="pre">try!</span></code> expression (that is, in the scope of a <code class="docutils literal notranslate"><span class="pre">try</span></code> or <code class="docutils literal notranslate"><span class="pre">try!</span></code> operator).<br><span class="jpstr">
スロー関数またはメソッドに対する呼び出しは、<code class="docutils literal notranslate"><span class="pre">try</span></code>または<code class="docutils literal notranslate"><span class="pre">try!</span></code>式の中に（即ち、<code class="docutils literal notranslate"><span class="pre">try</span></code>または<code class="docutils literal notranslate"><span class="pre">try!</span></code>演算子のスコープの中に）包まれなければなりません。
</span><!--end_jpstr-->
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions. As a result, you can use a nonthrowing function in the same places as a throwing one.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">throws</span></code>キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。
</span><!--end_jpstr-->
</p>
<p>You can’t overload a function based only on whether the function can throw an error. That said, you can overload a function based on whether a function <em>parameter</em> can throw an error.<br><span class="jpstr">
あなたはある関数を、その関数がエラーをスローできるかどうかのみに基づいてオーバーロードできません。とは言え、あなたは関数を、ある関数<em>パラメーター</em>がエラーをスローできるかどうかに基づいてオーバーロードすることができます。
</span><!--end_jpstr-->
</p>
<p>A throwing method can’t override a nonthrowing method, and a throwing method can’t satisfy a protocol requirement for a nonthrowing method. That said, a nonthrowing method can override a throwing method, and a nonthrowing method can satisfy a protocol requirement for a throwing method.<br><span class="jpstr">
スローメソッドは、非スローメソッドをオーバーライドすることができません、そしてスローメソッドは、非スローメソッド用のプロトコル要件を満たすことができません。とは言え、非スローメソッドはスローメソッドをオーバーライドできます、そして非スローメソッドはスローメソッドのプロトコル要件を満たすことができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID531">
<h3>Rethrowing Functions and Methods<a class="headerlink" href="#ID531" title="Permalink to this headline">¶</a><br><span class="jpstr">
再スローを行う関数とメソッド<a class="headerlink" href="#ID531" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A function or method can be declared with the <code class="docutils literal notranslate"><span class="pre">rethrows</span></code> keyword to indicate that it throws an error only if one of its function parameters throws an error. These functions and methods are known as <em>rethrowing functions</em> and <em>rethrowing methods</em>. Rethrowing functions and methods must have at least one throwing function parameter.<br><span class="jpstr">
関数またはメソッドは、<code class="docutils literal notranslate"><span class="pre">rethrows</span></code>キーワードとともに宣言されて、それの関数パラメータの１つがエラーをスローする場合にのみそれがエラーをスローすることを指し示すことができます。これらの関数とメソッドは、<em>再スロー関数</em>と<em>再スローメソッド</em>として知られています。再スロー関数とメソッドは、少なくとも１つのスロー関数パラメーターを持たなければなりません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">callback</span>: () <span class="k">throws</span> -&gt; <span class="nv">Void</span>) <span class="k">rethrows</span> {
</li><li>    <span class="k">try</span> <span class="nv">callback</span>()
</li><li>}
</li></ol></div></div></div>
<p>A rethrowing function or method can contain a <code class="docutils literal notranslate"><span class="pre">throw</span></code> statement only inside a <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause. This lets you call the throwing function inside a <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code> block and handle errors in the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause by throwing a different error. In addition, the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause must handle only errors thrown by one of the rethrowing function’s throwing parameters. For example, the following is invalid because the <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause would handle the error thrown by <code class="docutils literal notranslate"><span class="pre">alwaysThrows()</span></code>.<br><span class="jpstr">
再度スローする関数やメソッドは、<code class="docutils literal notranslate"><span class="pre">throw</span></code>文を<code class="docutils literal notranslate"><span class="pre">catch</span></code>節の内部にのみ含むことができます。これは、あなたにスロー関数を<code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code>プロックの内部で呼び出させ、その<code class="docutils literal notranslate"><span class="pre">catch</span></code>節において異なるエラーをスローすることによって、エラーを取り扱わせます。加えて、その<code class="docutils literal notranslate"><span class="pre">catch</span></code>節はスロー関数の持つスローパラメータの１つによってスローされるエラーのみを取り扱わなければなりません。例えば、以下のものは無効です、なぜなら<code class="docutils literal notranslate"><span class="pre">catch</span></code>節が<code class="docutils literal notranslate"><span class="pre">alwaysThrows()</span></code>によってスローされるエラーを取り扱おうとするからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">alwaysThrows</span>() <span class="k">throws</span> {
</li><li>    <span class="k">throw</span> <span class="nv">SomeError</span>.<span class="nv">error</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">someFunction</span>(<span class="nv">callback</span>: () <span class="k">throws</span> -&gt; <span class="nv">Void</span>) <span class="k">rethrows</span> {
</li><li>    <span class="k">do</span> {
</li><li>        <span class="k">try</span> <span class="nv">callback</span>()
</li><li>        <span class="k">try</span> <span class="nv">alwaysThrows</span>()  <span class="c">// Invalid, alwaysThrows() isn&#39;t a throwing parameter&nbsp;<span class="jpstr"><span class="c">（無効、alwaysThrows()はスローパラメータではありません）</span></span><!--end_jpstr--></span>
</li><li>    } <span class="k">catch</span> {
</li><li>        <span class="k">throw</span> <span class="nv">AnotherError</span>.<span class="nv">error</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>A throwing method can’t override a rethrowing method, and a throwing method can’t satisfy a protocol requirement for a rethrowing method. That said, a rethrowing method can override a throwing method, and a rethrowing method can satisfy a protocol requirement for a throwing method.<br><span class="jpstr">
スローメソッドは、再スローメソッドをオーバーライドできません、そしてスローメソッドは再スローメソッド用のプロトコル要件を満たすことができません。とは言え、再スローメソッドはスローメソッドをオーバーライドできます、そして再スローメソッドはスローメソッド用のプロトコル要件を満たすことができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID551">
<h3>Functions that Never Return<a class="headerlink" href="#ID551" title="Permalink to this headline">¶</a><br><span class="jpstr">
決して返らない関数<a class="headerlink" href="#ID551" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Swift defines a <code class="docutils literal notranslate"><span class="pre">Never</span></code> type, which indicates that a function or method doesn’t return to its caller. Functions and methods with the <code class="docutils literal notranslate"><span class="pre">Never</span></code> return type are called <em>nonreturning</em>. Nonreturning functions and methods either cause an irrecoverable error or begin a sequence of work that continues indefinitely. This means that code that would otherwise run immediately after the call is never executed. Throwing and rethrowing functions can transfer program control to an appropriate <code class="docutils literal notranslate"><span class="pre">catch</span></code> block, even when they are nonreturning.<br><span class="jpstr">
スウィフトは<code class="docutils literal notranslate"><span class="pre">Never</span></code>型を定義します、それはある関数またはメソッドがそれの呼び出し側に帰らないことを指し示します。<code class="docutils literal notranslate"><span class="pre">Never</span></code>戻り型を持つ関数およびメソッドは、<em>非復帰</em>と呼ばれます。非復帰関数およびメソッドは、回復不能のエラーを起こすかまたは無期限に続く一連の作業を始めるかのどちらかです。これが意味するのは、そうでなければ呼び出しの直後に動作するコードは、決して実行されないということです。スローおよび再スロー関数は、制御を適切な<code class="docutils literal notranslate"><span class="pre">catch</span></code>プロックに移すことができます、それらが非復帰である場合でさえも。
</span><!--end_jpstr-->
</p>
<p>A nonreturning function or method can be called to conclude the <code class="docutils literal notranslate"><span class="pre">else</span></code> clause of a guard statement, as discussed in <a class="reference internal" href="Statements.html#ID524"><span class="std std-ref">Guard Statement</span></a>.<br><span class="jpstr">
非復帰関数およびメソッドは、guard文の<code class="docutils literal notranslate"><span class="pre">else</span></code>節で終わるために呼び出されることができます、<a class="reference internal" href="Statements.html#ID524"><span class="std std-ref">guard文</span></a>で議論されるように。
</span><!--end_jpstr-->
</p>
<p>You can override a nonreturning method, but the new method must preserve its return type and nonreturning behavior.<br><span class="jpstr">
あなたは非復帰メソッドをオーバーライドすることができます、しかし新しいメソッドはそれの戻り型と非復帰挙動を維持しなければなりません。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a function declaration<br><span class="jpstr">
関数宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-declaration"></a>function-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-head">function-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-name">function-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-signature">function-signature</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-body">function-body</a></span> <sub>opt</sub></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-head"></a>function-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>func</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-name"></a>function-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-signature"></a>function-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>throws</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-result">function-result</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-signature_1031"></a>function-signature</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>rethrows</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-result">function-result</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-result"></a>function-result</span><span class="arrow"> → </span> <code>-&gt;</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_function-body"></a>function-body</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parameter-clause"></a>parameter-clause</span><span class="arrow"> → </span> <code>(</code> <code>)</code> |  <code>(</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-list">parameter-list</a></span>  <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parameter-list"></a>parameter-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter">parameter</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter">parameter</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-list">parameter-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parameter"></a>parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_external-parameter-name">external-parameter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_local-parameter-name">local-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_default-argument-clause">default-argument-clause</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parameter_1032"></a>parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_external-parameter-name">external-parameter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_local-parameter-name">local-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_parameter_1033"></a>parameter</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_external-parameter-name">external-parameter-name</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_local-parameter-name">local-parameter-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <code>...</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_external-parameter-name"></a>external-parameter-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_local-parameter-name"></a>local-parameter-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_default-argument-clause"></a>default-argument-clause</span><span class="arrow"> → </span> <code>=</code> <span class="syntactic-category"><a href="../ReferenceManual/Expressions.html#grammar_expression">expression</a></span> </p></div></div></div>
</div>
<div class="section" id="ID364">
<h2>Enumeration Declaration<a class="headerlink" href="#ID364" title="Permalink to this headline">¶</a><br><span class="jpstr">
列挙宣言<a class="headerlink" href="#ID364" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>An <em>enumeration declaration</em> introduces a named enumeration type into your program.<br><span class="jpstr">
<em>列挙宣言</em>は、名前をつけられた列挙型をあなたのプログラムに導入します。
</span><!--end_jpstr-->
</p>
<p>Enumeration declarations have two basic forms and are declared using the <code class="docutils literal notranslate"><span class="pre">enum</span></code> keyword. The body of an enumeration declared using either form contains zero or more values—called <em>enumeration cases</em>—and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, and class declarations. Enumeration declarations can’t contain deinitializer or protocol declarations.<br><span class="jpstr">
列挙宣言は、２つの基本の形式を持ち、キーワード<code class="docutils literal notranslate"><span class="pre">enum</span></code>を使って宣言されます。どちらの形式を使って宣言される列挙宣言の本文でも、０以上の値 ― <em>列挙ケース節</em>と呼ばれるもの ― および任意の数の宣言から成っていて、計算プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、型エイリアス、そして他の列挙、構造体、およびクラス宣言さえも含められます。列挙宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。
</span><!--end_jpstr-->
</p>
<p>Enumeration types can adopt any number of protocols, but can’t inherit from classes, structures, or other enumerations.<br><span class="jpstr">
列挙型は、任意の数のプロトコルに準拠することができます、しかしクラス、構造体、または他の列挙から継承することはできません。
</span><!--end_jpstr-->
</p>
<p>Unlike classes and structures, enumeration types do not have an implicitly provided default initializer; all initializers must be declared explicitly. Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to <code class="docutils literal notranslate"><span class="pre">self</span></code>.<br><span class="jpstr">
クラスや構造体と違って、列挙型には、暗黙のうちに提供される省略時のイニシャライザがありません；全てのイニシャライザは、明確に宣言されなければなりません。イニシャライザは、その列挙の中の他のイニシャライザに委任することができます、しかしその初期化処理はあるイニシャライザが列挙ケース節のうちの１つを<code class="docutils literal notranslate"><span class="pre">self</span></code>に代入した後になって初めて終了します。
</span><!--end_jpstr-->
</p>
<p>Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call. For information about value types, see <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a>.<br><span class="jpstr">
構造体のように、しかしクラスとは違い、列挙は値型です；列挙のインスタンスは、変数や定数に代入されるとき、または関数呼び出しに引数として渡されるときにコピーされます。値型に関して詳しくは、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">構造体と列挙は値型です</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>You can extend the behavior of an enumeration type with an extension declaration, as discussed in <a class="reference internal" href="#ID378"><span class="std std-ref">Extension Declaration</span></a>.<br><span class="jpstr">
あなたは列挙型の挙動を拡張宣言を使って拡張することができます、<a class="reference internal" href="#ID378"><span class="std std-ref">拡張宣言</span></a>で議論されるように。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID365">
<h3>Enumerations with Cases of Any Type<a class="headerlink" href="#ID365" title="Permalink to this headline">¶</a><br><span class="jpstr">
随意の型のケース節をもつ列挙<a class="headerlink" href="#ID365" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The following form declares an enumeration type that contains enumeration cases of any type:<br><span class="jpstr">
以下の形式は、随意の型の列挙ケース節を含む列挙型を宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="gi">enumeration name</span>: <span class="gi">adopted protocols</span> {
</li><li>    <span class="k">case</span> <span class="gi">enumeration case 1</span>
</li><li>    <span class="k">case</span> <span class="gi">enumeration case 2</span>(<span class="gi">associated value types</span>)
</li><li>}
</li></ol></div></div></div>
<p>Enumerations declared in this form are sometimes called <em>discriminated unions</em> in other programming languages.<br><span class="jpstr">
この形式で宣言される列挙は、時として他のプログラミング言語では<em>判別共用体</em>と呼ばれています。
</span><!--end_jpstr-->
</p>
<p>In this form, each case block consists of the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword followed by one or more enumeration cases, separated by commas. The name of each case must be unique. Each case can also specify that it stores values of a given type. These types are specified in the <em>associated value types</em> tuple, immediately following the name of the case.<br><span class="jpstr">
この形式では、それぞれのケース節ブロックはキーワード<code class="docutils literal notranslate"><span class="pre">case</span></code>とそれに続く一つ以上の、コンマで区切られた、列挙ケース節から成ります。各ケース節の名前は、固有でなければなりません。各ケース節は、また、それが特定の型の値を格納することを示すことができます。これらの型は、ケース節の名前の直後に、それら<em>関連値型</em>のタプルを使って指定されます。
</span><!--end_jpstr-->
</p>
<p>Enumeration cases that store associated values can be used as functions that create instances of the enumeration with the specified associated values. And just like functions, you can get a reference to an enumeration case and apply it later in your code.<br><span class="jpstr">
関連値を格納する列挙ケース節は、関数として使われることができ、それは指定された関連値を持つその列挙のインスタンスを作成します。さらにまさに関数のように、あなたはある列挙ケース節の参照を得ることができ、それを後であなたのコードに応用することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Number</span> {
</li><li>    <span class="k">case</span> <span class="nv">integer</span>(<span class="nv">Int</span>)
</li><li>    <span class="k">case</span> <span class="nv">real</span>(<span class="nv">Double</span>)
</li><li>}
</li><li><span class="k">let</span> <span class="nv">f</span> = <span class="nv">Number</span>.<span class="nv">integer</span>
</li><li><span class="c">// f is a function of type (Int) -&gt; Number&nbsp;<span class="jpstr">（fは型(Int) -&gt; Numberの関数です）</span><!--end_jpstr-->
</span>
</li><li>
</li><li><span class="c">// Apply f to create an array of Number instances with integer values&nbsp;<span class="jpstr">（fを適用して整数値を持つNumberインスタンスからなる配列を作成する）</span><!--end_jpstr-->
</span>
</li><li><span class="k">let</span> <span class="nv">evenInts</span>: [<span class="nc">Number</span>] = [<span class="m">0</span>, <span class="m">2</span>, <span class="m">4</span>, <span class="m">6</span>].<span class="nv">map</span>(<span class="nv">f</span>)
</li></ol></div></div></div>
<p>For more information and to see examples of cases with associated value types, see <a class="reference internal" href="../LanguageGuide/Enumerations.html#ID148"><span class="std std-ref">Associated Values</span></a>.<br><span class="jpstr">
より多くの情報のために、そして関連値型をもつケース節の例を見るために、<a class="reference internal" href="../LanguageGuide/Enumerations.html#ID148"><span class="std std-ref">関連値</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID537">
<h4>Enumerations with Indirection<a class="headerlink" href="#ID537" title="Permalink to this headline">¶</a><br><span class="jpstr">
間接参照を持つ列挙<a class="headerlink" href="#ID537" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>Enumerations can have a recursive structure, that is, they can have cases with associated values that are instances of the enumeration type itself. However, instances of enumeration types have value semantics, which means they have a fixed layout in memory. To support recursion, the compiler must insert a layer of indirection.<br><span class="jpstr">
列挙は、再帰構造を持つことができます、すなわち、それは、その列挙型それ自身のインスタンスである関連値を伴うケース節を持つことができます。しかしながら、列挙型のインスタンスは値意味論を持ちます、それは、それらがメモリにおいてある固定された配置を持つことを意味します。再帰をサポートするために、コンパイラは間接参照の階層を差し入れる必要があります。
</span><!--end_jpstr-->
</p>
<p>To enable indirection for a particular enumeration case, mark it with the <code class="docutils literal notranslate"><span class="pre">indirect</span></code> declaration modifier. An indirect case must have an associated value.<br><span class="jpstr">
ある特定の列挙ケース節に対して間接参照を可能にするには、それを<code class="docutils literal notranslate"><span class="pre">indirect</span></code>宣言修飾子で印してください。関節参照のケース節は、関連値を持っていなければなりません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Tree</span>&lt;<span class="nv">T</span>&gt; {
</li><li>    <span class="k">case</span> <span class="nv">empty</span>
</li><li>    <span class="k">indirect</span> <span class="k">case</span> <span class="nv">node</span>(<span class="nv">value</span>: <span class="nv">T</span>, <span class="nv">left</span>: <span class="nv">Tree</span>, <span class="nv">right</span>: <span class="nv">Tree</span>)
</li><li>}
</li></ol></div></div></div>
<p>To enable indirection for all the cases of an enumeration that have an associated value, mark the entire enumeration with the <code class="docutils literal notranslate"><span class="pre">indirect</span></code> modifier—this is convenient when the enumeration contains many cases that would each need to be marked with the <code class="docutils literal notranslate"><span class="pre">indirect</span></code> modifier.<br><span class="jpstr">
ある列挙の中のすべてのケース節、それらは関連値を持っている、に対して間接参照を可能にするには、その列挙全体を<code class="docutils literal notranslate"><span class="pre">indirect</span></code>修飾子で印してください—これはその列挙がそのそれぞれが<code class="docutils literal notranslate"><span class="pre">indirect</span></code>修飾子で印される必要がある多くのケース節を含んでいる時に適します。
</span><!--end_jpstr-->
</p>
<p>An enumeration that is marked with the <code class="docutils literal notranslate"><span class="pre">indirect</span></code> modifier can contain a mixture of cases that have associated values and cases those that don’t. That said, it can’t contain any cases that are also marked with the <code class="docutils literal notranslate"><span class="pre">indirect</span></code> modifier.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">indirect</span></code>修飾子で印される列挙は、関連値を持つケース節とそうでないケース節の入り交じったものを持つことができます。とは言うものの、それは<code class="docutils literal notranslate"><span class="pre">indirect</span></code>修飾子でさらに印されるどんなケース節も含むことはできません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID366">
<h3>Enumerations with Cases of a Raw-Value Type<a class="headerlink" href="#ID366" title="Permalink to this headline">¶</a><br><span class="jpstr">
「生の値」型のケース節を持つ列挙<a class="headerlink" href="#ID366" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>The following form declares an enumeration type that contains enumeration cases of the same basic type:<br><span class="jpstr">
以下の形式は、同じ基本の型をもつ列挙ケース節たちを含む列挙型を宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="gi">enumeration name</span>: <span class="gi">raw-value type</span>, <span class="gi">adopted protocols</span> {
</li><li>    <span class="k">case</span> <span class="gi">enumeration case 1</span> = <span class="gi">raw value 1</span>
</li><li>    <span class="k">case</span> <span class="gi">enumeration case 2</span> = <span class="gi">raw value 2</span>
</li><li>}
</li></ol></div></div></div>
<p>In this form, each case block consists of the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword, followed by one or more enumeration cases, separated by commas. Unlike the cases in the first form, each case has an underlying value, called a <em>raw value</em>, of the same basic type. The type of these values is specified in the <em>raw-value type</em> and must represent an integer, floating-point number, string, or single character. In particular, the <em>raw-value type</em> must conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol and one of the following protocols: <code class="docutils literal notranslate"><span class="pre">ExpressibleByIntegerLiteral</span></code> for integer literals, <code class="docutils literal notranslate"><span class="pre">ExpressibleByFloatLiteral</span></code> for floating-point literals, <code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code> for string literals that contain any number of characters, and <code class="docutils literal notranslate"><span class="pre">ExpressibleByUnicodeScalarLiteral</span></code> or <code class="docutils literal notranslate"><span class="pre">ExpressibleByExtendedGraphemeClusterLiteral</span></code> for string literals that contain only a single character. Each case must have a unique name and be assigned a unique raw value.<br><span class="jpstr">
この形式では、それぞれのケース節ブロックはキーワード<code class="docutils literal notranslate"><span class="pre">case</span></code>、それに続けて、コンマで区切られる一つ以上の列挙ケース節から成ります。最初の形式でのケース節と違って、それぞれのケース節は、同じ基本の型の、もととなる値、<em>生の値</em>と呼ばれるものを持ちます。これらの値の型は、<em>生の値型</em>において指定されて、整数、浮動小数点数、文字列または単一の文字を表さなければなりません。特に、<em>生の値型</em>は、<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルおよび次のプロトコルの内の１つに準拠しなければなりません：整数リテラルのための<code class="docutils literal notranslate"><span class="pre">ExpressibleByIntegerLiteral</span></code>、浮動小数点リテラルのための<code class="docutils literal notranslate"><span class="pre">ExpressibleByFloatLiteral</span></code>、随意の数の文字を含む文字列リテラルのための<code class="docutils literal notranslate"><span class="pre">ExpressibleByStringLiteral</span></code>、そしてただ１つの文字だけを含む文字列リテラルのための<code class="docutils literal notranslate"><span class="pre">ExpressibleByUnicodeScalarLiteral</span></code>または<code class="docutils literal notranslate"><span class="pre">ExpressibleByExtendedGraphemeClusterLiteral</span></code>。それぞれのケース節は、固有な名前を持ち固有な生の値を割り当てられなければなりません。
</span><!--end_jpstr-->
</p>
<p>If the raw-value type is specified as <code class="docutils literal notranslate"><span class="pre">Int</span></code> and you don’t assign a value to the cases explicitly, they are implicitly assigned the values <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, and so on. Each unassigned case of type <code class="docutils literal notranslate"><span class="pre">Int</span></code> is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.<br><span class="jpstr">
もし生の値型が<code class="docutils literal notranslate"><span class="pre">Int</span></code>として指定され、あなたが明示的に値をそれぞれのケース節に割り当てないならば、それらは暗黙のうちに値<code class="docutils literal notranslate"><span class="pre">0</span></code>、<code class="docutils literal notranslate"><span class="pre">1</span></code>、<code class="docutils literal notranslate"><span class="pre">2</span></code>、等々を割り当てられます。型<code class="docutils literal notranslate"><span class="pre">Int</span></code>の未割り当てのケース節それぞれは、暗黙のうちに生の値を割り当てられます、それは、前のケース節の生の値から自動的に増やされたものです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ExampleEnum</span>: <span class="nc">Int</span> {
</li><li>    <span class="k">case</span> <span class="nv">a</span>, <span class="nv">b</span>, <span class="nv">c</span> = <span class="m">5</span>, <span class="nv">d</span>
</li><li>}
</li></ol></div></div></div>
<p>In the above example, the raw value of <code class="docutils literal notranslate"><span class="pre">ExampleEnum.a</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code> and the value of <code class="docutils literal notranslate"><span class="pre">ExampleEnum.b</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>. And because the value of <code class="docutils literal notranslate"><span class="pre">ExampleEnum.c</span></code> is explicitly set to <code class="docutils literal notranslate"><span class="pre">5</span></code>, the value of <code class="docutils literal notranslate"><span class="pre">ExampleEnum.d</span></code> is automatically incremented from <code class="docutils literal notranslate"><span class="pre">5</span></code> and is therefore <code class="docutils literal notranslate"><span class="pre">6</span></code>.<br><span class="jpstr">
上記の例で、<code class="docutils literal notranslate"><span class="pre">ExampleEnum.a</span></code>の値は<code class="docutils literal notranslate"><span class="pre">0</span></code>です、そして<code class="docutils literal notranslate"><span class="pre">ExampleEnum.b</span></code>の値は<code class="docutils literal notranslate"><span class="pre">1</span></code>です。そして<code class="docutils literal notranslate"><span class="pre">ExampleEnum.cの</span></code>値が明示的に<code class="docutils literal notranslate"><span class="pre">5</span></code>に設定されるので、<code class="docutils literal notranslate"><span class="pre">ExampleEnum.d</span></code>の値は<code class="docutils literal notranslate"><span class="pre">5</span></code>から自動的に増加して、したがって<code class="docutils literal notranslate"><span class="pre">6</span></code>です。
</span><!--end_jpstr-->
</p>
<p>If the raw-value type is specified as <code class="docutils literal notranslate"><span class="pre">String</span></code> and you don’t assign values to the cases explicitly, each unassigned case is implicitly assigned a string with the same text as the name of that case.<br><span class="jpstr">
「生の値」型が<code class="docutils literal notranslate"><span class="pre">String</span></code>として指定されてあなたが明示的に値をそのケース節に割り当てないならば、未割り当てのケース節のそれぞれは暗黙的にそのケース節の名前である同じテキストをもつ文字列を割り当てられます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">GamePlayMode</span>: <span class="nc">String</span> {
</li><li>    <span class="k">case</span> <span class="nv">cooperative</span>, <span class="nv">individual</span>, <span class="nv">competitive</span>
</li><li>}
</li></ol></div></div></div>
<p>In the above example, the raw value of <code class="docutils literal notranslate"><span class="pre">GamePlayMode.cooperative</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;cooperative&quot;</span></code>, the raw value of <code class="docutils literal notranslate"><span class="pre">GamePlayMode.individual</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;individual&quot;</span></code>, and the raw value of <code class="docutils literal notranslate"><span class="pre">GamePlayMode.competitive</span></code> is <code class="docutils literal notranslate"><span class="pre">&quot;competitive&quot;</span></code>.<br><span class="jpstr">
上の例において、<code class="docutils literal notranslate"><span class="pre">GamePlayMode.cooperative</span></code>の生の値は<code class="docutils literal notranslate"><span class="pre">"cooperative"</span></code>です、<code class="docutils literal notranslate"><span class="pre">GamePlayMode.individual</span></code>の生の値は<code class="docutils literal notranslate"><span class="pre">"individual"</span></code>です、そして<code class="docutils literal notranslate"><span class="pre">GamePlayMode.competitive</span></code>の生の値は<code class="docutils literal notranslate"><span class="pre">"competitive"</span></code>です。
</span><!--end_jpstr-->
</p>
<p>Enumerations that have cases of a raw-value type implicitly conform to the <code class="docutils literal notranslate"><span class="pre">RawRepresentable</span></code> protocol, defined in the Swift standard library. As a result, they have a <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> property and a failable initializer with the signature <code class="docutils literal notranslate"><span class="pre">init?(rawValue:</span> <span class="pre">RawValue)</span></code>. You can use the <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> property to access the raw value of an enumeration case, as in <code class="docutils literal notranslate"><span class="pre">ExampleEnum.b.rawValue</span></code>. You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration’s failable initializer, as in <code class="docutils literal notranslate"><span class="pre">ExampleEnum(rawValue:</span> <span class="pre">5)</span></code>, which returns an optional case. For more information and to see examples of cases with raw-value types, see <a class="reference internal" href="../LanguageGuide/Enumerations.html#ID149"><span class="std std-ref">Raw Values</span></a>.<br><span class="jpstr">
「生の値」型のケース節を持つ列挙は、スウィフト標準ライブラリで定義される<code class="docutils literal notranslate"><span class="pre">RawRepresentable</span></code>プロトコルに暗黙的に準拠します。結果として、それは<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>プロパティとシグネチャ<code class="docutils literal notranslate"><span class="pre">init?(rawValue:</span> <span class="pre">RawValue)</span></code>を持つ失敗できるイニシャライザを持ちます。あなたは、<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>プロパティを使うことで列挙ケース節の生の値にアクセスできます、<code class="docutils literal notranslate"><span class="pre">ExampleEnum.b.rawValue</span></code>におけるように。あなたはまた生の値を使用して対応するケース節を見つけることが、もしそれが１つあるならば、列挙の持つ失敗できるイニシャライザを呼ぶことによって可能です、例えば<code class="docutils literal notranslate"><span class="pre">ExampleEnum(rawValue:</span> <span class="pre">5)</span></code>のように、それはオプショナルのケース節を返します。より多くの情報のために、そして「生の値」型をもつケース節の例を見るために、<a class="reference internal" href="../LanguageGuide/Enumerations.html#ID149"><span class="std std-ref">生の値</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID474">
<h3>Accessing Enumeration Cases<a class="headerlink" href="#ID474" title="Permalink to this headline">¶</a><br><span class="jpstr">
列挙ケース節にアクセスする<a class="headerlink" href="#ID474" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>To reference the case of an enumeration type, use dot (<code class="docutils literal notranslate"><span class="pre">.</span></code>) syntax, as in <code class="docutils literal notranslate"><span class="pre">EnumerationType.enumerationCase</span></code>. When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in <a class="reference internal" href="../LanguageGuide/Enumerations.html#ID146"><span class="std std-ref">Enumeration Syntax</span></a> and <a class="reference internal" href="Expressions.html#ID394"><span class="std std-ref">Implicit Member Expression</span></a>.<br><span class="jpstr">
列挙型のケース節に言及するために、<code class="docutils literal notranslate"><span class="pre">EnumerationType.enumerationCase</span></code>のように、ドット（<code class="docutils literal notranslate"><span class="pre">.</span></code>）構文を使ってください。列挙型が前後関係から推論されることができるとき、<a class="reference internal" href="../LanguageGuide/Enumerations.html#ID146"><span class="std std-ref">列挙構文</span></a>と<a class="reference internal" href="Expressions.html#ID394"><span class="std std-ref">暗黙のメンバー式</span></a>で記述されるように、あなたはそれを省略することができます（ドットは依然必要です）。
</span><!--end_jpstr-->
</p>
<p>To check the values of enumeration cases, use a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, as shown in <a class="reference internal" href="../LanguageGuide/Enumerations.html#ID147"><span class="std std-ref">Matching Enumeration Values with a Switch Statement</span></a>. The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, as described in <a class="reference internal" href="Patterns.html#ID424"><span class="std std-ref">Enumeration Case Pattern</span></a>.<br><span class="jpstr">
列挙ケース節の値を調べるために、<a class="reference internal" href="../LanguageGuide/Enumerations.html#ID147"><span class="std std-ref">スイッチ文で列挙値を照合する</span></a>で示されるように、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文を使ってください。列挙型は、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文のケース節ブロックにおいて、列挙ケース節パターンに対してパターンのマッチされます、<a class="reference internal" href="Patterns.html#ID424"><span class="std std-ref">列挙ケース節パターン</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an enumeration declaration<br><span class="jpstr">
列挙宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_enum-declaration"></a>enum-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum">union-style-enum</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_enum-declaration_1034"></a>enum-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum">raw-value-style-enum</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum"></a>union-style-enum</span><span class="arrow"> → </span> <code>indirect</code><sub>opt</sub> <code>enum</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_enum-name">enum-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-members">union-style-enum-members</a></span> <sub>opt</sub> <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum-members"></a>union-style-enum-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-member">union-style-enum-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-members">union-style-enum-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum-member"></a>union-style-enum-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-case-clause">union-style-enum-case-clause</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum-case-clause"></a>union-style-enum-case-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>indirect</code><sub>opt</sub> <code>case</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-case-list">union-style-enum-case-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum-case-list"></a>union-style-enum-case-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-case">union-style-enum-case</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-case">union-style-enum-case</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_union-style-enum-case-list">union-style-enum-case-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_union-style-enum-case"></a>union-style-enum-case</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_enum-case-name">enum-case-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_tuple-type">tuple-type</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_enum-name"></a>enum-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_enum-case-name"></a>enum-case-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum"></a>raw-value-style-enum</span><span class="arrow"> → </span> <code>enum</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_enum-name">enum-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-members">raw-value-style-enum-members</a></span>  <code>}</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum-members"></a>raw-value-style-enum-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-member">raw-value-style-enum-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-members">raw-value-style-enum-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum-member"></a>raw-value-style-enum-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-case-clause">raw-value-style-enum-case-clause</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum-case-clause"></a>raw-value-style-enum-case-clause</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>case</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-case-list">raw-value-style-enum-case-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum-case-list"></a>raw-value-style-enum-case-list</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-case">raw-value-style-enum-case</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-case">raw-value-style-enum-case</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-style-enum-case-list">raw-value-style-enum-case-list</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-style-enum-case"></a>raw-value-style-enum-case</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_enum-case-name">enum-case-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-assignment">raw-value-assignment</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-assignment"></a>raw-value-assignment</span><span class="arrow"> → </span> <code>=</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_raw-value-literal">raw-value-literal</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_raw-value-literal"></a>raw-value-literal</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_numeric-literal">numeric-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammarstatic-string-literal">static-string-literal</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_boolean-literal">boolean-literal</a></span> </p></div></div></div>
</div>
<div class="section" id="ID367">
<h2>Structure Declaration<a class="headerlink" href="#ID367" title="Permalink to this headline">¶</a><br><span class="jpstr">
構造体宣言<a class="headerlink" href="#ID367" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>structure declaration</em> introduces a named structure type into your program. Structure declarations are declared using the <code class="docutils literal notranslate"><span class="pre">struct</span></code> keyword and have the following form:<br><span class="jpstr">
<em>構造体宣言</em>は、名前をつけられた構造体型をあなたのプログラムに導入します。構造体宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">struct</span></code>を使って宣言されて、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="gi">structure name</span>: <span class="gi">adopted protocols</span> {
</li><li>    <span class="gi">declarations</span>
</li><li>}
</li></ol></div></div></div>
<p>The body of a structure contains zero or more <em>declarations</em>. These <em>declarations</em> can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, and enumeration declarations. Structure declarations can’t contain deinitializer or protocol declarations. For a discussion and several examples of structures that include various kinds of declarations, see <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html"><span class="doc">Structures and Classes</span></a>.<br><span class="jpstr">
構造の本文は、０以上の<em>宣言</em>を含みます。これらの<em>宣言</em>は、格納または計算プロパティの双方、型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字、型エイリアス、そして他の構造体、クラス、および列挙宣言さえも含むことができます。構造宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。議論および、さまざまな種類の宣言を含む構造体の例のいくつかのために、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html"><span class="doc">構造体とクラス</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>Structure types can adopt any number of protocols, but can’t inherit from classes, enumerations, or other structures.<br><span class="jpstr">
構造体型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、または他の構造体から継承することはできません。
</span><!--end_jpstr-->
</p>
<p>There are three ways to create an instance of a previously declared structure:<br><span class="jpstr">
以前に宣言された構造体のインスタンスを作成するには３つの方法があります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Call one of the initializers declared within the structure, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID205"><span class="std std-ref">Initializers</span></a>.<br><span class="jpstr">
その構造体の内部で宣言されるイニシャライザの内の１つを呼び出す、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID205"><span class="std std-ref">イニシャライザ</span></a>で記述されるように。
</span><!--end_jpstr-->
</li>
<li>If no initializers are declared, call the structure’s memberwise initializer, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID214"><span class="std std-ref">Memberwise Initializers for Structure Types</span></a>.<br><span class="jpstr">
イニシャライザが宣言されないならば、その構造体のメンバー関連イニシャライザ呼び出す、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID214"><span class="std std-ref">構造型のためのメンバー関連イニシャライザ</span></a>で記述されるように。
</span><!--end_jpstr-->
</li>
<li>If no initializers are declared, and all properties of the structure declaration were given initial values, call the structure’s default initializer, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>.<br><span class="jpstr">
イニシャライザが宣言されない、そしてその構造体宣言の全てのプロパティが初期値を与えられたならば、構造体の省略時のイニシャライザを呼び出す、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように。
</span><!--end_jpstr-->
</li>
</ul>
<p>The process of initializing a structure’s declared properties is described in <a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">Initialization</span></a>.<br><span class="jpstr">
ある構造体の宣言されたプロパティを初期化する過程は、<a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">初期化</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p>Properties of a structure instance can be accessed using dot (<code class="docutils literal notranslate"><span class="pre">.</span></code>) syntax, as described in <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID86"><span class="std std-ref">Accessing Properties</span></a>.<br><span class="jpstr">
クラスインスタンスのプロパティにドット（<code class="docutils literal notranslate"><span class="pre">.</span></code>）構文でアクセスされることができます、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID86"><span class="std std-ref">プロパティにアクセスする</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p>Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call. For information about value types, see <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a>.<br><span class="jpstr">
構造体は、値型です；構造体のインスタンスは、変数や定数に代入される時、または関数呼び出しの引数として渡される時にコピーされます。値型に関して詳しくは、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">構造体と列挙は値型です</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>You can extend the behavior of a structure type with an extension declaration, as discussed in <a class="reference internal" href="#ID378"><span class="std std-ref">Extension Declaration</span></a>.<br><span class="jpstr">
あなたは構造体型の挙動を拡張宣言を使って拡張することができます、<a class="reference internal" href="#ID378"><span class="std std-ref">拡張宣言</span></a>で議論されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a structure declaration<br><span class="jpstr">
構造体宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_struct-declaration"></a>struct-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>struct</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-name">struct-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-body">struct-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_struct-name"></a>struct-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_struct-body"></a>struct-body</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-members">struct-members</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_struct-members"></a>struct-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-member">struct-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_struct-members">struct-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_struct-member"></a>struct-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p></div></div></div>
<div class="section" id="ID368">
<h2>Class Declaration<a class="headerlink" href="#ID368" title="Permalink to this headline">¶</a><br><span class="jpstr">
クラス宣言<a class="headerlink" href="#ID368" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>class declaration</em> introduces a named class type into your program. Class declarations are declared using the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword and have the following form:<br><span class="jpstr">
<em>クラス宣言</em>は、名前をつけられたクラス型をあなたのプログラムに導入します。クラス宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">class</span></code>を使用して宣言されて、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="gi">class name</span>: <span class="gi">superclass</span>, <span class="gi">adopted protocols</span> {
</li><li>    <span class="gi">declarations</span>
</li><li>}
</li></ol></div></div></div>
<p>The body of a class contains zero or more <em>declarations</em>. These <em>declarations</em> can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations. Class declarations can’t contain protocol declarations. For a discussion and several examples of classes that include various kinds of declarations, see <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html"><span class="doc">Structures and Classes</span></a>.<br><span class="jpstr">
クラスの本文は、０個以上の<em>宣言</em>を含みます。これらの<em>宣言</em>は、格納または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、一つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、および列挙宣言さえも含むことができます。クラス宣言は、プロトコル宣言を含むことができません。議論および、さまざまな種類の宣言を含むクラスの例のいくつかのために、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html"><span class="doc">構造体とクラス</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>A class type can inherit from only one parent class, its <em>superclass</em>, but can adopt any number of protocols. The <em>superclass</em> appears first after the <em>class name</em> and colon, followed by any <em>adopted protocols</em>. Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes. When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.<br><span class="jpstr">
クラス型は、ただ１つの親クラス、それの<em>スーパークラス</em>から継承することだけが許されます、しかし随意の数のプロトコルに準拠することはできます。<em>スーパークラス</em>がまず<em>クラス名</em>とコロンの後に現れ、続いて随意の<em>準拠するプロトコル</em>が続きます。総称体クラスは、他の総称体および非総称体クラスから継承することができます、しかし非総称体クラスはただ他の非総称体クラスからのみ継承することができます。あなたがコロンの後に総称体スーパークラスの名前を書く時、あなたはその総称体クラスの名前全体を、それの総称体パラメーター節を含めて書く必要があります。
</span><!--end_jpstr-->
</p>
<p>As discussed in <a class="reference internal" href="#ID375"><span class="std std-ref">Initializer Declaration</span></a>, classes can have designated and convenience initializers. The designated initializer of a class must initialize all of the class’s declared properties and it must do so before calling any of its superclass’s designated initializers.<br><span class="jpstr">
<a class="reference internal" href="#ID375"><span class="std std-ref">イニシャライザ宣言</span></a>で議論されるように、クラスは、指定および便宜イニシャライザを持つことができます。あるクラスの指定イニシャライザは、そのクラスの指定するプロパティのすべてを初期化しなければ成りません、そしてそれは何であれそれのスーパークラスの指定イニシャライザを呼ぶ前にそうしなければなりません。
</span><!--end_jpstr-->
</p>
<p>A class can override properties, methods, subscripts, and initializers of its superclass. Overridden properties, methods, subscripts, and designated initializers must be marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> declaration modifier.<br><span class="jpstr">
クラスは、それのスーパークラスのプロパティ、メソッド、添え字、そしてイニシャライザをオーバーライドすることができます。プロパティ、メソッド、添え字、そして指定イニシャライザのオーバーライドは、<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印されなければなりません。
</span><!--end_jpstr-->
</p>
<p>To require that subclasses implement a superclass’s initializer, mark the superclass’s initializer with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier. The subclass’s implementation of that initializer must also be marked with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier.<br><span class="jpstr">
あるスーパークラスの持つイニシャライザをそのサブクラスたちが実装することを要求するために、そのスーパークラスのイニシャライザを<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子で印してください。そのイニシャライザのサブクラスの実装もまた、<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子で印されなければなりません。
</span><!--end_jpstr-->
</p>
<p>Although properties and methods declared in the <em>superclass</em> are inherited by the current class, designated initializers declared in the <em>superclass</em> are only inherited when the subclass meets the conditions described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID222"><span class="std std-ref">Automatic Initializer Inheritance</span></a>. Swift classes do not inherit from a universal base class.<br><span class="jpstr">
<em>スーパークラス</em>の中で宣言されるプロパティやメソッドは現在のクラスによって継承されるけれども、<em>スーパークラス</em>の中で宣言される指定イニシャライザはただサブクラスが<a class="reference internal" href="../LanguageGuide/Initialization.html#ID222"><span class="std std-ref">自動的なイニシャライザ継承</span></a>で記述される条件と出会う場合に継承されるだけです。スウィフトのクラスたちは、ひとつの共通の基盤クラスから継承はしません。
</span><!--end_jpstr-->
</p>
<p>There are two ways to create an instance of a previously declared class:<br><span class="jpstr">
以前に宣言されたクラスのインスタンスをつくるには２つの方法があります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Call one of the initializers declared within the class, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID205"><span class="std std-ref">Initializers</span></a>.<br><span class="jpstr">
そのクラス内で宣言されるイニシャライザのうちの１つを呼び出す、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID205"><span class="std std-ref">イニシャライザ</span></a>で記述されるように。
</span><!--end_jpstr-->
</li>
<li>If no initializers are declared, and all properties of the class declaration were given initial values, call the class’s default initializer, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>.<br><span class="jpstr">
イニシャライザが宣言されない、そして全てのクラス宣言のプロパティが初期値を与えられるならば、クラスの省略時のイニシャライザを呼び出す、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように。
</span><!--end_jpstr-->
</li>
</ul>
<p>Access properties of a class instance with dot (<code class="docutils literal notranslate"><span class="pre">.</span></code>) syntax, as described in <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID86"><span class="std std-ref">Accessing Properties</span></a>.<br><span class="jpstr">
クラスインスタンスのプロパティにドット（<code class="docutils literal notranslate"><span class="pre">.</span></code>）構文でアクセスしてください、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID86"><span class="std std-ref">プロパティにアクセスする</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p>Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call. For information about reference types, see <a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a>.<br><span class="jpstr">
クラスは、参照型です；クラスのインスタンスは、変数または定数に代入されるとき、または関数呼び出しに対する引数として渡されるときに、コピーされるのではなく、参照されます。参照型に関して詳しくは、<a class="reference internal" href="../LanguageGuide/ClassesAndStructures.html#ID88"><span class="std std-ref">構造体と列挙は値型です</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>You can extend the behavior of a class type with an extension declaration, as discussed in <a class="reference internal" href="#ID378"><span class="std std-ref">Extension Declaration</span></a>.<br><span class="jpstr">
あなたはクラス型の挙動を拡張宣言を使って拡張することができます、<a class="reference internal" href="#ID378"><span class="std std-ref">拡張宣言</span></a>で議論されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a class declaration<br><span class="jpstr">
クラス宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-declaration"></a>class-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>final</code><sub>opt</sub> <code>class</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-name">class-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-body">class-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-declaration_1035"></a>class-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>final</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>class</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-name">class-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-body">class-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-name"></a>class-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-body"></a>class-body</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-members">class-members</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-members"></a>class-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-member">class-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_class-members">class-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_class-member"></a>class-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p></div></div></div>
<div class="section" id="ID369">
<h2>Protocol Declaration<a class="headerlink" href="#ID369" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコル宣言<a class="headerlink" href="#ID369" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>protocol declaration</em> introduces a named protocol type into your program. Protocol declarations are declared at global scope using the <code class="docutils literal notranslate"><span class="pre">protocol</span></code> keyword and have the following form:<br><span class="jpstr">
<em>プロトコル宣言</em>は、名前をつけられたプロトコル型をあなたのプログラムに導入します。プロトコル宣言は、グローバルなスコープでキーワード<code class="docutils literal notranslate"><span class="pre">protocol</span></code>を使って宣言されて、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="gi">protocol name</span>: <span class="gi">inherited protocols</span> {
</li><li>    <span class="gi">protocol member declarations</span>
</li><li>}
</li></ol></div></div></div>
<p>The body of a protocol contains zero or more <em>protocol member declarations</em>, which describe the conformance requirements that any type adopting the protocol must fulfill. In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts. Protocols can also declare special kinds of type aliases, called <em>associated types</em>, that can specify relationships among the various declarations of the protocol. Protocol declarations can’t contain class, structure, enumeration, or other protocol declarations. The <em>protocol member declarations</em> are discussed in detail below.<br><span class="jpstr">
プロトコルの本文は０以上の<em>プロトコルメンバー宣言</em>を含みます、それは、プロトコルを採用しているすべての型が満たさなければならない準拠要件を記述します。特に、プロトコルは、準拠している型が特定のプロパティ、メソッド、イニシャライザ、そして添え字を実装しなければならないと宣言することができます。プロトコルはまた、特別な種類の型エイリアス、そのプロトコルのいろいろな宣言の間での関係を指定することができる<em>関連型</em>と呼ばれるものを宣言することができます。プロトコル宣言は、クラス、構造体、列挙、または他のプロトコル宣言を含むことができません。<em>プロトコルメンバー宣言</em>は、詳細に下で議論されます。
</span><!--end_jpstr-->
</p>
<p>Protocol types can inherit from any number of other protocols. When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements. For an example of how to use protocol inheritance, see <a class="reference internal" href="../LanguageGuide/Protocols.html#ID280"><span class="std std-ref">Protocol Inheritance</span></a>.<br><span class="jpstr">
プロトコル型は、いくらかの他のプロトコルから継承することができます。あるプロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件一式は、ひとまとめにされます、そして現在のプロトコルから継承するどんな型でも、それらの要件の全てに従わなければなりません。プロトコル継承を使う方法の例のために、<a class="reference internal" href="../LanguageGuide/Protocols.html#ID280"><span class="std std-ref">プロトコル継承</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">You can also aggregate the conformance requirements of multiple protocols using protocol composition types, as described in <a class="reference internal" href="Types.html#ID454"><span class="std std-ref">Protocol Composition Type</span></a> and <a class="reference internal" href="../LanguageGuide/Protocols.html#ID282"><span class="std std-ref">Protocol Composition</span></a>.<br><span class="jpstr">
あなたは、また、<a class="reference internal" href="Types.html#ID454"><span class="std std-ref">プロトコル合成型</span></a>と<a class="reference internal" href="../LanguageGuide/Protocols.html#ID282"><span class="std std-ref">プロトコル合成</span></a>で記述されるように、複数のプロトコルの準拠要件をひとまとめにすることがプロトコル合成（コンポジション）型を使って可能です。
</span><!--end_jpstr-->
</p>
</div>
<p>You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type. In the extension, you must implement all of the adopted protocol’s requirements. If the type already implements all of the requirements, you can leave the body of the extension declaration empty.<br><span class="jpstr">
あなたは、プロトコル準拠を以前に宣言された型に加えることが、その型の拡張宣言においてそのプロトコルを採用することによってできます。拡張において、あなたは採用されたプロトコルの要件の全てを実装しなければなりません。その型が要件の全てをすでに実装するならば、あなたは拡張宣言の本文を空のままにしておいてかまいません。
</span><!--end_jpstr-->
</p>
<p>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol. That said, you can mark these protocol member declarations with the <code class="docutils literal notranslate"><span class="pre">optional</span></code> declaration modifier to specify that their implementation by a conforming type is optional. The <code class="docutils literal notranslate"><span class="pre">optional</span></code> modifier can be applied only to members that are marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute, and only to members of protocols that are marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements. For more information about how to use the <code class="docutils literal notranslate"><span class="pre">optional</span></code> declaration modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see <a class="reference internal" href="../LanguageGuide/Protocols.html#ID284"><span class="std std-ref">Optional Protocol Requirements</span></a>.<br><span class="jpstr">
初期状態では、あるプロトコルに準拠する型は、そのプロトコルにおいて宣言される全てのプロパティ、メソッド、そして添え字を実装しなければなりません。とは言え、 あなたはこれらのプロトコルメンバー宣言を<code class="docutils literal notranslate"><span class="pre">optional</span></code>宣言修飾子を使って印して、ある準拠型にとってそれらの実装が随意であると指定することができます。<code class="docutils literal notranslate"><span class="pre">optional</span></code>修飾子は、<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるメンバにだけ、そして<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるプロトコルのメンバにだけ適用されることができます。結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。<code class="docutils literal notranslate"><span class="pre">optional</span></code>宣言修飾子を働かせる方法に関する詳細は、そして、オプショナルのプロトコルメンバーにアクセスする方法 ― 例えば、ある準拠している型がそれらを実装するかどうかについてあなたが確信が持てない時など ― についての手引きとして<a class="reference internal" href="../LanguageGuide/Protocols.html#ID284"><span class="std std-ref">オプショナルのプロトコル要件</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>To restrict the adoption of a protocol to class types only, include the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> protocol in the <em>inherited protocols</em> list after the colon. For example, the following protocol can be adopted only by class types:<br><span class="jpstr">
あるプロトコルの採用をクラス型のみに制約するには、<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>プロトコルを<em>継承されたプロトコル</em>のリストの中にコロンの後で加えてください。例えば、以下のプロトコルはクラス型によってのみ採用されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span>: <span class="nc">AnyObject</span> {
</li><li>    <span class="c">/* Protocol members go here */</span>
</li><li>}
</li></ol></div></div></div>
<p>Any protocol that inherits from a protocol that’s marked with the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> requirement can likewise be adopted only by class types.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>要件で印されるプロトコルから継承するどんなプロトコルも、同じようにクラス型でのみ採用されることができます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">If a protocol is marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute, the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> requirement is implicitly applied to that protocol; there’s no need to mark the protocol with the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> requirement explicitly.<br><span class="jpstr">
あるプロトコルが<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるならば、<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>要件は暗黙的にそのプロトコルに適用されます；<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>要件で明示的に印する必要はありません。
</span><!--end_jpstr-->
</p>
</div>
<p>Protocols are named types, and thus they can appear in all the same places in your code as other named types, as discussed in <a class="reference internal" href="../LanguageGuide/Protocols.html#ID275"><span class="std std-ref">Protocols as Types</span></a>. However, you can’t construct an instance of a protocol, because protocols do not actually provide the implementations for the requirements they specify.<br><span class="jpstr">
プロトコルは名前をつけられた型です、したがってそれらはあなたのコードにおいて他の名前をつけられた型と同じ場所の全てにおいて現れることができます、<a class="reference internal" href="../LanguageGuide/Protocols.html#ID275"><span class="std std-ref">型としてのプロトコル</span></a>で議論されるように。しかし、あなたはプロトコルからインスタンスを造ることができません、なぜならプロトコルは実際にはそれらが指定する要件に対する実装を用意しないからです。
</span><!--end_jpstr-->
</p>
<p>You can use protocols to declare which methods a delegate of a class or structure should implement, as described in <a class="reference internal" href="../LanguageGuide/Protocols.html#ID276"><span class="std std-ref">Delegation</span></a>.<br><span class="jpstr">
あなたはプロトコルを使って、あるクラスまたは構造体から委任を受ける側が実装しなければならないのはどのメソッドかを宣言することができます、<a class="reference internal" href="../LanguageGuide/Protocols.html#ID276"><span class="std std-ref">委任</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol declaration<br><span class="jpstr">
プロトコル宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-declaration"></a>protocol-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>protocol</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-name">protocol-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-body">protocol-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-name"></a>protocol-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-body"></a>protocol-body</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-members">protocol-members</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-members"></a>protocol-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-member">protocol-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-members">protocol-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member"></a>protocol-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-member-declaration">protocol-member-declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-property-declaration">protocol-property-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration_1036"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-method-declaration">protocol-method-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration_1037"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-initializer-declaration">protocol-initializer-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration_1038"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-subscript-declaration">protocol-subscript-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration_1039"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_protocol-associated-type-declaration">protocol-associated-type-declaration</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-member-declaration_1040"></a>protocol-member-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-declaration">typealias-declaration</a></span> </p></div></div><div class="section" id="ID370">
<h3>Protocol Property Declaration<a class="headerlink" href="#ID370" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコルプロパティ宣言<a class="headerlink" href="#ID370" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Protocols declare that conforming types must implement a property by including a <em>protocol property declaration</em> in the body of the protocol declaration. Protocol property declarations have a special form of a variable declaration:<br><span class="jpstr">
プロトコルは、準拠している型がそのプロトコル宣言の本文の中の<em>プロトコルプロパティ宣言</em>を含めることによってプロパティを実装しなければならないことを宣言します。プロトコルプロパティ宣言は、変数宣言の特別な形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="gi">property name</span>: <span class="gi">type</span> { <span class="k">get</span> <span class="nv">set</span> }
</li></ol></div></div></div>
<p>As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol. As a result, you don’t implement the getter or setter directly in the protocol in which it is declared.<br><span class="jpstr">
他のプロトコルメンバー宣言と同様に、これらのプロパティ宣言はそのプロトコルに準拠する型のためのゲッターとセッター要件だけを宣言します。結果として、それが宣言されるプロトコルにおいて、あなたは直接ゲッターまたはセッターを実装しません。
</span><!--end_jpstr-->
</p>
<p>The getter and setter requirements can be satisfied by a conforming type in a variety of ways. If a property declaration includes both the <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> keywords, a conforming type can implement it with a stored variable property or a computed property that is both readable and writeable (that is, one that implements both a getter and a setter). However, that property declaration can’t be implemented as a constant property or a read-only computed property. If a property declaration includes only the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword, it can be implemented as any kind of property. For examples of conforming types that implement the property requirements of a protocol, see <a class="reference internal" href="../LanguageGuide/Protocols.html#ID269"><span class="std std-ref">Property Requirements</span></a>.<br><span class="jpstr">
ゲッターとセッター要件は、準拠している型によっていろいろなやり方で満たされることができます。あるプロパティ宣言が<code class="docutils literal notranslate"><span class="pre">get</span></code>と<code class="docutils literal notranslate"><span class="pre">set</span></code>キーワードを両方とも含むならば、準拠している型はそれを、格納変数プロパティや計算プロパティを使って実装することができます、それは読み出し可能と書き込み可能の両方であるものです（すなわち、ゲッターとセッターのどちらも実装できるもの）。しかし、そのプロパティ宣言は、定数プロパティまたは読み出し専用の計算プロパティとして実装されることができません。プロパティ宣言が<code class="docutils literal notranslate"><span class="pre">get</span></code>キーワードだけを含むならば、それはどんな種類のプロパティとしてでも実装されることができます。あるプロトコルのプロパティ要件を実装するものである、準拠している型の例のために、<a class="reference internal" href="../LanguageGuide/Protocols.html#ID269"><span class="std std-ref">プロパティ要件</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>See also <a class="reference internal" href="#ID356"><span class="std std-ref">Variable Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID356"><span class="std std-ref">変数の宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol property declaration<br><span class="jpstr">
プロトコルプロパティ宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-property-declaration"></a>protocol-property-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-declaration-head">variable-declaration-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_variable-name">variable-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-annotation">type-annotation</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-keyword-block">getter-setter-keyword-block</a></span> </p></div></div></div>
<div class="section" id="ID371">
<h3>Protocol Method Declaration<a class="headerlink" href="#ID371" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコルメソッド宣言<a class="headerlink" href="#ID371" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration. Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration. For examples of conforming types that implement the method requirements of a protocol, see <a class="reference internal" href="../LanguageGuide/Protocols.html#ID270"><span class="std std-ref">Method Requirements</span></a>.<br><span class="jpstr">
プロトコルが宣言するのは、準拠している型は、プロトコル宣言の本文中のプロトコルメソッド宣言を含めることによって、あるメソッドを実装する必要があるということです。プロトコルメソッド宣言は、２つの例外を除いて、関数宣言と同じ形式を持ちます：それらは関数本体を含むことができません、そして、あなたは関数宣言の一部として省略時のパラメータ値をまったく提供することができません。あるプロトコルのメソッド要件を満たすものである準拠している型の例のために、<a class="reference internal" href="../LanguageGuide/Protocols.html#ID270"><span class="std std-ref">メソッド要件</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the <code class="docutils literal notranslate"><span class="pre">static</span></code> declaration modifier. Classes that implement this method declare the method with the <code class="docutils literal notranslate"><span class="pre">class</span></code> modifier. Structures that implement it must declare the method with the <code class="docutils literal notranslate"><span class="pre">static</span></code> declaration modifier instead. If you’re implementing the method in an extension, use the <code class="docutils literal notranslate"><span class="pre">class</span></code> modifier if you’re extending a class and the <code class="docutils literal notranslate"><span class="pre">static</span></code> modifier if you’re extending a structure.<br><span class="jpstr">
クラスまたは静的メソッド要件をあるプロトコル宣言において宣言するために、そのメソッド宣言を<code class="docutils literal notranslate"><span class="pre">static</span></code>宣言修飾子で印してください。そのメソッドを実装するクラスは、このメソッドを<code class="docutils literal notranslate"><span class="pre">class</span></code>修飾子を使って宣言します。それを実装する構造体は、その代わりに<code class="docutils literal notranslate"><span class="pre">static</span></code>宣言修飾子を使ってメソッドを宣言しなければなりません。あなたがこのメソッドをある拡張の中で実装するならば、あなたがクラスを拡張しているなら<code class="docutils literal notranslate"><span class="pre">class</span></code>修飾子を、あなたが構造体を拡張しているなら<code class="docutils literal notranslate"><span class="pre">static</span></code>修飾子を使ってください。
</span><!--end_jpstr-->
</p>
<p>See also <a class="reference internal" href="#ID362"><span class="std std-ref">Function Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID362"><span class="std std-ref">関数宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol method declaration<br><span class="jpstr">
プロトコルメソッド宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-method-declaration"></a>protocol-method-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-head">function-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-name">function-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_function-signature">function-signature</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub></p></div></div></div>
<div class="section" id="ID372">
<h3>Protocol Initializer Declaration<a class="headerlink" href="#ID372" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコルイニシャライザ宣言<a class="headerlink" href="#ID372" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration. Protocol initializer declarations have the same form as initializer declarations, except they don’t include the initializer’s body.<br><span class="jpstr">
プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルイニシャライザ宣言を含めることによってイニシャライザを実装しなければならないと宣言します。プロトコルイニシャライザ宣言は、それらがイニシャライザ本文を含めないことを除いて、イニシャライザ宣言と同じ形式を持ちます。
</span><!--end_jpstr-->
</p>
<p>A conforming type can satisfy a nonfailable protocol initializer requirement by implementing a nonfailable initializer or an <code class="docutils literal notranslate"><span class="pre">init!</span></code> failable initializer. A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.<br><span class="jpstr">
ある準拠している型は、失敗できないプロトコルイニシャライザ要件を満たすことが、失敗できないイニシャライザまたは<code class="docutils literal notranslate"><span class="pre">init!</span></code>失敗できるイニシャライザを実装することによって可能です。ある準拠している型は、失敗できるプロトコルイニシャライザ要件を満たすことが、どんな種類のイニシャライザを実装することによっても可能です。
</span><!--end_jpstr-->
</p>
<p>When a class implements an initializer to satisfy a protocol’s initializer requirement, the initializer must be marked with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier if the class is not already marked with the <code class="docutils literal notranslate"><span class="pre">final</span></code> declaration modifier.<br><span class="jpstr">
あるクラスがプロトコルのイニシャライザ要件を満たすためにイニシャライザを実装するとき、そのイニシャライザは<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子を使って印される必要が、そのクラスが既に<code class="docutils literal notranslate"><span class="pre">final</span></code>宣言修飾子を使って印されていないならば、あります。
</span><!--end_jpstr-->
</p>
<p>See also <a class="reference internal" href="#ID375"><span class="std std-ref">Initializer Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID375"><span class="std std-ref">イニシャライザ宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol initializer declaration<br><span class="jpstr">
プロトコル・イニシャライザ宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-initializer-declaration"></a>protocol-initializer-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-head">initializer-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>throws</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-initializer-declaration_1041"></a>protocol-initializer-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-head">initializer-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>rethrows</code> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub></p></div></div></div>
<div class="section" id="ID373">
<h3>Protocol Subscript Declaration<a class="headerlink" href="#ID373" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコル添え字宣言<a class="headerlink" href="#ID373" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration. Protocol subscript declarations have a special form of a subscript declaration:<br><span class="jpstr">
プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコル添え字宣言を含めることによって添え字を実装しなければならないと宣言します。プロトコル添え字宣言は、添え字宣言の特別な形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">subscript</span> (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> { <span class="k">get</span> <span class="nv">set</span> }
</li></ol></div></div></div>
<p>Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol. If the subscript declaration includes both the <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> keywords, a conforming type must implement both a getter and a setter clause. If the subscript declaration includes only the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword, a conforming type must implement <em>at least</em> a getter clause and optionally can implement a setter clause.<br><span class="jpstr">
添え字宣言は、プロトコルに準拠する型のための最小限のゲッターとセッター実装要件を宣言するだけです。添え字宣言が<code class="docutils literal notranslate"><span class="pre">get</span></code>と<code class="docutils literal notranslate"><span class="pre">set</span></code>キーワードを両方とも含むならば、準拠している型はゲッターとセッター節を両方とも実装しなければなりません。添え字宣言が<code class="docutils literal notranslate"><span class="pre">get</span></code>キーワードだけを含むならば、準拠している型は、<em>少なくとも</em>ゲッター節を実装しなければなりません、そして随意にセッター節を実装することができます。
</span><!--end_jpstr-->
</p>
<p>See also <a class="reference internal" href="#ID379"><span class="std std-ref">Subscript Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID379"><span class="std std-ref">添え字宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol subscript declaration<br><span class="jpstr">
プロトコル添え字宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-subscript-declaration"></a>protocol-subscript-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-head">subscript-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-result">subscript-result</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-keyword-block">getter-setter-keyword-block</a></span> </p></div></div></div>
<div class="section" id="ID374">
<h3>Protocol Associated Type Declaration<a class="headerlink" href="#ID374" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコル関連型宣言<a class="headerlink" href="#ID374" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Protocols declare associated types using the <code class="docutils literal notranslate"><span class="pre">associatedtype</span></code> keyword. An associated type provides an alias for a type that is used as part of a protocol’s declaration. Associated types are similar to type parameters in generic parameter clauses, but they’re associated with <code class="docutils literal notranslate"><span class="pre">Self</span></code> in the protocol in which they’re declared. In that context, <code class="docutils literal notranslate"><span class="pre">Self</span></code> refers to the eventual type that conforms to the protocol. For more information and examples, see <a class="reference internal" href="../LanguageGuide/Generics.html#ID189"><span class="std std-ref">Associated Types</span></a>.<br><span class="jpstr">
プロトコルは、関連型をキーワード<code class="docutils literal notranslate"><span class="pre">associatedtype</span></code>を使って宣言します。関連型は、エイリアスをプロトコルの宣言の一部として使われる型のために用意します。関連型は、総称体パラメータ節の中の型パラメータに似ています、しかしそれらは、それらが宣言されるプロトコルにおいて<code class="docutils literal notranslate"><span class="pre">Self</span></code>と結び付けられます。その文脈で、<code class="docutils literal notranslate"><span class="pre">Self</span></code>はそのプロトコルに準拠する結果として生じる型に言及します。より多くの情報と例のために、<a class="reference internal" href="../LanguageGuide/Generics.html#ID189"><span class="std std-ref">関連型</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>You use a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause in a protocol declaration to add constraints to an associated types inherited from another protocol, without redeclaring the associated types. For example, the declarations of <code class="docutils literal notranslate"><span class="pre">SubProtocol</span></code> below are equivalent:<br><span class="jpstr">
あなたは、総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節をプロトコル宣言の中で使うことで、別のプロトコルから継承された関連型に制約を追加します、その関連型を再宣言することなしに。例えば、下の<code class="docutils literal notranslate"><span class="pre">SubProtocol</span></code>の宣言は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li><li>    <span class="k">associatedtype</span> <span class="nv">SomeType</span>
</li><li>}
</li><li>
</li><li><span class="k">protocol</span> <span class="nv">SubProtocolA</span>: <span class="nc">SomeProtocol</span> {
</li><li>    <span class="c">// This syntax produces a warning.&nbsp;<span class="jpstr">（この構文は警告を生成します。）</span><!--end_jpstr-->
</span>
</li><li>    <span class="k">associatedtype</span> <span class="nv">SomeType</span>: <span class="nc">Equatable</span>
</li><li>}
</li><li>
</li><li><span class="c">// This syntax is preferred.&nbsp;<span class="jpstr">（この構文はより好まれます。）</span><!--end_jpstr-->
</span>
</li><li><span class="k">protocol</span> <span class="nv">SubProtocolB</span>: <span class="nc">SomeProtocol</span> <span class="k">where</span> <span class="nc">SomeType</span>: <span class="nc">Equatable</span> { }
</li></ol></div></div></div>
<p>See also <a class="reference internal" href="#ID361"><span class="std std-ref">Type Alias Declaration</span></a>.<br><span class="jpstr">
また、<a class="reference internal" href="#ID361"><span class="std std-ref">型エイリアス宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a protocol associated type declaration<br><span class="jpstr">
プロトコル関連型宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_protocol-associated-type-declaration"></a>protocol-associated-type-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>associatedtype</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-name">typealias-name</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_typealias-assignment">typealias-assignment</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub></p></div></div></div>
</div>
<div class="section" id="ID375">
<h2>Initializer Declaration<a class="headerlink" href="#ID375" title="Permalink to this headline">¶</a><br><span class="jpstr">
イニシャライザ宣言<a class="headerlink" href="#ID375" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>An <em>initializer declaration</em> introduces an initializer for a class, structure, or enumeration into your program. Initializer declarations are declared using the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword and have two basic forms.<br><span class="jpstr">
<em>イニシャライザ宣言</em>は、あなたのプログラムにクラス、構造体、または列挙のためのイニシャライザを導入します。イニシャライザ宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">init</span></code>を使って宣言されて、２つの基本の書式を持ちます。
</span><!--end_jpstr-->
</p>
<p>Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different. Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in <a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">Initialization</span></a>.<br><span class="jpstr">
構造体、列挙、そしてクラス型は、随意の数のイニシャライザを持つことができます、しかし、クラスイニシャライザのための規則および関連する挙動は異なります。構造体や列挙と違って、クラスは２種類のイニシャライザを持ちます：指定イニシャライザと便宜イニシャライザ、<a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">初期化</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p>The following form declares initializers for structures, enumerations, and designated initializers of classes:<br><span class="jpstr">
以下の形式は、構造体、列挙のイニシャライザ、そしてクラスの指定イニシャライザを宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">init</span>(<span class="gi">parameters</span>) {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>A designated initializer of a class initializes all of the class’s properties directly. It can’t call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass’s designated initializers. If the class inherits any properties from its superclass, one of the superclass’s designated initializers must be called before any of these properties can be set or modified in the current class.<br><span class="jpstr">
あるクラスの指定イニシャライザは、直接そのクラスのプロパティの全てを初期化します。それは同じクラスの他のどのイニシャライザも呼ぶことができません、そしてそのクラスがスーパークラスを持つならば、それはスーパークラスの指定イニシャライザのうちの１つを呼ばなければなりません。クラスが何らかのプロパティをそのスーパークラスから受け継ぐならば、これらのプロパティのどれかが現在のクラスにおいて設定または修正されることができる前に、スーパークラスの指定イニシャライザのうちの１つが呼ばれなければなりません。
</span><!--end_jpstr-->
</p>
<p>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.<br><span class="jpstr">
指定イニシャライザは、クラス宣言の文脈においてのみ宣言されることができて、したがって拡張宣言を使ってあるクラスに加えられることはできません。
</span><!--end_jpstr-->
</p>
<p>Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.<br><span class="jpstr">
構造体および列挙のイニシャライザは、初期化プロセスの一部または全てを委任するために他の宣言済みイニシャライザを呼ぶことができます。
</span><!--end_jpstr-->
</p>
<p>To declare convenience initializers for a class, mark the initializer declaration with the <code class="docutils literal notranslate"><span class="pre">convenience</span></code> declaration modifier.<br><span class="jpstr">
あるクラスの便宜イニシャライザを宣言するために、そのイニシャライザ宣言を<code class="docutils literal notranslate"><span class="pre">convenience</span></code>宣言修飾子を使って印してください。
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">convenience</span> <span class="k">init</span>(<span class="gi">parameters</span>) {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class’s designated initializers. That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class’s properties. Convenience initializers can’t call a superclass’s initializers.<br><span class="jpstr">
便宜イニシャライザは、初期化プロセスを別の便宜イニシャライザに、またはそのクラスの指定イニシャライザのうちの１つに委任することができます。とは言え、 初期化プロセスは、最終的にそのクラスのプロパティを初期化する指定イニシャライザに対する呼び出しで終わらなければなりません。便宜イニシャライザは、スーパークラスのイニシャライザを呼ぶことができません。
</span><!--end_jpstr-->
</p>
<p>You can mark designated and convenience initializers with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier to require that every subclass implement the initializer. A subclass’s implementation of that initializer must also be marked with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier.<br><span class="jpstr">
あなたは指定および便宜イニシャライザを<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子で印して、全てのサブクラスがそのイニシャライザを実装することが必須であるようにすることができます。そのイニシャライザのサブクラスでの実装は、また、<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子で印されなければなりません。
</span><!--end_jpstr-->
</p>
<p>By default, initializers declared in a superclass are not inherited by subclasses. That said, if a subclass initializes all of its stored properties with default values and doesn’t define any initializers of its own, it inherits all of the superclass’s initializers. If the subclass overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.<br><span class="jpstr">
初期状態では、スーパークラスで宣言されるイニシャライザは、サブクラスによって継承されません。とは言え、サブクラスがそれの格納プロパティのすべてを省略時の値で初期化して、それ自身のイニシャライザを全く定義しないならば、それはそのスーパークラスのイニシャライザのすべてを継承します。サブクラスがスーパークラスの指定イニシャライザのすべてをオーバーライドするならば、それはスーパークラスの便宜イニシャライザたちを継承します。
</span><!--end_jpstr-->
</p>
<p>As with methods, properties, and subscripts, you need to mark overridden designated initializers with the <code class="docutils literal notranslate"><span class="pre">override</span></code> declaration modifier.<br><span class="jpstr">
メソッド、プロパティ、そして添え字と同様に、あなたはオーバーライドした指定イニシャライザを<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印する必要があります。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">If you mark an initializer with the <code class="docutils literal notranslate"><span class="pre">required</span></code> declaration modifier, you don’t also mark the initializer with the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when you override the required initializer in a subclass.<br><span class="jpstr">
あなたがイニシャライザを<code class="docutils literal notranslate"><span class="pre">required</span></code>宣言修飾子で印するならば、あなたはさらにそのイニシャライザを<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印することは、あなたがサブクラスの必須イニシャライザをオーバーライドする場合には、しません。
</span><!--end_jpstr-->
</p>
</div>
<p>Just like functions and methods, initializers can throw or rethrow errors. And just like functions and methods, you use the <code class="docutils literal notranslate"><span class="pre">throws</span></code> or <code class="docutils literal notranslate"><span class="pre">rethrows</span></code> keyword after an initializer’s parameters to indicate the appropriate behavior.<br><span class="jpstr">
関数やメソッドのように、イニシャライザはエラーをスローまたは再スローできます。そして関数やメソッドのように、あなたは<code class="docutils literal notranslate"><span class="pre">throws</span></code>または<code class="docutils literal notranslate"><span class="pre">rethrows</span></code>キーワードをイニシャライザのパラメータの後に使って、ふさわしい挙動を指し示すことができます。
</span><!--end_jpstr-->
</p>
<p>To see examples of initializers in various type declarations, see <a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">Initialization</span></a>.<br><span class="jpstr">
いろいろな型宣言におけるイニシャライザの例を見るために、<a class="reference internal" href="../LanguageGuide/Initialization.html"><span class="doc">初期化</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID376">
<h3>Failable Initializers<a class="headerlink" href="#ID376" title="Permalink to this headline">¶</a><br><span class="jpstr">
失敗できるイニシャライザ<a class="headerlink" href="#ID376" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A <em>failable initializer</em> is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on. As a result, a failable initializer can return <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate that initialization failed.<br><span class="jpstr">
<em>失敗できるイニシャライザ</em>は、イニシャライザの一種で、そのイニシャライザが宣言されている型の、オプショナルのインスタンスまたは暗黙的にアンラップされるオプショナルのインスタンスを生成します。結果として、失敗できるイニシャライザは、そのイニシャライザが失敗したのを指し示すために<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返すことができます。
</span><!--end_jpstr-->
</p>
<p>To declare a failable initializer that produces an optional instance, append a question mark to the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword in the initializer declaration (<code class="docutils literal notranslate"><span class="pre">init?</span></code>). To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation mark instead (<code class="docutils literal notranslate"><span class="pre">init!</span></code>). The example below shows an <code class="docutils literal notranslate"><span class="pre">init?</span></code> failable initializer that produces an optional instance of a structure.<br><span class="jpstr">
オプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、イニシャライザ宣言において疑問符を<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードに加えてください（<code class="docutils literal notranslate"><span class="pre">init?</span></code>）。暗黙的にアンラップされるオプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、代わりに感嘆符を加えてください（<code class="docutils literal notranslate"><span class="pre">init!</span></code>）。下の例は、ある構造体のオプショナルインスタンスを生成する、失敗できるイニシャライザ<code class="docutils literal notranslate"><span class="pre">init?</span></code>を示します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStruct</span> {
</li><li>    <span class="k">let</span> <span class="nv">property</span>: <span class="nc">String</span>
</li><li>    <span class="c">// produces an optional instance of &#39;SomeStruct&#39;&nbsp;<span class="jpstr">（「SomeStruct」のオプショナルインスタンスを生成します）</span><!--end_jpstr-->
</span>
</li><li>    <span class="k">init</span>?(<span class="nv">input</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">if</span> <span class="nv">input</span>.<span class="nv">isEmpty</span> {
</li><li>            <span class="c">// discard &#39;self&#39; and return &#39;nil&#39;&nbsp;<span class="jpstr">（「self」を廃棄して「nil」を返します）</span><!--end_jpstr-->
</span>
</li><li>            <span class="k">return</span> <span class="k">nil</span>
</li><li>        }
</li><li>        <span class="nv">property</span> = <span class="nv">input</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>You call an <code class="docutils literal notranslate"><span class="pre">init?</span></code> failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.<br><span class="jpstr">
あなたは失敗できるイニシャライザ<code class="docutils literal notranslate"><span class="pre">init?</span></code>を、オプショナルの結果を処理する必要があることを除き、失敗できないイニシャライザを呼び出すのと同じ方法で呼び出します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">actualInstance</span> = <span class="nv">SomeStruct</span>(<span class="nv">input</span>: <span class="s">&quot;Hello&quot;</span>) {
</li><li>    <span class="c">// do something with the instance of &#39;SomeStruct&#39;&nbsp;<span class="jpstr">（「SomeStruct」のインスタンスで何か行う）</span><!--end_jpstr-->
</span>
</li><li>} <span class="k">else</span> {
</li><li>    <span class="c">// initialization of &#39;SomeStruct&#39; failed and the initializer returned &#39;nil&#39;&nbsp;<span class="jpstr">（「SomeStruct」の初期化は失敗したのでイニシャライザは「nil」を返した）</span><!--end_jpstr-->
</span>
</li><li>}
</li></ol></div></div></div>
<p>A failable initializer can return <code class="docutils literal notranslate"><span class="pre">nil</span></code> at any point in the implementation of the initializer’s body.<br><span class="jpstr">
失敗できるイニシャライザは、そのイニシャライザの本文の中の任意の地点で<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返すことができます。
</span><!--end_jpstr-->
</p>
<p>A failable initializer can delegate to any kind of initializer. A nonfailable initializer can delegate to another nonfailable initializer or to an <code class="docutils literal notranslate"><span class="pre">init!</span></code> failable initializer. A nonfailable initializer can delegate to an <code class="docutils literal notranslate"><span class="pre">init?</span></code> failable initializer by force-unwrapping the result of the superclass’s initializer—for example, by writing <code class="docutils literal notranslate"><span class="pre">super.init()!</span></code>.<br><span class="jpstr">
失敗できるイニシャライザは、あらゆる種類のイニシャライザへ委任することができます。失敗できないイニシャライザは、別の失敗できないイニシャライザへ、または失敗できるイニシャライザ<code class="docutils literal notranslate"><span class="pre">init!</span></code>へ委任することができます。失敗できないイニシャライザは、<code class="docutils literal notranslate"><span class="pre">init?</span></code>失敗できるイニシャライザに委任することが、スーパークラスのイニシャライザの結果を強制アンラップすることによって可能です ― 例えば、<code class="docutils literal notranslate"><span class="pre">super.init()!</span></code>と書くことによって。
</span><!--end_jpstr-->
</p>
<p>Initialization failure propagates through initializer delegation. Specifically, if a failable initializer delegates to an initializer that fails and returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>, then the initializer that delegated also fails and implicitly returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>. If a nonfailable initializer delegates to an <code class="docutils literal notranslate"><span class="pre">init!</span></code> failable initializer that fails and returns <code class="docutils literal notranslate"><span class="pre">nil</span></code>, then a runtime error is raised (as if you used the <code class="docutils literal notranslate"><span class="pre">!</span></code> operator to unwrap an optional that has a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value).<br><span class="jpstr">
初期化失敗は、イニシャライザ委任を通じて伝えられます。具体的には、失敗できるイニシャライザが、ある失敗して<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返すイニシャライザへ委任するならば、その時その委任した側のイニシャライザもまた失敗して暗黙的に<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返します。失敗できないイニシャライザが、ある失敗して<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返す失敗できるイニシャライザ<code class="docutils literal notranslate"><span class="pre">init!</span></code>へと委任するならば、その時は実行時エラーが（まるであなたが<code class="docutils literal notranslate"><span class="pre">nil</span></code>の値を持つオプショナルをアンラップするために<code class="docutils literal notranslate"><span class="pre">!</span></code>演算子を使ったかのように）引き起こされます。
</span><!--end_jpstr-->
</p>
<p>A failable designated initializer can be overridden in a subclass by any kind of designated initializer. A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.<br><span class="jpstr">
失敗できる指定イニシャライザは、サブクラスにおいて任意の種類の指定イニシャライザでオーバーライドされることができます。失敗できない指定イニシャライザは、サブクラスにおいて失敗できない指定イニシャライザでのみオーバーライドされることができます。
</span><!--end_jpstr-->
</p>
<p>For more information and to see examples of failable initializers, see <a class="reference internal" href="../LanguageGuide/Initialization.html#ID224"><span class="std std-ref">Failable Initializers</span></a>.<br><span class="jpstr">
さらなる情報と、失敗できるイニシャライザの例を見るために、<a class="reference internal" href="../LanguageGuide/Initialization.html#ID224"><span class="std std-ref">失敗できるイニシャライザ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an initializer declaration<br><span class="jpstr">
イニシャライザ宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-declaration"></a>initializer-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-head">initializer-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>throws</code><sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-body">initializer-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-declaration_1042"></a>initializer-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-head">initializer-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span>  <code>rethrows</code> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_initializer-body">initializer-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-head"></a>initializer-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>init</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-head_1043"></a>initializer-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>init</code> <code>?</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-head_1044"></a>initializer-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>init</code> <code>!</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_initializer-body"></a>initializer-body</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p></div></div></div>
</div>
<div class="section" id="ID377">
<h2>Deinitializer Declaration<a class="headerlink" href="#ID377" title="Permalink to this headline">¶</a><br><span class="jpstr">
デイニシャライザ宣言<a class="headerlink" href="#ID377" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>deinitializer declaration</em> declares a deinitializer for a class type. Deinitializers take no parameters and have the following form:<br><span class="jpstr">
<em>デイニシャライザ宣言</em>は、クラス型のためにデイニシャライザを宣言します。デイニシャライザは、パラメータを取らない以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">deinit</span> {
</li><li>    <span class="gi">statements</span>
</li><li>}
</li></ol></div></div></div>
<p>A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated. A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.<br><span class="jpstr">
デイニシャライザは、あるクラスオブジェクトに対するいかなる参照ももはやない時、そのクラスオブジェクトが割り当て解除される直前に、自動的に呼ばれます。デイニシャライザは、クラス宣言の本文においてのみ ― しかしクラスの拡張においてではなく ― 宣言されることができます、そして各クラスが多くとも１つしか持つことができません。
</span><!--end_jpstr-->
</p>
<p>A subclass inherits its superclass’s deinitializer, which is implicitly called just before the subclass object is deallocated. The subclass object is not deallocated until all deinitializers in its inheritance chain have finished executing.<br><span class="jpstr">
サブクラスはそのスーパークラスのデイニシャライザを継承します、それは、サブクラスオブジェクトが割り当て解除される直前に、暗黙のうちに呼ばれます。サブクラスオブジェクトは、その継承連鎖の中の全てのデイニシャライザが実行を終えるまで、割り当て解除されません。
</span><!--end_jpstr-->
</p>
<p>Deinitializers are not called directly.<br><span class="jpstr">
デイニシャライザは、直接に呼ばれません。
</span><!--end_jpstr-->
</p>
<p>For an example of how to use a deinitializer in a class declaration, see <a class="reference internal" href="../LanguageGuide/Deinitialization.html"><span class="doc">Deinitialization</span></a>.<br><span class="jpstr">
クラス宣言においてデイニシャライザを使う方法の例のために、<a class="reference internal" href="../LanguageGuide/Deinitialization.html"><span class="doc">デイニシャライズ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a deinitializer declaration<br><span class="jpstr">
デイニシャライザ宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_deinitializer-declaration"></a>deinitializer-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <code>deinit</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p></div></div></div>
<div class="section" id="ID378">
<h2>Extension Declaration<a class="headerlink" href="#ID378" title="Permalink to this headline">¶</a><br><span class="jpstr">
拡張宣言<a class="headerlink" href="#ID378" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>An <em>extension declaration</em> allows you to extend the behavior of existing types. Extension declarations are declared using the <code class="docutils literal notranslate"><span class="pre">extension</span></code> keyword and have the following form:<br><span class="jpstr">
<em>拡張宣言</em>があなたに可能にするのは、既存の型の挙動を拡張することです。拡張宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">extension</span></code>キーワードを使って宣言され、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="gi">type name</span> <span class="k">where</span> <span class="gi">requirements</span> {
</li><li>    <span class="gi">declarations</span>
</li><li>}
</li></ol></div></div></div>
<p>The body of an extension declaration contains zero or more <em>declarations</em>. These <em>declarations</em> can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations. Extension declarations can’t contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations. Declarations in a protocol extension can’t be marked <code class="docutils literal notranslate"><span class="pre">final</span></code>. For a discussion and several examples of extensions that include various kinds of declarations, see <a class="reference internal" href="../LanguageGuide/Extensions.html"><span class="doc">Extensions</span></a>.<br><span class="jpstr">
拡張宣言の本文は、０個以上の<em>宣言</em>を含みます。これらの<em>宣言</em>は、計算プロパティ、計算型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字宣言、そしてクラス、構造体、そして列挙宣言さえも含むことができます。拡張宣言は、デイニシャライザまたはプロトコル宣言、格納プロパティ、プロパティオブザーバー、または他の拡張宣言を含むことができません。プロトコル拡張の中の宣言は、<code class="docutils literal notranslate"><span class="pre">final</span></code>で印されることができません。いろいろな種類の宣言を含む拡張の解説といくつかの例のために、<a class="reference internal" href="../LanguageGuide/Extensions.html"><span class="doc">拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>If the <em>type name</em> is a class, structure, or enumeration type, the extension extends that type. If the <em>type name</em> is a protocol type, the extension extends all types that conform to that protocol.<br><span class="jpstr">
<em>type name</em>がクラス、構造体、または列挙型ならば、その拡張はその型を拡張します。<em>type name</em>がプロトコル型ならば、その拡張はそのプロトコルに準拠するすべての型を拡張します。
</span><!--end_jpstr-->
</p>
<p>Extension declarations that extend a generic type or a protocol with associated types can include <em>requirements</em>. If an instance of the extended type or of a type that conforms to the extended protocol satisfies the <em>requirements</em>, the instance gains the behavior specified in the declaration.<br><span class="jpstr">
総称体型またはプロトコルを関連型で拡張する拡張宣言は、<em>requirements いくつかの要件</em>を含むことができます。拡張された型のまたは拡張されたプロトコルに準拠する型のインスタンスが<em>requirements 要件</em>を満たすならば、そのインスタンスは宣言において指定される挙動を獲得します。
</span><!--end_jpstr-->
</p>
<p>Extension declarations can contain initializer declarations. That said, if the type you’re extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.<br><span class="jpstr">
拡張宣言は、イニシャライザ宣言を含むことができます。とは言え、 あなたが拡張している型が別のモジュールにおいて定義されるならば、イニシャライザ宣言はそのモジュールですでに定義されるイニシャライザに委任して、その型のメンバーが正しく初期化されることを確実にしなければなりません。
</span><!--end_jpstr-->
</p>
<p>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.<br><span class="jpstr">
既存の型のプロパティ、メソッド、そしてイニシャライザは、その型の拡張においてオーバーライドされることができません。
</span><!--end_jpstr-->
</p>
<p>Extension declarations can add protocol conformance to an existing class, structure, or enumeration type by specifying <em>adopted protocols</em>:<br><span class="jpstr">
拡張宣言は、プロトコル準拠を既存のクラス、構造体、または列挙型に加えることが<em>adopted protocols 採用プロトコル</em>を指定することによって可能です：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="gi">type name</span>: <span class="gi">adopted protocols</span> <span class="k">where</span> <span class="gi">requirements</span> {
</li><li>    <span class="gi">declarations</span>
</li><li>}
</li></ol></div></div></div>
<p>Extension declarations can’t add class inheritance to an existing class, and therefore you can specify only a list of protocols after the <em>type name</em> and colon.<br><span class="jpstr">
拡張宣言は、クラス継承を既存のクラスに加えることができません、従ってあなたは幾らかのプロトコルからなるリストのみを<em>type name 型名</em>とコロンの後に指定することができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID576">
<h3>Conditional Conformance<a class="headerlink" href="#ID576" title="Permalink to this headline">¶</a><br><span class="jpstr">
条件準拠<a class="headerlink" href="#ID576" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>You can extend a generic type to conditionally conform to a protocol, so that instances of the type conform to the protocol only when certain requirements are met. You add conditional conformance to a protocol by including <em>requirements</em> in an extension declaration.<br><span class="jpstr">
あなたは、条件付きでプロトコルに準拠するように総称体型を拡張できます、それでその型のインスタンスは特定の要件が満たされた場合にのみそのプロトコルに準拠します。あなたは、あるプロトコルに対する条件準拠を加えることを、<em>要件</em>を拡張宣言に含めることによって行います。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID577">
<h4>Overridden Requirements Aren’t Used in Some Generic Contexts<a class="headerlink" href="#ID577" title="Permalink to this headline">¶</a><br><span class="jpstr">
オーバーライドされた要件はいくつかの総称体文脈では使われません<a class="headerlink" href="#ID577" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>In some generic contexts, types that get behavior from conditional conformance to a protocol don’t always use the specialized implementations of that protocol’s requirements. To illustrate this behavior, the following example defines two protocols and a generic type that conditionally conforms to both protocols.<br><span class="jpstr">
いくつかの総称体文脈では、あるプロトコルに対する条件準拠由来の挙動を持つ型は、そのプロトコルの要件の特殊化された実装を必ず使うとは限りません。この挙動を図解するために、以下の例は２つのプロトコルおよび両方のプロトコルに条件付きで準拠する１つの総称体型を定義します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Loggable</span> {
</li><li>    <span class="k">func</span> <span class="nv">log</span>()
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">Loggable</span> {
</li><li>    <span class="k">func</span> <span class="nv">log</span>() {
</li><li>        <span class="nv">print</span>(<span class="k">self</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">protocol</span> <span class="nv">TitledLoggable</span>: <span class="nc">Loggable</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">logTitle</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">TitledLoggable</span> {
</li><li>    <span class="k">func</span> <span class="nv">log</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;</span>\<span class="p">(</span><span class="k">Self</span>.<span class="nv">logTitle</span><span class="p">)</span><span class="s">: </span>\<span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="s">&quot;</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">struct</span> <span class="nv">Pair</span>&lt;<span class="nv">T</span>&gt;: <span class="nc">CustomStringConvertible</span> {
</li><li>    <span class="k">let</span> <span class="nv">first</span>: <span class="nc">T</span>
</li><li>    <span class="k">let</span> <span class="nv">second</span>: <span class="nc">T</span>
</li><li>    <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">&quot;(</span>\<span class="p">(</span><span class="nv">first</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">second</span><span class="p">)</span><span class="s">)&quot;</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Pair</span>: <span class="nc">Loggable</span> <span class="k">where</span> <span class="nc">T</span>: <span class="nc">Loggable</span> { }
</li><li><span class="k">extension</span> <span class="nc">Pair</span>: <span class="nc">TitledLoggable</span> <span class="k">where</span> <span class="nc">T</span>: <span class="nc">TitledLoggable</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">logTitle</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">&quot;Pair of &#39;</span>\<span class="p">(</span><span class="nv">T</span>.<span class="nv">logTitle</span><span class="p">)</span><span class="s">&#39;&quot;</span>
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">String</span>: <span class="nc">TitledLoggable</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">logTitle</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">&quot;String&quot;</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">Pair</span></code> structure conforms to <code class="docutils literal notranslate"><span class="pre">Loggable</span></code> and <code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code> whenever its generic type conforms to <code class="docutils literal notranslate"><span class="pre">Loggable</span></code> or <code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>, respectively. In the example below, <code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">Pair&lt;String&gt;</span></code>, which conforms to <code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code> because <code class="docutils literal notranslate"><span class="pre">String</span></code> conforms to <code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>. When the <code class="docutils literal notranslate"><span class="pre">log()</span></code> method is called on <code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code> directly, the specialized version containing the title string is used.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Pair</span></code>構造体は、<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>および<code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>に準拠します、それの総称体型がそれぞれ<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>または<code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>に準拠する時はいつでも。下の例において、<code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code>は<code class="docutils literal notranslate"><span class="pre">Pair&lt;String&gt;</span></code>のインスタンスです、それは<code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>に準拠します、なぜなら<code class="docutils literal notranslate"><span class="pre">String</span></code>は<code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>に準拠するからです。<code class="docutils literal notranslate"><span class="pre">log()</span></code>メソッドが<code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code>において直接に呼び出される時、タイトル文字列を含んでいる特殊化版が使われます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">oneAndTwo</span> = <span class="nv">Pair</span>(<span class="nv">first</span>: <span class="s">&quot;one&quot;</span>, <span class="nv">second</span>: <span class="s">&quot;two&quot;</span>)
</li><li><span class="nv">oneAndTwo</span>.<span class="nv">log</span>()
</li><li><span class="c">// Prints &quot;Pair of &#39;String&#39;: (one, two)&quot;</span>
</li></ol></div></div></div>
<p>However, when <code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code> is used in a generic context or as an instance of the <code class="docutils literal notranslate"><span class="pre">Loggable</span></code> protocol, the specialized version isn’t used. Swift picks which implementation of <code class="docutils literal notranslate"><span class="pre">log()</span></code> to call by consulting only the minimum requirements that <code class="docutils literal notranslate"><span class="pre">Pair</span></code> needs to conform to <code class="docutils literal notranslate"><span class="pre">Loggable</span></code>. For this reason, the default implementation provided by the <code class="docutils literal notranslate"><span class="pre">Loggable</span></code> protocol is used instead.<br><span class="jpstr">
しかしながら、<code class="docutils literal notranslate"><span class="pre">oneAndTwo</span></code>がある総称体文脈においてまたは<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>プロトコルのインスタンスとして使われる場合、この特殊化版は使用されません。スウィフトは、<code class="docutils literal notranslate"><span class="pre">log()</span></code>の実装のどれを呼び出すかの選択を、<code class="docutils literal notranslate"><span class="pre">Pair</span></code>が<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>に準拠するために必要とする最小限の要件のみを考慮することで行います。この理由のために、<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>プロトコルによって提供される省略時の実装が代わりに使われます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">doSomething</span>&lt;<span class="nv">T</span>: <span class="nc">Loggable</span>&gt;(<span class="nv">with</span> <span class="nv">x</span>: <span class="nc">T</span>) {
</li><li>    <span class="nv">x</span>.<span class="nv">log</span>()
</li><li>}
</li><li><span class="nv">doSomething</span>(<span class="nv">with</span>: <span class="nv">oneAndTwo</span>)
</li><li><span class="c">// Prints &quot;(one, two)&quot;</span>
</li></ol></div></div></div>
<p>When <code class="docutils literal notranslate"><span class="pre">log()</span></code> is called on the instance that’s passed to <code class="docutils literal notranslate"><span class="pre">doSomething(_:)</span></code>, the customized title is omitted from the logged string.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">log()</span></code>が<code class="docutils literal notranslate"><span class="pre">doSomething(_:)</span></code>に渡されるインスタンス上で呼び出される時、カスタマイズされたタイトルはログ文字列から省かれます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID578">
<h3>Protocol Conformance Must Not Be Redundant<a class="headerlink" href="#ID578" title="Permalink to this headline">¶</a><br><span class="jpstr">
プロトコル準拠は冗長であってはいけません<a class="headerlink" href="#ID578" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>A concrete type can conform to a particular protocol only once. Swift marks redundant protocol conformances as an error. You’re likely to encounter this kind of error in two kinds of situations. The first situation is when you explicitly conform to the same protocol multiple times, but with different requirements. The second situation is when you implicitly inherit from the same protocol multiple times. These situations are discussed in the sections below.<br><span class="jpstr">
ある具象型は、特定のプロトコルにただ一度だけ準拠できます。スウィフトは、冗長なプロトコル準拠をエラーであると印します。あなたは、この種のエラーに２種類の状況において出くわしそうに思われます。第一の状況は、あなたが明示的に同じプロトコルに対しての複数回の準拠を、しかし異なる要件を使って行う時です。第二の状況は、あなたが暗黙的に同じプロトコルから複数回継承する時です。これらの状況は、以下の節で議論されます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID579">
<h4>Resolving Explicit Redundancy<a class="headerlink" href="#ID579" title="Permalink to this headline">¶</a><br><span class="jpstr">
明示的な冗長性を解決する<a class="headerlink" href="#ID579" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>Multiple extensions on a concrete type can’t add conformance to the same protocol, even if the extensions’ requirements are mutually exclusive. This restriction is demonstrated in the example below. Two extension declarations attempt to add conditional conformance to the <code class="docutils literal notranslate"><span class="pre">Serializable</span></code> protocol, one for for arrays with <code class="docutils literal notranslate"><span class="pre">Int</span></code> elements, and one for arrays with <code class="docutils literal notranslate"><span class="pre">String</span></code> elements.<br><span class="jpstr">
ある具象型上の複数の拡張は、同じプロトコルに対して準拠を加えることはできません、たとえそれら拡張の持つ要件が相互に排他的であるとしてもです。この制限は、下の例において実演されます。２つの拡張宣言は、<code class="docutils literal notranslate"><span class="pre">Serializable</span></code>プロトコルへの条件準拠を加えることを試みます、<code class="docutils literal notranslate"><span class="pre">Int</span></code>要素を持つ配列のために１つ、そして<code class="docutils literal notranslate"><span class="pre">String</span></code>要素を持つ配列のために１つ。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Serializable</span> {
</li><li>    <span class="k">func</span> <span class="nv">serialize</span>() -&gt; <span class="k">Any</span>
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Serializable</span> <span class="k">where</span> <span class="nc">Element</span> == <span class="nc">Int</span> {
</li><li>    <span class="k">func</span> <span class="nv">serialize</span>() -&gt; <span class="k">Any</span> {
</li><li>        <span class="c">// implementation</span>
</li><li>    }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Serializable</span> <span class="k">where</span> <span class="nc">Element</span> == <span class="nc">String</span> {
</li><li>    <span class="k">func</span> <span class="nv">serialize</span>() -&gt; <span class="k">Any</span> {
</li><li>        <span class="c">// implementation</span>
</li><li>    }
</li><li>}
</li><li><span class="c">// Error: redundant conformance of &#39;Array&lt;Element&gt;&#39; to protocol &#39;Serializable&#39;&nbsp;<span class="jpstr">（エラー: プロトコル 'Serializable' に対しての 'Array&lt;Element&gt;' の冗長な準拠）<!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>If you need to add conditional conformance based on multiple concrete types, create a new protocol that each type can conform to and use that protocol as the requirement when declaring conditional conformance.<br><span class="jpstr">
あなたが複数の具象型に基づく条件準拠を加える必要があるならば、それぞれの型が準拠できる新しいプロトコルを作成してください、そしてそのプロトコルを条件準拠を宣言する時に要件として使ってください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">SerializableInArray</span> { }
</li><li><span class="k">extension</span> <span class="nc">Int</span>: <span class="nc">SerializableInArray</span> { }
</li><li><span class="k">extension</span> <span class="nc">String</span>: <span class="nc">SerializableInArray</span> { }
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Serializable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">SerializableInArray</span> {
</li><li>    <span class="k">func</span> <span class="nv">serialize</span>() -&gt; <span class="k">Any</span> {
</li><li>        <span class="c">// implementation</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID580">
<h4>Resolving Implicit Redundancy<a class="headerlink" href="#ID580" title="Permalink to this headline">¶</a><br><span class="jpstr">
暗黙的な冗長性を解決する<a class="headerlink" href="#ID580" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h4>
<p>When a concrete type conditionally conforms to a protocol, that type implicitly conforms to any parent protocols with the same requirements.<br><span class="jpstr">
具象型があるプロトコルに条件準拠するとき、その型は同じ要件を持つあらゆる親プロトコルに暗黙的に準拠します。
</span><!--end_jpstr-->
</p>
<p>If you need a type to conditionally conform to two protocols that inherit from a single parent, explicitly declare conformance to the parent protocol. This avoids implicitly conforming to the parent protocol twice with different requirements.<br><span class="jpstr">
あなたがある型に単一の親から継承する２つのプロトコルに対して条件準拠して欲しいならば、明示的に親プロトコルに対する準拠を宣言してください。これは、その親プロトコルに対する異なる要件での二重の暗黙的準拠を回避します。
</span><!--end_jpstr-->
</p>
<p>The following example explicitly declares the conditional conformance of <code class="docutils literal notranslate"><span class="pre">Array</span></code> to <code class="docutils literal notranslate"><span class="pre">Loggable</span></code> to avoid a conflict when declaring its conditional conformance to both <code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code> and the new <code class="docutils literal notranslate"><span class="pre">MarkedLoggable</span></code> protocol.<br><span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>に対しての<code class="docutils literal notranslate"><span class="pre">Array</span></code>の条件準拠を明示的に宣言して、<code class="docutils literal notranslate"><span class="pre">TitledLoggable</span></code>と新しい<code class="docutils literal notranslate"><span class="pre">MarkedLoggable</span></code>プロトコルの両方に対してのそれの条件準拠を宣言する時に衝突を回避します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">MarkedLoggable</span>: <span class="nc">Loggable</span> {
</li><li>    <span class="k">func</span> <span class="nv">markAndLog</span>()
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">MarkedLoggable</span> {
</li><li>    <span class="k">func</span> <span class="nv">markAndLog</span>() {
</li><li>        <span class="nv">print</span>(<span class="s">&quot;----------&quot;</span>)
</li><li>        <span class="nv">log</span>()
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Loggable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">Loggable</span> { }
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">TitledLoggable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">TitledLoggable</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">logTitle</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">&quot;Array of &#39;</span>\<span class="p">(</span><span class="nv">Element</span>.<span class="nv">logTitle</span><span class="p">)</span><span class="s">&#39;&quot;</span>
</li><li>    }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">MarkedLoggable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">MarkedLoggable</span> { }
</li></ol></div></div></div>
<p>Without the extension to explicitly declare conditional conformance to <code class="docutils literal notranslate"><span class="pre">Loggable</span></code>, the other <code class="docutils literal notranslate"><span class="pre">Array</span></code> extensions would implicitly create these declarations, resulting in an error:<br><span class="jpstr">
拡張が<code class="docutils literal notranslate"><span class="pre">Loggable</span></code>への条件準拠を明示的に宣言することなしには、他の<code class="docutils literal notranslate"><span class="pre">Array</span></code>拡張は、結果としてエラーになるこれら宣言を暗黙的に作成するでしょう。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Loggable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">TitledLoggable</span> { }
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Loggable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">MarkedLoggable</span> { }
</li><li><span class="c">// Error: redundant conformance of &#39;Array&lt;Element&gt;&#39; to protocol &#39;Loggable&#39;&nbsp;<span class="jpstr">（エラー: プロトコル 'Loggable' に対しての 'Array&lt;Element&gt;' の冗長な準拠）<!--end_jpstr-->
</span>
</li></ol></div></div></div>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an extension declaration<br><span class="jpstr">
拡張宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_extension-declaration"></a>extension-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> <sub>opt</sub> <code>extension</code> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-identifier">type-identifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type-inheritance-clause">type-inheritance-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_extension-body">extension-body</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_extension-body"></a>extension-body</span><span class="arrow"> → </span> <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_extension-members">extension-members</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_extension-members"></a>extension-members</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_extension-member">extension-member</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_extension-members">extension-members</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_extension-member"></a>extension-member</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration">declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Statements.html#grammar_compiler-control-statement">compiler-control-statement</a></span> </p></div></div></div>
</div>
</div>
<div class="section" id="ID379">
<h2>Subscript Declaration<a class="headerlink" href="#ID379" title="Permalink to this headline">¶</a><br><span class="jpstr">
添え字宣言<a class="headerlink" href="#ID379" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>subscript</em> declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence. Subscript declarations are declared using the <code class="docutils literal notranslate"><span class="pre">subscript</span></code> keyword and have the following form:<br><span class="jpstr">
<em>添え字宣言</em>は、特定の型のオブジェクトに対する添え字サポートを付け加えることをあなたに可能にして、コレクション、リスト、またはシーケンスの中の要素にアクセスするための便利な構文を提供するために概して使われます。添え字宣言は、キーワード<code class="docutils literal notranslate"><span class="pre">subscript</span></code>を使って宣言されて、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">subscript</span> (<span class="gi">parameters</span>) -&gt; <span class="gi">return type</span> {
</li><li>    <span class="k">get</span> {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>    <span class="k">set</span>(<span class="gi">setter name</span>) {
</li><li>        <span class="gi">statements</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.<br><span class="jpstr">
添え字宣言は、クラス、構造体、列挙、拡張、またはプロトコル宣言の文脈においてだけ、現れることができます。
</span><!--end_jpstr-->
</p>
<p>The <em>parameters</em> specify one or more indexes used to access elements of the corresponding type in a subscript expression (for example, the <code class="docutils literal notranslate"><span class="pre">i</span></code> in the expression <code class="docutils literal notranslate"><span class="pre">object[i]</span></code>). Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index. The <em>return type</em> specifies the type of the element being accessed.<br><span class="jpstr">
<em>パラメータ</em>は、対応する型の要素にアクセスするために添え字式において使用する一種類以上のインデックスを指定します（例えば、式<code class="docutils literal notranslate"><span class="pre">object[i]</span></code>における<code class="docutils literal notranslate"><span class="pre">i</span></code>など）。要素にアクセスするために使用されるインデックスは、どんな型でも可能であるけれども、各パラメータは型注釈を含んで、各インデックスの型を指定しなければなりません。<em>戻り型</em>は、アクセスされている要素の型を指定します。
</span><!--end_jpstr-->
</p>
<p>As with computed properties, subscript declarations support reading and writing the value of the accessed elements. The getter is used to read the value, and the setter is used to write the value. The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly. That said, if you provide a setter clause, you must also provide a getter clause.<br><span class="jpstr">
計算プロパティと同様に、添え字宣言はアクセスされた要素の値を読み書きすることをサポートします。ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。セッター節は任意です、そしてゲッターだけが必要なとき、あなたは両方の節を省略して、単に直接要請された値を返すことができます。とは言え、 あなたがセッター節を提供するならば、あなたはまたゲッター節も提供しなければなりません。
</span><!--end_jpstr-->
</p>
<p>The <em>setter name</em> and enclosing parentheses are optional. If you provide a setter name, it is used as the name of the parameter to the setter. If you do not provide a setter name, the default parameter name to the setter is <code class="docutils literal notranslate"><span class="pre">value</span></code>. The type of the <em>setter name</em> must be the same as the <em>return type</em>.<br><span class="jpstr">
<em>セッター名</em>と囲んでいる括弧は、任意です。あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。あなたがセッター名を提供しないならば、セッターへの省略時のパラメータ名は<code class="docutils literal notranslate"><span class="pre">value</span></code>です。<em>セッター名</em>の型は、<em>戻り型</em>と同じものでなければなりません。
</span><!--end_jpstr-->
</p>
<p>You can overload a subscript declaration in the type in which it is declared, as long as the <em>parameters</em> or the <em>return type</em> differ from the one you’re overloading. You can also override a subscript declaration inherited from a superclass. When you do so, you must mark the overridden subscript declaration with the <code class="docutils literal notranslate"><span class="pre">override</span></code> declaration modifier.<br><span class="jpstr">
あなたは、ある添え字宣言を、そこにおいてそれが宣言される型においてオーバーロードすることができます、<em>パラメーター</em>または<em>戻り型</em>があなたがオーバーロードしているものと異なる限りはです。あなたはまた、スーパークラスから継承した添え字宣言をオーバーライドすることができます。あなたがそうするとき、あなたはオーバーライドされる添え字宣言を<code class="docutils literal notranslate"><span class="pre">override</span></code>宣言修飾子で印しなければなりません。
</span><!--end_jpstr-->
</p>
<p>By default, the parameters used in subscripting don’t have argument labels, unlike functions, methods, and initializers. However, you can provide explicit argument labels using the same syntax that functions, methods, and initializers use.<br><span class="jpstr">
初期状態で、添字において使用されるパラメータは引数ラベルを持ちません、関数、メソッド、およびイニシャライザとは違って。しかしながら、あなたは明示的に引数ラベルを提供することが、関数、メソッド、およびイニシャライザが使うのと同じ構文を使うことで可能です。
</span><!--end_jpstr-->
</p>
<p>You can also declare subscripts in the context of a protocol declaration, as described in <a class="reference internal" href="#ID373"><span class="std std-ref">Protocol Subscript Declaration</span></a>.<br><span class="jpstr">
<a class="reference internal" href="#ID373"><span class="std std-ref">プロトコル添え字宣言</span></a>で記述されるように、あなたはまた、プロトコル宣言の文脈において添え字を宣言することができます。
</span><!--end_jpstr-->
</p>
<p>For more information about subscripting and to see examples of subscript declarations, see <a class="reference internal" href="../LanguageGuide/Subscripts.html"><span class="doc">Subscripts</span></a>.<br><span class="jpstr">
添え字に関するより多くの情報のために、そして、添え字宣言の例を見るために、<a class="reference internal" href="../LanguageGuide/Subscripts.html"><span class="doc">添え字</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a subscript declaration<br><span class="jpstr">
添え字宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-declaration"></a>subscript-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-head">subscript-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-result">subscript-result</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_code-block">code-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-declaration_1045"></a>subscript-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-head">subscript-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-result">subscript-result</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-block">getter-setter-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-declaration_1046"></a>subscript-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-head">subscript-head</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_subscript-result">subscript-result</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-where-clause">generic-where-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_getter-setter-keyword-block">getter-setter-keyword-block</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-head"></a>subscript-head</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub> <code>subscript</code> <span class="syntactic-category"><a href="../ReferenceManual/GenericParametersAndArguments.html#grammar_generic-parameter-clause">generic-parameter-clause</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_parameter-clause">parameter-clause</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_subscript-result"></a>subscript-result</span><span class="arrow"> → </span> <code>-&gt;</code> <span class="syntactic-category"><a href="../ReferenceManual/Attributes.html#grammar_attributes">attributes</a></span> <sub>opt</sub> <span class="syntactic-category"><a href="../ReferenceManual/Types.html#grammar_type">type</a></span> </p></div></div></div>
<div class="section" id="ID380">
<h2>Operator Declaration<a class="headerlink" href="#ID380" title="Permalink to this headline">¶</a><br><span class="jpstr">
演算子宣言<a class="headerlink" href="#ID380" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>An <em>operator declaration</em> introduces a new infix, prefix, or postfix operator into your program and is declared using the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword.<br><span class="jpstr">
<em>演算子宣言</em>は、新しい接中辞、接頭辞、または接尾辞演算子をあなたのプログラムに導入します、そしてキーワード<code class="docutils literal notranslate"><span class="pre">operator</span></code>を使って宣言されます。
</span><!--end_jpstr-->
</p>
<p>You can declare operators of three different fixities: infix, prefix, and postfix. The <em>fixity</em> of an operator specifies the relative position of an operator to its operands.<br><span class="jpstr">
あなたは、３つの異なる定着性の演算子を宣言することができます：接中辞、接頭辞、そして接尾辞。演算子の<em>定着性</em>は、その演算子の演算数に対する相対位置を指定します。
</span><!--end_jpstr-->
</p>
<p>There are three basic forms of an operator declaration, one for each fixity. The fixity of the operator is specified by marking the operator declaration with the <code class="docutils literal notranslate"><span class="pre">infix</span></code>, <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> declaration modifier before the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword. In each form, the name of the operator can contain only the operator characters defined in <a class="reference internal" href="LexicalStructure.html#ID418"><span class="std std-ref">Operators</span></a>.<br><span class="jpstr">
演算子宣言の基本の書式は、各定着性に対して１つずつ、３つあります。演算子の定着性は、演算子定義を<code class="docutils literal notranslate"><span class="pre">operator</span></code>キーワードの前に<code class="docutils literal notranslate"><span class="pre">infix</span></code>、<code class="docutils literal notranslate"><span class="pre">prefix</span></code>、または<code class="docutils literal notranslate"><span class="pre">postfix</span></code>宣言修飾子を使って印することによって指定されます。各形式において、演算子の名前は<a class="reference internal" href="LexicalStructure.html#ID418"><span class="std std-ref">演算子</span></a>で定義される演算子文字だけを含むことができます。
</span><!--end_jpstr-->
</p>
<p>The following form declares a new infix operator:<br><span class="jpstr">
以下の形式は、新しい接中辞演算子を宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">infix</span> <span class="k">operator</span> <span class="gi">operator name</span>: <span class="gi">precedence group</span>
</li></ol></div></div></div>
<p>An <em>infix operator</em> is a binary operator that is written between its two operands, such as the familiar addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) in the expression <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>.<br><span class="jpstr">
<em>接中辞演算子</em>は、それの２つ演算数の間で書かれる二項演算子です、例えば式<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code>でのよく知られた加算演算子（<code class="docutils literal notranslate"><span class="pre">+</span></code>）など。
</span><!--end_jpstr-->
</p>
<p>Infix operators can optionally specify a precedence group. If you omit the precedence group for an operator, Swift uses the default precedence group, <code class="docutils literal notranslate"><span class="pre">DefaultPrecedence</span></code>, which specifies a precedence just higher than <code class="docutils literal notranslate"><span class="pre">TernaryPrecedence</span></code>. For more information, see <a class="reference internal" href="#ID550"><span class="std std-ref">Precedence Group Declaration</span></a>.<br><span class="jpstr">
接中辞演算子は、任意に優先順位グループを指定することができます。あなたが優先順位グループを省略するならば、スウィフトは省略時の優先順位グループ、<code class="docutils literal notranslate"><span class="pre">DefaultPrecedence</span></code>を使います、それは<code class="docutils literal notranslate"><span class="pre">TernaryPrecedence</span></code>のすぐ上の優先順位を指定します。さらなる情報は、<a class="reference internal" href="#ID550"><span class="std std-ref">優先順位グループ定義</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p>The following form declares a new prefix operator:<br><span class="jpstr">
以下の形式は、新しい接頭辞演算子を宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">prefix</span> <span class="k">operator</span> <span class="gi">operator name</span>
</li></ol></div></div></div>
<p>A <em>prefix operator</em> is a unary operator that is written immediately before its operand, such as the prefix logical NOT operator (<code class="docutils literal notranslate"><span class="pre">!</span></code>) in the expression <code class="docutils literal notranslate"><span class="pre">!a</span></code>.<br><span class="jpstr">
<em>接頭辞演算子</em>は単項演算子です、それはその演算数の直前に書かれます、例えば式<code class="docutils literal notranslate"><span class="pre">!a</span></code>での論理否定演算子（<code class="docutils literal notranslate"><span class="pre">!</span></code>）など。
</span><!--end_jpstr-->
</p>
<p>Prefix operators declarations don’t specify a precedence level. Prefix operators are nonassociative.<br><span class="jpstr">
接頭辞演算子宣言は、優先順位レベルを指定しません。接頭辞演算子は非結合です。
</span><!--end_jpstr-->
</p>
<p>The following form declares a new postfix operator:<br><span class="jpstr">
以下の形式は、新しい接尾辞演算子を宣言します：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">postfix</span> <span class="k">operator</span> <span class="gi">operator name</span>
</li></ol></div></div></div>
<p>A <em>postfix operator</em> is a unary operator that is written immediately after its operand, such as the postfix forced-unwrap operator (<code class="docutils literal notranslate"><span class="pre">!</span></code>) in the expression <code class="docutils literal notranslate"><span class="pre">a!</span></code>.<br><span class="jpstr">
<em>接尾辞演算子</em>は単項演算子です、それはその演算数の直後に書かれます、例えば式<code class="docutils literal notranslate"><span class="pre">a!</span></code>での論理否定演算子（<code class="docutils literal notranslate"><span class="pre">!</span></code>）など。
</span><!--end_jpstr-->
</p>
<p>As with prefix operators, postfix operator declarations don’t specify a precedence level. Postfix operators are nonassociative.<br><span class="jpstr">
接頭辞演算子と同様に、接尾辞演算子宣言は、優先順位レベルを指定しません。接尾辞演算子は非結合です。
</span><!--end_jpstr-->
</p>
<p>After declaring a new operator, you implement it by declaring a static method that has the same name as the operator. The static method is a member of one of the types whose values the operator takes as an argument—for example, an operator that multiplies a <code class="docutils literal notranslate"><span class="pre">Double</span></code> by an <code class="docutils literal notranslate"><span class="pre">Int</span></code> is implemented as a static method on either the <code class="docutils literal notranslate"><span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">Int</span></code> structure. If you’re implementing a prefix or postfix operator, you must also mark that method declaration with the corresponding <code class="docutils literal notranslate"><span class="pre">prefix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> declaration modifier. To see an example of how to create and implement a new operator, see <a class="reference internal" href="../LanguageGuide/AdvancedOperators.html#ID46"><span class="std std-ref">Custom Operators</span></a>.<br><span class="jpstr">
ある新しい演算子を宣言した後に、あなたはその演算子と同じ名前を持つ静的メソッドを宣言することによってそれを実装します。この静的メソッドは、その演算子が引数としてとる値の型のうちの１つに属するあるメンバーです、例えば<code class="docutils literal notranslate"><span class="pre">Double</span></code>に<code class="docutils literal notranslate"><span class="pre">Int</span></code>を掛ける演算子は静的メソッドとして<code class="docutils literal notranslate"><span class="pre">Double</span></code>または<code class="docutils literal notranslate"><span class="pre">Int</span></code> 構造体のどちらかで実装されます。あなたが接頭辞または接尾辞演算子を実装しているならば、あなたはまたそのメソッド宣言を対応する<code class="docutils literal notranslate"><span class="pre">prefix</span></code>または<code class="docutils literal notranslate"><span class="pre">postfix</span></code>宣言修飾子で印をしなければなりません。新しい演算子の作成と実装の方法の例を見るには、<a class="reference internal" href="../LanguageGuide/AdvancedOperators.html#ID46"><span class="std std-ref">あつらえの演算子</span></a>を参照してください。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of an operator declaration<br><span class="jpstr">
演算子宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_operator-declaration"></a>operator-declaration</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_prefix-operator-declaration">prefix-operator-declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_postfix-operator-declaration">postfix-operator-declaration</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_infix-operator-declaration">infix-operator-declaration</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_prefix-operator-declaration"></a>prefix-operator-declaration</span><span class="arrow"> → </span> <code>prefix</code> <code>operator</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_postfix-operator-declaration"></a>postfix-operator-declaration</span><span class="arrow"> → </span> <code>postfix</code> <code>operator</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-operator-declaration"></a>infix-operator-declaration</span><span class="arrow"> → </span> <code>infix</code> <code>operator</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_operator">operator</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_infix-operator-group">infix-operator-group</a></span> <sub>opt</sub></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_infix-operator-group"></a>infix-operator-group</span><span class="arrow"> → </span> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-name">precedence-group-name</a></span> </p></div></div></div>
<div class="section" id="ID550">
<h2>Precedence Group Declaration<a class="headerlink" href="#ID550" title="Permalink to this headline">¶</a><br><span class="jpstr">
優先順位グループ定義<a class="headerlink" href="#ID550" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>A <em>precedence group declaration</em> introduces a new grouping for infix operator precedence into your program. The precedence of an operator specifies how tightly the operator binds to its operands, in the absence of grouping parentheses.<br><span class="jpstr">
<em>優先順位グループ</em>は、接中辞演算子優先順位に対する新しいグループをあなたのプログラムへ導入します。ある演算子の優先順位は、どのくらいきつくその演算子をそれの演算数に束縛するかを、グループ化の丸括弧がないところで指定します。
</span><!--end_jpstr-->
</p>
<p>A precedence group declaration has the following form:<br><span class="jpstr">
優先順位グループ定義は、以下の形式を持ちます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">precedencegroup</span> <span class="gi">precedence group name</span> {
</li><li>    <span class="k">higherThan</span>: <span class="gi">lower group names</span>
</li><li>    <span class="k">lowerThan</span>: <span class="gi">higher group names</span>
</li><li>    <span class="k">associativity</span>: <span class="gi">associativity</span>
</li><li>    <span class="k">assignment</span>: <span class="gi">assignment</span>
</li><li>}
</li></ol></div></div></div>
<p>The <em>lower group names</em> and <em>higher group names</em> lists specify the new precedence group’s relation to existing precedence groups. The <code class="docutils literal notranslate"><span class="pre">lowerThan</span></code> precedence group attribute may only be used to refer to precedence groups declared outside of the current module. When two operators compete with each other for their operands, such as in the expression <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>, the operator with the higher relative precedence binds more tightly to its operands.<br><span class="jpstr">
<em>下方グループ名</em>および<em>上方グループ名</em>リストは、新しい優先順位グループのもつ関係を既存の優先順位グループに対して指定します。<code class="docutils literal notranslate"><span class="pre">lowerThan</span></code>優先順位グループ属性は、現在のモジュールの外側で宣言される優先順位グループを参照するのに使われるだけでしょう。２つの演算子がそれらの演算数に対して互いと比較される時、例えば式<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>などで、より高い関係優先順位を持つ演算子はよりきつくそれの演算数に束縛されます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Precedence groups related to each other using <em>lower group names</em> and <em>higher group names</em> must fit into a single relational hierarchy, but they <em>don’t</em> have to form a linear hierarchy. This means it is possible to have precedence groups with undefined relative precedence. Operators from those precedence groups can’t be used next to each other without grouping parentheses.<br><span class="jpstr">
<em>下方グループ名</em>と<em>上方グループ名</em>を使って互いに関係のある優先順位グループは、単一の関係階層へはめ込まなければなりません、しかしそれらは線形階層を形作る必要は<em>ありません</em>。これが意味するのは、未定義の関係優先順位による優先順位グループを持つことは可能だということです。それらの優先順位グループ由来の演算子は、グループ化括弧なしで互いにすぐ隣に使われることができません。
</span><!--end_jpstr-->
</p>
</div>
<p>Swift defines numerous precedence groups to go along with the operators provided by the standard library. For example, the addition (<code class="docutils literal notranslate"><span class="pre">+</span></code>) and subtraction (<code class="docutils literal notranslate"><span class="pre">-</span></code>) operators belong to the <code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code> group, and the multiplication (<code class="docutils literal notranslate"><span class="pre">*</span></code>) and division (<code class="docutils literal notranslate"><span class="pre">/</span></code>) operators belong to the <code class="docutils literal notranslate"><span class="pre">MultiplicationPrecedence</span></code> group. For a complete list of precedence groups provided by the Swift standard library, see <a class="reference external" href="https://developer.apple.com/documentation/swift/operator_declarations">Operator Declarations</a>.<br><span class="jpstr">
スウィフトは、標準ライブラリによって提供される演算子と一緒にやっていくために、多数の優先順位グループを定義します。例えば、加算（<code class="docutils literal notranslate"><span class="pre">+</span></code>）および減算（<code class="docutils literal notranslate"><span class="pre">-</span></code>）演算子は、<code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code>グルーブに所属し、そして乗算（<code class="docutils literal notranslate"><span class="pre">*</span></code>）および減算（<code class="docutils literal notranslate"><span class="pre">/</span></code>）演算子は<code class="docutils literal notranslate"><span class="pre">MultiplicationPrecedence</span></code>グルーブに属します。スウィフト標準ライブラリによって提供される優先順位グループの完全なリストとして、<a class="reference external" href="../../../developer.apple.com/documentation/swift/swift_standard_library/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<p>The <em>associativity</em> of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses. You specify the associativity of an operator by writing one of the context-sensitive keywords <code class="docutils literal notranslate"><span class="pre">left</span></code>, <code class="docutils literal notranslate"><span class="pre">right</span></code>, or <code class="docutils literal notranslate"><span class="pre">none</span></code>—if your omit the associativity, the default is <code class="docutils literal notranslate"><span class="pre">none</span></code>. Operators that are left-associative group left-to-right. For example, the subtraction operator (<code class="docutils literal notranslate"><span class="pre">-</span></code>) is left-associative, so the expression <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">-</span> <span class="pre">5</span> <span class="pre">-</span> <span class="pre">6</span></code> is grouped as <code class="docutils literal notranslate"><span class="pre">(4</span> <span class="pre">-</span> <span class="pre">5)</span> <span class="pre">-</span> <span class="pre">6</span></code> and evaluates to <code class="docutils literal notranslate"><span class="pre">-7</span></code>. Operators that are right-associative group right-to-left, and operators that are specified with an associativity of <code class="docutils literal notranslate"><span class="pre">none</span></code> don’t associate at all. Nonassociative operators of the same precedence level can’t appear adjacent to each to other. For example, the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator has an associativity of <code class="docutils literal notranslate"><span class="pre">none</span></code>, which means <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">2</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> is not a valid expression.<br><span class="jpstr">
演算子の<em>結合性</em>は、グループ括弧がない場合に同じ優先順位レベルを持つひと連なりの演算子がどのようにまとめられるかを指定します。あなたはある演算子の結合性を文脈依存キーワード<code class="docutils literal notranslate"><span class="pre">left</span></code>、<code class="docutils literal notranslate"><span class="pre">right</span></code>、または<code class="docutils literal notranslate"><span class="pre">none</span></code>のうちの１つを書くことによって指定します—あなたが結合性を省略するならば、初期状態は<code class="docutils literal notranslate"><span class="pre">none</span></code>です。左結合である演算子は、左から右へとグループにまとめられます。例えば、減算演算子（<code class="docutils literal notranslate"><span class="pre">-</span></code>）は左結合です、それで式<code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">-</span> <span class="pre">5</span> <span class="pre">-</span> <span class="pre">6</span></code>は<code class="docutils literal notranslate"><span class="pre">(4</span> <span class="pre">-</span> <span class="pre">5)</span> <span class="pre">-</span> <span class="pre">6</span></code>のようにグループにされて、<code class="docutils literal notranslate"><span class="pre">-7</span></code>に評価されます。右結合の演算子は右から左にグループにされます、そして<code class="docutils literal notranslate"><span class="pre">none</span></code>の関係性を指定される演算子は全く結合しません。同じ優先順位レベルを持つ非結合演算子は、互いに隣同士に現れることができません。例えば、<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>演算子は、<code class="docutils literal notranslate"><span class="pre">none</span></code>の関係性を持ちます、それは<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">2</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>が有効な式でないことを意味します。
</span><!--end_jpstr-->
</p>
<p>The <em>assignment</em> of a precedence group specifies the precedence of an operator when used in an operation that includes optional chaining. When set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library. Otherwise, when set to <code class="docutils literal notranslate"><span class="pre">false</span></code> or omitted, operators in the precedence group follows the same optional chaining rules as operators that don’t perform assignment.<br><span class="jpstr">
優先順位グループの<em>assignment</em>は、オプショナル連鎖を含む演算において使われる時ある演算子の優先順位を指定します。<code class="docutils literal notranslate"><span class="pre">true</span></code>に設定する場合、対応する優先順位グループの演算子は標準ライブラリ由来のassignment（割り当て）演算子と同じグループ化規則をオプショナル連鎖の間に使います。そうせずに、<code class="docutils literal notranslate"><span class="pre">false</span></code>に設定するか省略する場合は、その優先順位グループの演算子は代入を実行しない演算子と同じオプショナル連鎖規則に従います。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a precedence group declaration<br><span class="jpstr">
優先順位グループ宣言の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-declaration"></a>precedence-group-declaration</span><span class="arrow"> → </span> <code>precedencegroup</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-name">precedence-group-name</a></span>  <code>{</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-attributes">precedence-group-attributes</a></span> <sub>opt</sub> <code>}</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-attributes"></a>precedence-group-attributes</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-attribute">precedence-group-attribute</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-attributes">precedence-group-attributes</a></span> <sub>opt</sub></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-attribute"></a>precedence-group-attribute</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-relation">precedence-group-relation</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-attribute_1047"></a>precedence-group-attribute</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-assignment">precedence-group-assignment</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-attribute_1048"></a>precedence-group-attribute</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-associativity">precedence-group-associativity</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-relation"></a>precedence-group-relation</span><span class="arrow"> → </span> <code>higherThan</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-names">precedence-group-names</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-relation_1049"></a>precedence-group-relation</span><span class="arrow"> → </span> <code>lowerThan</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-names">precedence-group-names</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-assignment"></a>precedence-group-assignment</span><span class="arrow"> → </span> <code>assignment</code> <code>:</code> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_boolean-literal">boolean-literal</a></span> </p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-associativity"></a>precedence-group-associativity</span><span class="arrow"> → </span> <code>associativity</code> <code>:</code> <code>left</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-associativity_1050"></a>precedence-group-associativity</span><span class="arrow"> → </span> <code>associativity</code> <code>:</code> <code>right</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-associativity_1051"></a>precedence-group-associativity</span><span class="arrow"> → </span> <code>associativity</code> <code>:</code> <code>none</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-names"></a>precedence-group-names</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-name">precedence-group-name</a></span>  |  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-name">precedence-group-name</a></span>  <code>,</code> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_precedence-group-names">precedence-group-names</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_precedence-group-name"></a>precedence-group-name</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/LexicalStructure.html#grammar_identifier">identifier</a></span> </p></div></div></div>
<div class="section" id="ID381">
<h2>Declaration Modifiers<a class="headerlink" href="#ID381" title="Permalink to this headline">¶</a><br><span class="jpstr">
宣言修飾子<a class="headerlink" href="#ID381" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><em>Declaration modifiers</em> are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration. You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration’s attributes (if any) and the keyword that introduces the declaration.<br><span class="jpstr">
<em>宣言修飾子</em>は、キーワードまたは文脈依存キーワードです、それは宣言のふるまいや意味することを修正します。あなたは、宣言修飾子を適切なキーワードまたは文脈依存キーワードを宣言の属性（もしあれば）と宣言を導入するキーワードとの間に書くことによって指定します。
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dynamic</span></code></dt>
<dd><p class="first">Apply this modifier to any member of a class that can be represented by Objective-C. When you mark a member declaration with the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> modifier, access to that member is always dynamically dispatched using the Objective-C runtime. Access to that member is never inlined or devirtualized by the compiler.<br><span class="jpstr">
この修飾子をObjective-Cによって表わされることのできるクラスのあらゆるメンバーに適用してください。あなたがメンバー宣言を<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>修飾子で印する時は、そのメンバーへのアクセスは、常に動的にObjective-Cランタイムを使用してディスパッチされます。そのメンパーに対するアクセスは、決してコンパイラによってインラインまたはデバーチャライズされません。
</span><!--end_jpstr-->
</p>
<p class="last">Because declarations marked with the <code class="docutils literal notranslate"><span class="pre">dynamic</span></code> modifier are dispatched using the Objective-C runtime, they must be marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>修飾子で印される宣言はObjective-Cランタイムを使ってディスパッチされるので、それらは<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されなければなりません。
</span><!--end_jpstr-->
</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">final</span></code></dt>
<dd>Apply this modifier to a class or to a property, method, or subscript member of a class. It’s applied to a class to indicate that the class can’t be subclassed. It’s applied to a property, method, or subscript of a class to indicate that a class member can’t be overridden in any subclass. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">final</span></code> attribute, see <a class="reference internal" href="../LanguageGuide/Inheritance.html#ID202"><span class="std std-ref">Preventing Overrides</span></a>.<br><span class="jpstr">
この修飾子をクラスに、またはプロパティ、メソッド、またはクラスの添え字メンバーに適用してください。それはクラスに適用されて、そのクラスがサブクラスを作られることができないのを指し示します。それはプロパティ、メソッド、またはクラスの添え字に適用されて、そのクラスメンバーがあらゆるサブクラスにおいてオーバーライドされることができないのを指し示します。<code class="docutils literal notranslate"><span class="pre">final</span></code>属性を使う方法の例として、<a class="reference internal" href="../LanguageGuide/Inheritance.html#ID202"><span class="std std-ref">オーバーライドを防ぐ</span></a>を見てください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lazy</span></code></dt>
<dd>Apply this modifier to a stored variable property of a class or structure to indicate that the property’s initial value is calculated and stored at most once, when the property is first accessed. For an example of how to use the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier, see <a class="reference internal" href="../LanguageGuide/Properties.html#ID257"><span class="std std-ref">Lazy Stored Properties</span></a>.<br><span class="jpstr">
この修飾子をクラスまたは構造体の格納変数プロパティに適用して、そのプロパティの初期値が最大でも一度だけ、そのプロパティが最初にアクセスされるときに、計算または格納されることを指し示してください。<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子を使う方法の例として、<a class="reference internal" href="../LanguageGuide/Properties.html#ID257"><span class="std std-ref">遅延格納プロパティ</span></a>を見てください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">optional</span></code></dt>
<dd><p class="first">Apply this modifier to a protocol’s property, method, or subscript members to indicate that a conforming type isn’t required to implement those members.<br><span class="jpstr">
この修飾子をプロトコルのプロパティ、メソッド、または添え字メンバーに適用して、ある準拠型がそれらのメンバーを実装する必要がないことを指し示してください。
</span><!--end_jpstr-->
</p>
<p class="last">You can apply the <code class="docutils literal notranslate"><span class="pre">optional</span></code> modifier only to protocols that are marked with the <code class="docutils literal notranslate"><span class="pre">objc</span></code> attribute. As a result, only class types can adopt and conform to a protocol that contains optional member requirements. For more information about how to use the <code class="docutils literal notranslate"><span class="pre">optional</span></code> modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see <a class="reference internal" href="../LanguageGuide/Protocols.html#ID284"><span class="std std-ref">Optional Protocol Requirements</span></a>.<br><span class="jpstr">
あなたは<code class="docutils literal notranslate"><span class="pre">optional</span></code>修飾子を<code class="docutils literal notranslate"><span class="pre">objc</span></code>属性で印されるプロトコルだけに適用することができます。結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。<code class="docutils literal notranslate"><span class="pre">optional</span></code>修飾子を使う方法についての更なる情報のために、そしてオプショナルプロトコルメンバーにアクセスする方法についての手引きとして ― 例えば、あなたがある準拠型がそれらを実装するかどうか確信が持てない時など ― <a class="reference internal" href="../LanguageGuide/Protocols.html#ID284"><span class="std std-ref">オプショナルのプロトコル要件</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">required</span></code></dt>
<dd>Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer. The subclass’s implementation of that initializer must also be marked with the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier.<br><span class="jpstr">
この修飾子をクラスの必須または便宜イニシャライザに適用して、全てのサブクラスがそのイニシャライザを実装しなければならないことを指し示してください。このイニシャライザのサブクラスでの実装はまた、<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子で印されなければなりません。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unowned</span></code></dt>
<dd>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value. If you try to access the variable or property after the object has been deallocated, a runtime error is raised. Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is nonoptional. For an example and more information about the <code class="docutils literal notranslate"><span class="pre">unowned</span></code> modifier, see <a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID54"><span class="std std-ref">Unowned References</span></a>.<br><span class="jpstr">
この修飾子を格納変数、定数、または格納プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、実行時エラーが引き起こされます。弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。<code class="docutils literal notranslate"><span class="pre">unowned</span></code>修飾子についての例とさらなる情報として、<a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID54"><span class="std std-ref">非所有参照</span></a>を見てください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unowned(safe)</span></code></dt>
<dd>An explicit spelling of <code class="docutils literal notranslate"><span class="pre">unowned</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">unowned</span></code>の明確なつづり方。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unowned(unsafe)</span></code></dt>
<dd>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value. If you try to access the variable or property after the object has been deallocated, you’ll access the memory at the location where the object used to be, which is a memory-unsafe operation. Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is nonoptional. For an example and more information about the <code class="docutils literal notranslate"><span class="pre">unowned</span></code> modifier, see <a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID54"><span class="std std-ref">Unowned References</span></a>.<br><span class="jpstr">
この修飾子を格納変数、定数、または格納プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。あなたが変数またはプロパティに、そのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、あなたはそのオブジェクトが存在するのに使われたところの位置でメモリにアクセスするでしょう、それはメモリ安全ではない操作です。弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。<code class="docutils literal notranslate"><span class="pre">unowned</span></code>修飾子についての例とさらなる情報として、<a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID54"><span class="std std-ref">非所有参照</span></a>を見てください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">weak</span></code></dt>
<dd>Apply this modifier to a stored variable or stored variable property to indicate that the variable or property has a weak reference to the object stored as its value. The type of the variable or property must be an optional class type. If you access the variable or property after the object has been deallocated, its value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. For an example and more information about the <code class="docutils literal notranslate"><span class="pre">weak</span></code> modifier, see <a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID53"><span class="std std-ref">Weak References</span></a>.<br><span class="jpstr">
この修飾子を格納変数または格納変数プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して弱い参照を持つことを指し示してください。この変数またはプロパティの型はまた、オプショナルクラス型でなければなりません。あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスするならば、それの値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。<code class="docutils literal notranslate"><span class="pre">weak</span></code>修飾子についての例と更なる情報のために、<a class="reference internal" href="../LanguageGuide/AutomaticReferenceCounting.html#ID53"><span class="std std-ref">弱い参照</span></a>を見てください。
</span><!--end_jpstr-->
</dd>
</dl>
<div class="section" id="ID382">
<h3>Access Control Levels<a class="headerlink" href="#ID382" title="Permalink to this headline">¶</a><br><span class="jpstr">
アクセス制御水準<a class="headerlink" href="#ID382" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Swift provides five levels of access control: open, public, internal, file private, and private. You can mark a declaration with one of the access-level modifiers below to specify the declaration’s access level. Access control is discussed in detail in <a class="reference internal" href="../LanguageGuide/AccessControl.html"><span class="doc">Access Control</span></a>.<br><span class="jpstr">
スウィフトは、５つの水準のアクセス制御を提供します：公開、内部、そして非公開。あなたは、宣言を以下のアクセス水準修飾子のうちの１つで印して、その宣言のアクセス水準を指定することができます。アクセス制御は、<a class="reference internal" href="../LanguageGuide/AccessControl.html"><span class="doc">アクセス制御</span></a>で詳細に議論されます。
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">open</span></code></dt>
<dd>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration. Declarations marked with the <code class="docutils literal notranslate"><span class="pre">open</span></code> access-level modifier can also be accessed and subclassed by code in a module that imports the module that contains that declaration.<br><span class="jpstr">
この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。<code class="docutils literal notranslate"><span class="pre">open</span></code>アクセス水準修飾子で印される宣言はまた、アクセスされることおよびサブクラスを作られることが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">public</span></code></dt>
<dd>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration. Declarations marked with the <code class="docutils literal notranslate"><span class="pre">public</span></code> access-level modifier can also be accessed (but not subclassed) by code in a module that imports the module that contains that declaration.<br><span class="jpstr">
この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。<code class="docutils literal notranslate"><span class="pre">public</span></code>アクセス水準修飾子で印される宣言はまた、アクセスされる（しかしサブクラスは作られない）ことが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">internal</span></code></dt>
<dd>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration. By default, most declarations are implicitly marked with the <code class="docutils literal notranslate"><span class="pre">internal</span></code> access-level modifier.<br><span class="jpstr">
この修飾子を宣言に適用して、その宣言が、宣言と同じモジュールの中のコードによってのみアクセスされることができるのを指し示してください。省略時では、大部分の宣言は暗黙的に<code class="docutils literal notranslate"><span class="pre">internal</span></code>アクセス水準修飾子で印されます。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fileprivate</span></code></dt>
<dd>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.<br><span class="jpstr">
この修飾子を宣言に適用して、その宣言が、宣言と同じソースファイルの中のコードによってのみアクセスされることができるのを指し示してください。
</span><!--end_jpstr-->
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">private</span></code></dt>
<dd>Apply this modifier to a declaration to indicate the declaration can be accessed only by code within the declaration’s immediate enclosing scope.<br><span class="jpstr">
この修飾子を宣言に適用して、その宣言がアクセスされることは、宣言が直に囲んでいるスコープ内のコードによってのみ可能なのを指し示してください。
</span><!--end_jpstr-->
</dd>
</dl>
<p>For the purpose of access control, extensions to the same type that are in the same file share an access-control scope. If the type they extend is also in the same file, they share the type’s access-control scope. Private members declared in the type’s declaration can be accessed from extensions, and private members declared in one extension can be accessed from other extensions and from the type’s declaration.<br><span class="jpstr">
アクセス制御の目的のために、同じ型で同じファイルの中にあるものに対する拡張それらは、アクセス制御スコープを共有します。それらが拡張した型もまた同じファイルにあるならば、それらはその型のもつアクセス制御スコープを共有します。型の持つ宣言において宣言される非公開メンバは拡張からアクセスできます、そして一方の拡張において宣言される非公開メンバは他方の拡張からそしてその型のもつ宣言からアクセスできます。
</span><!--end_jpstr-->
</p>
<p>Each access-level modifier above optionally accepts a single argument, which consists of the <code class="docutils literal notranslate"><span class="pre">set</span></code> keyword enclosed in parentheses (for instance, <code class="docutils literal notranslate"><span class="pre">private(set)</span></code>). Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that’s less than or equal to the access level of the variable or subscript itself, as discussed in <a class="reference internal" href="../LanguageGuide/AccessControl.html#ID18"><span class="std std-ref">Getters and Setters</span></a>.<br><span class="jpstr">
上記のそれぞれのアクセス水準修飾子は、任意に１つだけの引数を受け入れます、それは丸括弧に囲まれたキーワード<code class="docutils literal notranslate"><span class="pre">set</span></code>からなります（例えば、<code class="docutils literal notranslate"><span class="pre">private(set)</span></code>）。アクセス水準修飾子のこの形式は、あなたが変数または添え字のセッターにその変数または添え字それ自身のアクセス水準よりもより少ないか等しいアクセス水準を指定することを望むときに使ってください、<a class="reference internal" href="../LanguageGuide/AccessControl.html#ID18"><span class="std std-ref">ゲッターとセッター</span></a>で議論されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition grammar"><p class="first admonition-title">Grammar of a declaration modifier<br><span class="jpstr">
宣言修飾子の文法
</span><!--end_jpstr-->
</p><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration-modifier"></a>declaration-modifier</span><span class="arrow"> → </span> <code>class</code> |  <code>convenience</code> |  <code>dynamic</code> |  <code>final</code> |  <code>infix</code> |  <code>lazy</code> |  <code>optional</code> |  <code>override</code> |  <code>postfix</code> |  <code>prefix</code> |  <code>required</code> |  <code>static</code> |  <code>unowned</code> |  <code>unowned</code> <code>(</code> <code>safe</code> <code>)</code> |  <code>unowned</code> <code>(</code> <code>unsafe</code> <code>)</code> |  <code>weak</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration-modifier_1052"></a>declaration-modifier</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_access-level-modifier">access-level-modifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration-modifier_1053"></a>declaration-modifier</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_mutation-modifier">mutation-modifier</a></span> </p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_declaration-modifiers"></a>declaration-modifiers</span><span class="arrow"> → </span> <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifier">declaration-modifier</a></span>  <span class="syntactic-category"><a href="../ReferenceManual/Declarations.html#grammar_declaration-modifiers">declaration-modifiers</a></span> <sub>opt</sub></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_access-level-modifier"></a>access-level-modifier</span><span class="arrow"> → </span> <code>private</code> |  <code>private</code> <code>(</code> <code>set</code> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_access-level-modifier_1054"></a>access-level-modifier</span><span class="arrow"> → </span> <code>fileprivate</code> |  <code>fileprivate</code> <code>(</code> <code>set</code> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_access-level-modifier_1055"></a>access-level-modifier</span><span class="arrow"> → </span> <code>internal</code> |  <code>internal</code> <code>(</code> <code>set</code> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_access-level-modifier_1056"></a>access-level-modifier</span><span class="arrow"> → </span> <code>public</code> |  <code>public</code> <code>(</code> <code>set</code> <code>)</code></p><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_access-level-modifier_1057"></a>access-level-modifier</span><span class="arrow"> → </span> <code>open</code> |  <code>open</code> <code>(</code> <code>set</code> <code>)</code></p></div><div class="syntax-group"><p class="syntax-def"><span class="syntax-def-name"><a id="grammar_mutation-modifier"></a>mutation-modifier</span><span class="arrow"> → </span> <code>mutating</code> |  <code>nonmutating</code></p></div></div></div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Statements.html">Statements<br><span class="jpstr">
文
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Attributes.html">Attributes<br><span class="jpstr">
属性
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
