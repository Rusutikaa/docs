

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>A Swift Tour — The Swift Programming Language (Swift 5.3)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.3</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html"><span class="enstr">About Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトについて
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Compatibility.html"><span class="enstr">Version Compatibility</span><!--end_enstr-->
<span class="jpstr">
バージョン互換性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">A Swift Tour</span><!--end_enstr-->
<span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../LanguageGuide/TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">A Swift Tour</span><!--end_enstr-->
<span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID461"><span class="enstr">Simple Values</span><!--end_enstr-->
<span class="jpstr">
単純な値
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID462"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID463"><span class="enstr">Functions and Closures</span><!--end_enstr-->
<span class="jpstr">
関数とクロージャ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID464"><span class="enstr">Objects and Classes</span><!--end_enstr-->
<span class="jpstr">
オブジェクトとクラス
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID465"><span class="enstr">Enumerations and Structures</span><!--end_enstr-->
<span class="jpstr">
列挙と構造体
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID466"><span class="enstr">Protocols and Extensions</span><!--end_enstr-->
<span class="jpstr">
プロトコルと拡張
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID623"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID624"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="a-swift-tour">
<h1><span class="enstr">A Swift Tour<a class="headerlink" href="#a-swift-tour" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
スウィフトツアー<a class="headerlink" href="#a-swift-tour" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr">Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen. In Swift, this can be done in a single line:</span><!--end_enstr-->
<span class="jpstr">
伝統は、新しい言語において最初のプログラムが画面上に語句「Hello, world!」を出力しなければならないことを示唆します。スウィフトにおいて、これは１つの行でされることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="s">"Hello, world!"</span>)
</li><li><span class="c">// Prints "Hello, world!"</span>
</li></ol></div></div></div>
<p><span class="enstr">If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program. You don’t need to import a separate library for functionality like input/output or string handling. Code written at global scope is used as the entry point for the program, so you don’t need a <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. You also don’t need to write semicolons at the end of every statement.</span><!--end_enstr-->
<span class="jpstr">
あなたがCまたはObjective-Cでコードを書いたことがあるならば、この構文はあなたにとって馴染みがあるものでしょう ― スウィフトにおいて、コードのこの行は、ひとつの完全なプログラムです。あなたは、入力／出力または文字列取り扱いのような機能性のために個々のライブラリをインポートする必要はありません。グローバルなスコープで書かれるコードは、プログラムのエントリポイントとして使われるので、あなたは<code class="docutils literal notranslate"><span class="pre">main()</span></code>関数を必要としません。あなたはまた、すべての文の終わりにセミコロンを書く必要がありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks. Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.</span><!--end_enstr-->
<span class="jpstr">
このツアーはあなたにスウィフトでコードを書き始めるのに十分な情報を、どうやって様々なプログラミング作業を達成するかをあなたに示すことによって提供します。わからないことがあっても心配することはありません ― このツアーにおいて紹介されるすべてのことは、この本の残りで詳細に説明されます。
</span><!--end_jpstr-->
</p>
<div class="playground_link admonition">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For the best experience, open this chapter as a playground in Xcode. Playgrounds allow you to edit the code listings and see the result immediately.</span><!--end_enstr-->
<span class="jpstr">
最もよい体験方法として、Xcodeでplayground（遊び場）としてこの章を開いてください。プレイグラウンドは、あなたがコードリストを編集してすぐにその結果を見られるようにします。
</span><!--end_jpstr-->

</p>
<p class="last"><a class="reference external" href="GuidedTour.playground.zip"><span class="enstr">Download Playground</span><!--end_enstr-->
<span class="jpstr">
「遊び場」をダウンロード
</span><!--end_jpstr-->
</a></p>
</div>
<div class="section" id="ID461">
<h2><span class="enstr">Simple Values<a class="headerlink" href="#ID461" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
単純な値<a class="headerlink" href="#ID461" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">let</span></code> to make a constant and <code class="docutils literal notranslate"><span class="pre">var</span></code> to make a variable. The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once. This means you can use constants to name a value that you determine once but use in many places.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">let</span></code>を使って定数を作り<code class="docutils literal notranslate"><span class="pre">var</span></code>を使って変数を作ってください。定数の値はコンパイル時に知られている必要はありません、しかしあなたはそれに値を厳密に一度だけ代入します。これは、あなたが一度だけ決定するが多くの場所で使用する値に対して名前をつけるために定数を利用できるのを意味します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">myVariable</span> = <span class="m">42</span>
</li><li><span class="nv">myVariable</span> = <span class="m">50</span>
</li><li><span class="k">let</span> <span class="nv">myConstant</span> = <span class="m">42</span>
</li></ol></div></div></div>
<p><span class="enstr">A constant or variable must have the same type as the value you want to assign to it. However, you don’t always have to write the type explicitly. Providing a value when you create a constant or variable lets the compiler infer its type. In the example above, the compiler infers that <code class="docutils literal notranslate"><span class="pre">myVariable</span></code> is an integer because its initial value is an integer.</span><!--end_enstr-->
<span class="jpstr">
定数または変数は、あなたがそれに代入したい値と同じ型を持たなければなりません。しかし、あなたは必ずしも明確に型を書く必要はありません。あなたが定数または変数をつくる時に値を提供することは、コンパイラにその型を推論させます。上の例で、コンパイラは<code class="docutils literal notranslate"><span class="pre">myVariable</span></code>が整数であると推測します、その最初の値が整数であるためです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If the initial value doesn’t provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.</span><!--end_enstr-->
<span class="jpstr">
最初の値が十分な情報を提供しないならば（または最初の値がないならば）、変数の後にコロンで区切ってそれを書くことによって型を指定してください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">implicitInteger</span> = <span class="m">70</span>
</li><li><span class="k">let</span> <span class="nv">implicitDouble</span> = <span class="m">70.0</span>
</li><li><span class="k">let</span> <span class="nv">explicitDouble</span>: <span class="nc">Double</span> = <span class="m">70</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Create a constant with an explicit type of <code class="docutils literal notranslate"><span class="pre">Float</span></code> and a value of <code class="docutils literal notranslate"><span class="pre">4</span></code>.</span><!--end_enstr-->
<span class="jpstr">
明確に<code class="docutils literal notranslate"><span class="pre">Float</span></code>の型で値<code class="docutils literal notranslate"><span class="pre">4</span></code>の定数をつくってください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Values are never implicitly converted to another type. If you need to convert a value to a different type, explicitly make an instance of the desired type.</span><!--end_enstr-->
<span class="jpstr">
なんらかの値が暗黙のうちに別の型に変換されることは決してありません。あなたがある値を異なる型に変換する必要があるならば、明示的に望む型のインスタンスにしてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">label</span> = <span class="s">"The width is "</span>
</li><li><span class="k">let</span> <span class="nv">width</span> = <span class="m">94</span>
</li><li><span class="k">let</span> <span class="nv">widthLabel</span> = <span class="nv">label</span> + <span class="nv">String</span>(<span class="nv">width</span>)
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Try removing the conversion to <code class="docutils literal notranslate"><span class="pre">String</span></code> from the last line. What error do you get?</span><!--end_enstr-->
<span class="jpstr">
最後の行から<code class="docutils literal notranslate"><span class="pre">String</span></code>への転換を取り除いてみてください。あなたは、どんなエラーを得ますか？
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash (<code class="docutils literal notranslate"><span class="pre">\</span></code>) before the parentheses. For example:</span><!--end_enstr-->
<span class="jpstr">
いろいろな値を文字列の中に含めるさらに単純な方法があります：その値を丸括弧の中に書いてください、そして丸括弧の前にバックスラッシュ（<code class="docutils literal notranslate"><span class="pre">\</span></code>）を書いてください。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">apples</span> = <span class="m">3</span>
</li><li><span class="k">let</span> <span class="nv">oranges</span> = <span class="m">5</span>
</li><li><span class="k">let</span> <span class="nv">appleSummary</span> = <span class="s">"I have </span>\<span class="p">(</span><span class="nv">apples</span><span class="p">)</span><span class="s"> apples."</span>
</li><li><span class="k">let</span> <span class="nv">fruitSummary</span> = <span class="s">"I have </span>\<span class="p">(</span><span class="nv">apples</span> + <span class="nv">oranges</span><span class="p">)</span><span class="s"> pieces of fruit."</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">\()</span></code> to include a floating-point calculation in a string and to include someone’s name in a greeting.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">\()</span></code>を、浮動小数点計算を文字列に含めるために、そして誰かの名前をある挨拶に含めるために使ってみてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Use three double quotation marks (<code class="docutils literal notranslate"><span class="pre">"""</span></code>) for strings that take up multiple lines. Indentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quotation marks. For example:</span><!--end_enstr-->
<span class="jpstr">
複数行にわたる文字列のために３つの二重引用符（<code class="docutils literal notranslate"><span class="pre">"""</span></code>）を使ってください。各引用された行の始まりでの字下げは、それが終了引用符の字下げと合致する分だけは、取り除かれます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">quotation</span> = <span class="s">"""</span>
</li><li><span class="s">I said "I have </span>\<span class="p">(</span><span class="nv">apples</span><span class="p">)</span><span class="s"> apples."</span>
</li><li><span class="s">And then I said "I have </span>\<span class="p">(</span><span class="nv">apples</span> + <span class="nv">oranges</span><span class="p">)</span><span class="s"> pieces of fruit."</span>
</li><li><span class="s">"""</span>
</li></ol></div></div></div>
<p><span class="enstr">Create arrays and dictionaries using brackets (<code class="docutils literal notranslate"><span class="pre">[]</span></code>), and access their elements by writing the index or key in brackets. A comma is allowed after the last element.</span><!--end_enstr-->
<span class="jpstr">
角括弧（<code class="docutils literal notranslate"><span class="pre">[]</span></code>）を使って配列および辞書（連想配列）を作ってください、そしてインデックスまたはキーを角括弧の中に記述することによってそれらの要素にアクセスしてください。ひとつのコンマが最後の要素のあとに許容されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">shoppingList</span> = [<span class="s">"catfish"</span>, <span class="s">"water"</span>, <span class="s">"tulips"</span>]
</li><li><span class="nv">shoppingList</span>[<span class="m">1</span>] = <span class="s">"bottle of water"</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">occupations</span> = [
</li><li>    <span class="s">"Malcolm"</span>: <span class="s">"Captain"</span>,
</li><li>    <span class="s">"Kaylee"</span>: <span class="s">"Mechanic"</span>,
</li><li>]
</li><li><span class="nv">occupations</span>[<span class="s">"Jayne"</span>] = <span class="s">"Public Relations"</span>
</li></ol></div></div></div>
<p><span class="enstr">Arrays automatically grow as you add elements.</span><!--end_enstr-->
<span class="jpstr">
配列は、あなたが要素を追加するとき自動的に増大します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span>.<span class="nv">append</span>(<span class="s">"blue paint"</span>)
</li><li><span class="nv">print</span>(<span class="nv">shoppingList</span>)
</li></ol></div></div></div>
<p><span class="enstr">To create an empty array or dictionary, use the initializer syntax.</span><!--end_enstr-->
<span class="jpstr">
空の配列または辞書を作成するために、初期化構文を使ってください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">emptyArray</span> = [<span class="nv">String</span>]()
</li><li><span class="k">let</span> <span class="nv">emptyDictionary</span> = [<span class="nv">String</span>: <span class="nv">Float</span>]()
</li></ol></div></div></div>
<p><span class="enstr">If type information can be inferred, you can write an empty array as <code class="docutils literal notranslate"><span class="pre">[]</span></code> and an empty dictionary as <code class="docutils literal notranslate"><span class="pre">[:]</span></code>—for example, when you set a new value for a variable or pass an argument to a function.</span><!--end_enstr-->
<span class="jpstr">
型情報が推論されることが出来るならば、あなたは空の配列を<code class="docutils literal notranslate"><span class="pre">[]</span></code>のように、そして空の辞書を<code class="docutils literal notranslate"><span class="pre">[:]</span></code>のように書くことができます ― 例えば、あなたが新しい値を変数に設定したり、関数に引数を渡す時に。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">shoppingList</span> = []
</li><li><span class="nv">occupations</span> = [:]
</li></ol></div></div></div>
</div>
<div class="section" id="ID462">
<h2><span class="enstr">Control Flow<a class="headerlink" href="#ID462" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
制御の流れ<a class="headerlink" href="#ID462" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">switch</span></code> to make conditionals, and use <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code>, and <code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code> to make loops. Parentheses around the condition or loop variable are optional. Braces around the body are required.</span><!--end_enstr-->
<span class="jpstr">
条件文を作るために<code class="docutils literal notranslate"><span class="pre">if</span></code>と<code class="docutils literal notranslate"><span class="pre">switch</span></code>を使ってください、そしてループを作るために<code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>、<code class="docutils literal notranslate"><span class="pre">while</span></code>、そして<code class="docutils literal notranslate"><span class="pre">repeat</span></code>-<code class="docutils literal notranslate"><span class="pre">while</span></code>を使ってください。条件またはループ変数のまわりの丸括弧は任意です。本文のまわりの波括弧は必須です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">individualScores</span> = [<span class="m">75</span>, <span class="m">43</span>, <span class="m">103</span>, <span class="m">87</span>, <span class="m">12</span>]
</li><li><span class="k">var</span> <span class="nv">teamScore</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">score</span> <span class="k">in</span> <span class="nv">individualScores</span> {
</li><li>    <span class="k">if</span> <span class="nv">score</span> &gt; <span class="m">50</span> {
</li><li>        <span class="nv">teamScore</span> += <span class="m">3</span>
</li><li>    } <span class="k">else</span> {
</li><li>        <span class="nv">teamScore</span> += <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">teamScore</span>)
</li><li><span class="c">// Prints "11"</span>
</li></ol></div></div></div>
<p><span class="enstr">In an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, the conditional must be a Boolean expression—this means that code such as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">score</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> is an error, not an implicit comparison to zero.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">if</span></code>文において、その条件を表すのはブール式でなければなりません ― これは<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">score</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>のようなコードがエラーになることを意味します、暗黙的なゼロとの比較はしないためです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span></code> together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate that a value is missing. Write a question mark (<code class="docutils literal notranslate"><span class="pre">?</span></code>) after the type of a value to mark the value as optional.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">if</span></code>と<code class="docutils literal notranslate"><span class="pre">let</span></code>を一緒に使って、見つからないかもしれない値を扱うことができます。このような値は、オプショナルであるとして表現されます。オプショナルの値は、ある値を含むか、値が見つからないことを示す<code class="docutils literal notranslate"><span class="pre">nil</span></code>を含むかのどちらかです。ある値がオプショナルであると印するために、その値の型の後に疑問符（<code class="docutils literal notranslate"><span class="pre">?</span></code>）を書いてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">optionalString</span>: <span class="nc">String</span>? = <span class="s">"Hello"</span>
</li><li><span class="nv">print</span>(<span class="nv">optionalString</span> == <span class="k">nil</span>)
</li><li><span class="c"><span class="enstr">// Prints "false"</span><!--end_enstr--><span class="jpstr">（「false」を出力します）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">optionalName</span>: <span class="nc">String</span>? = <span class="s">"John Appleseed"</span>
</li><li><span class="k">var</span> <span class="nv">greeting</span> = <span class="s">"Hello!"</span>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">optionalName</span> {
</li><li>    <span class="nv">greeting</span> = <span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>
</li><li>}
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Change <code class="docutils literal notranslate"><span class="pre">optionalName</span></code> to <code class="docutils literal notranslate"><span class="pre">nil</span></code>. What greeting do you get? Add an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause that sets a different greeting if <code class="docutils literal notranslate"><span class="pre">optionalName</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">optionalName</span></code>を<code class="docutils literal notranslate"><span class="pre">nil</span></code>に変えてください。あなたは、どんな挨拶を得ますか？<code class="docutils literal notranslate"><span class="pre">optionalName</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば異なる挨拶を設定する<code class="docutils literal notranslate"><span class="pre">else</span></code>節を加えてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If the optional value is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, the conditional is <code class="docutils literal notranslate"><span class="pre">false</span></code> and the code in braces is skipped. Otherwise, the optional value is unwrapped and assigned to the constant after <code class="docutils literal notranslate"><span class="pre">let</span></code>, which makes the unwrapped value available inside the block of code.</span><!--end_enstr-->
<span class="jpstr">
オプショナルの値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、この条件文は<code class="docutils literal notranslate"><span class="pre">false</span></code>になります、そして波括弧の中のコードはスキップされます。そうでなければ、そのオプショナルの値は包装を取られて（アンラップされて）、<code class="docutils literal notranslate"><span class="pre">let</span></code>の後の定数に代入されます、そしてそれはコードのブロックの内側で利用できる包装を取られた値（アンラップ値）になります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Another way to handle optional values is to provide a default value using the <code class="docutils literal notranslate"><span class="pre">??</span></code> operator. If the optional value is missing, the default value is used instead.</span><!--end_enstr-->
<span class="jpstr">
オプショナルの値を取り扱うもう１つの方法は、省略時の値を<code class="docutils literal notranslate"><span class="pre">??</span></code>演算子を使って提供することです。オプショナル値が見つからないならば、省略時の値が代わりに使われます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">nickname</span>: <span class="nc">String</span>? = <span class="k">nil</span>
</li><li><span class="k">let</span> <span class="nv">fullName</span>: <span class="nc">String</span> = <span class="s">"John Appleseed"</span>
</li><li><span class="k">let</span> <span class="nv">informalGreeting</span> = <span class="s">"Hi </span>\<span class="p">(</span><span class="nv">nickname</span> ?? <span class="nv">fullName</span><span class="p">)</span><span class="s">"</span>
</li></ol></div></div></div>
<p><span class="enstr">Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.</span><!--end_enstr-->
<span class="jpstr">
スイッチ（条件分岐）は、あらゆる種類のデータおよび多種多様な比較操作をサポートします ― それは、整数および同等性に対する検査に限られていません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">vegetable</span> = <span class="s">"red pepper"</span>
</li><li><span class="k">switch</span> <span class="nv">vegetable</span> {
</li><li><span class="k">case</span> <span class="s">"celery"</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Add some raisins and make ants on a log."</span>)
</li><li><span class="k">case</span> <span class="s">"cucumber"</span>, <span class="s">"watercress"</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"That would make a good tea sandwich."</span>)
</li><li><span class="k">case</span> <span class="k">let</span> <span class="nv">x</span> <span class="k">where</span> <span class="nv">x</span>.<span class="nv">hasSuffix</span>(<span class="s">"pepper"</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"Is it a spicy </span>\<span class="p">(</span><span class="nv">x</span><span class="p">)</span><span class="s">?"</span>)
</li><li><span class="k">default</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Everything tastes good in soup."</span>)
</li><li>}
</li><li><span class="c">// Prints "Is it a spicy red pepper?"</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Try removing the default case. What error do you get?</span><!--end_enstr-->
<span class="jpstr">
何れにも当てはまらない場合の部分（default: の部分）を取り除いてみてください。あなたは、どんなエラーを得ますか？
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Notice how <code class="docutils literal notranslate"><span class="pre">let</span></code> can be used in a pattern to assign the value that matched the pattern to a constant.</span><!--end_enstr-->
<span class="jpstr">
どのように<code class="docutils literal notranslate"><span class="pre">let</span></code>がパターン内で使われて、パターンに合致した値を定数に割り当てることができるかに注意してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">After executing the code inside the switch case that matched, the program exits from the switch statement. Execution doesn’t continue to the next case, so there is no need to explicitly break out of the switch at the end of each case’s code.</span><!--end_enstr-->
<span class="jpstr">
合致したスイッチのケース節（case）の内部のコードを実行した後に、プログラムはスイッチ文から出ます。実行は次の条件部分に続かないので、各条件部分のコードの終わりで明示的にスイッチから抜け出す必要はありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You use <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> to iterate over items in a dictionary by providing a pair of names to use for each key-value pair. Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.</span><!--end_enstr-->
<span class="jpstr">
あなたは<code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>を使って、辞書の中の項目のすべてに対して繰り返すことを、一対の名前を提供してそれぞれの「キーと値」の対に使用することで行います。辞書は、順序付けられないコレクションです、なのでそのキーと値は気まぐれな順番で繰り返されていきます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">interestingNumbers</span> = [
</li><li>    <span class="s">"Prime"</span>: [<span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">7</span>, <span class="m">11</span>, <span class="m">13</span>],
</li><li>    <span class="s">"Fibonacci"</span>: [<span class="m">1</span>, <span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span>, <span class="m">8</span>],
</li><li>    <span class="s">"Square"</span>: [<span class="m">1</span>, <span class="m">4</span>, <span class="m">9</span>, <span class="m">16</span>, <span class="m">25</span>],
</li><li>]
</li><li><span class="k">var</span> <span class="nv">largest</span> = <span class="m">0</span>
</li><li><span class="k">for</span> (<span class="nv">kind</span>, <span class="nv">numbers</span>) <span class="k">in</span> <span class="nv">interestingNumbers</span> {
</li><li>    <span class="k">for</span> <span class="nv">number</span> <span class="k">in</span> <span class="nv">numbers</span> {
</li><li>        <span class="k">if</span> <span class="nv">number</span> &gt; <span class="nv">largest</span> {
</li><li>            <span class="nv">largest</span> = <span class="nv">number</span>
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">largest</span>)
</li><li><span class="c">// Prints "25"</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add another variable to keep track of which kind of number was the largest, as well as what that largest number was.</span><!--end_enstr-->
<span class="jpstr">
最も大きい数が何であったかだけでなく、どの種類の数が最も大きいものであったかについて情報を把握するために、もう１つの変数を加えてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">while</span></code> to repeat a block of code until a condition changes. The condition of a loop can be at the end instead, ensuring that the loop is run at least once.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">while</span></code>を使って、コードのひとかたまり（ブロック）を、ある条件が変化するまで繰り返します。ループの条件は終わりに置くことができます、その場合にはループが少なくとも一回は実行されることを確実にします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">n</span> = <span class="m">2</span>
</li><li><span class="k">while</span> <span class="nv">n</span> &lt; <span class="m">100</span> {
</li><li>    <span class="nv">n</span> *= <span class="m">2</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">n</span>)
</li><li><span class="c">// Prints "128"</span>
</li><li>
</li><li><span class="k">var</span> <span class="nv">m</span> = <span class="m">2</span>
</li><li><span class="k">repeat</span> {
</li><li>    <span class="nv">m</span> *= <span class="m">2</span>
</li><li>} <span class="k">while</span> <span class="nv">m</span> &lt; <span class="m">100</span>
</li><li><span class="nv">print</span>(<span class="nv">m</span>)
</li><li><span class="c">// Prints "128"</span>
</li></ol></div></div></div>
<p><span class="enstr">You can keep an index in a loop by using <code class="docutils literal notranslate"><span class="pre">..&lt;</span></code> to make a range of indexes.</span><!--end_enstr-->
<span class="jpstr">
あなたは、インデックス（索引）をループにおいて保持することが、<code class="docutils literal notranslate"><span class="pre">..&lt;</span></code>を使ってインデックスの範囲を作ることで可能です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">total</span> = <span class="m">0</span>
</li><li><span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="m">4</span> {
</li><li>    <span class="nv">total</span> += <span class="nv">i</span>
</li><li>}
</li><li><span class="nv">print</span>(<span class="nv">total</span>)
</li><li><span class="c"><span class="enstr">// Prints "6"</span><!--end_enstr--><span class="jpstr">（「6」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">..&lt;</span></code> to make a range that omits its upper value, and use <code class="docutils literal notranslate"><span class="pre">...</span></code> to make a range that includes both values.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">..&lt;</span></code>をその上側の値を除く範囲を作るために使ってください、そして<code class="docutils literal notranslate"><span class="pre">...</span></code>を両方の値を含む範囲を作るために使ってください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID463">
<h2><span class="enstr">Functions and Closures<a class="headerlink" href="#ID463" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
関数とクロージャ<a class="headerlink" href="#ID463" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">func</span></code> to declare a function. Call a function by following its name with a list of arguments in parentheses. Use <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> to separate the parameter names and types from the function’s return type.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">func</span></code>を使うことで、あるひとつの関数を宣言してください。関数は、その名前の後に丸括弧に入れた引数の目録（リスト）を続けることで呼び出します。<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>を使って、パラメーター名とその関数の返す型とを隔ててください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="nv">person</span>: <span class="nc">String</span>, <span class="nv">day</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> {
</li><li>    <span class="k">return</span> <span class="s">"Hello </span>\<span class="p">(</span><span class="nv">person</span><span class="p">)</span><span class="s">, today is </span>\<span class="p">(</span><span class="nv">day</span><span class="p">)</span><span class="s">."</span>
</li><li>}
</li><li><span class="nv">greet</span>(<span class="nv">person</span>: <span class="s">"Bob"</span>, <span class="nv">day</span>: <span class="s">"Tuesday"</span>)
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Remove the <code class="docutils literal notranslate"><span class="pre">day</span></code> parameter. Add a parameter to include today’s lunch special in the greeting.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">day</span></code>パラメータを取り除いてください。今日のスペシャル・ランチをこの挨拶に含めるために、パラメータをひとつ加えてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">By default, functions use their parameter names as labels for their arguments. Write a custom argument label before the parameter name, or write <code class="docutils literal notranslate"><span class="pre">_</span></code> to use no argument label.</span><!--end_enstr-->
<span class="jpstr">
特に何もしなくとも、関数はそれらのパラメータ名をそれらの引数のラベルとして使います。あつらえの引数ラベルはパラメータ名の前に書いてください、または引数ラベルなしで使うためには<code class="docutils literal notranslate"><span class="pre">_</span></code>を書いてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">greet</span>(<span class="k">_</span> <span class="nv">person</span>: <span class="nc">String</span>, <span class="nv">on</span> <span class="nv">day</span>: <span class="nc">String</span>) -&gt; <span class="nc">String</span> {
</li><li>    <span class="k">return</span> <span class="s">"Hello </span>\<span class="p">(</span><span class="nv">person</span><span class="p">)</span><span class="s">, today is </span>\<span class="p">(</span><span class="nv">day</span><span class="p">)</span><span class="s">."</span>
</li><li>}
</li><li><span class="nv">greet</span>(<span class="s">"John"</span>, <span class="nv">on</span>: <span class="s">"Wednesday"</span>)
</li></ol></div></div></div>
<p><span class="enstr">Use a tuple to make a compound value—for example, to return multiple values from a function. The elements of a tuple can be referred to either by name or by number.</span><!--end_enstr-->
<span class="jpstr">
ある混成の値を作るために、タプル（一組にしたもの）を使ってください ― 例えば、関数から複数の値を返すために。あるタプルの要素それらは、名前または番号で言及されることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">calculateStatistics</span>(<span class="nv">scores</span>: [<span class="nc">Int</span>]) -&gt; (<span class="nv">min</span>: <span class="nc">Int</span>, <span class="nv">max</span>: <span class="nc">Int</span>, <span class="nv">sum</span>: <span class="nc">Int</span>) {
</li><li>    <span class="k">var</span> <span class="nv">min</span> = <span class="nv">scores</span>[<span class="m">0</span>]
</li><li>    <span class="k">var</span> <span class="nv">max</span> = <span class="nv">scores</span>[<span class="m">0</span>]
</li><li>    <span class="k">var</span> <span class="nv">sum</span> = <span class="m">0</span>
</li><li>
</li><li>    <span class="k">for</span> <span class="nv">score</span> <span class="k">in</span> <span class="nv">scores</span> {
</li><li>        <span class="k">if</span> <span class="nv">score</span> &gt; <span class="nv">max</span> {
</li><li>            <span class="nv">max</span> = <span class="nv">score</span>
</li><li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">score</span> &lt; <span class="nv">min</span> {
</li><li>            <span class="nv">min</span> = <span class="nv">score</span>
</li><li>        }
</li><li>        <span class="nv">sum</span> += <span class="nv">score</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">return</span> (<span class="nv">min</span>, <span class="nv">max</span>, <span class="nv">sum</span>)
</li><li>}
</li><li><span class="k">let</span> <span class="nv">statistics</span> = <span class="nv">calculateStatistics</span>(<span class="nv">scores</span>: [<span class="m">5</span>, <span class="m">3</span>, <span class="m">100</span>, <span class="m">3</span>, <span class="m">9</span>])
</li><li><span class="nv">print</span>(<span class="nv">statistics</span>.<span class="nv">sum</span>)
</li><li><span class="c">// Prints "120"</span>
</li><li><span class="nv">print</span>(<span class="nv">statistics</span>.<span class="m">2</span>)
</li><li><span class="c">// Prints "120"</span>
</li></ol></div></div></div>
<p><span class="enstr">Functions can be nested. Nested functions have access to variables that were declared in the outer function. You can use nested functions to organize the code in a function that is long or complex.</span><!--end_enstr-->
<span class="jpstr">
関数は、入れ子にされることができます。入れ子にされた関数は、外側の関数において宣言された変数に、アクセスをします。あなたは、長いか複雑である関数においてコードを組織するために、入れ子にされた関数を使用することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">returnFifteen</span>() -&gt; <span class="nc">Int</span> {
</li><li>    <span class="k">var</span> <span class="nv">y</span> = <span class="m">10</span>
</li><li>    <span class="k">func</span> <span class="nv">add</span>() {
</li><li>        <span class="nv">y</span> += <span class="m">5</span>
</li><li>    }
</li><li>    <span class="nv">add</span>()
</li><li>    <span class="k">return</span> <span class="nv">y</span>
</li><li>}
</li><li><span class="nv">returnFifteen</span>()
</li></ol></div></div></div>
<p><span class="enstr">Functions are a first-class type. This means that a function can return another function as its value.</span><!--end_enstr-->
<span class="jpstr">
関数は、第一級（ファーストクラス）の種類のものです。これは、ある関数が別の関数をその値として返すことができるのを意味します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeIncrementer</span>() -&gt; ((<span class="nc">Int</span>) -&gt; <span class="nc">Int</span>) {
</li><li>    <span class="k">func</span> <span class="nv">addOne</span>(<span class="nv">number</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="m">1</span> + <span class="nv">number</span>
</li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">addOne</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">increment</span> = <span class="nv">makeIncrementer</span>()
</li><li><span class="nv">increment</span>(<span class="m">7</span>)
</li></ol></div></div></div>
<p><span class="enstr">A function can take another function as one of its arguments.</span><!--end_enstr-->
<span class="jpstr">
ある関数は、その引数の１つとして別の関数をとることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">hasAnyMatches</span>(<span class="nv">list</span>: [<span class="nc">Int</span>], <span class="nv">condition</span>: (<span class="nc">Int</span>) -&gt; <span class="nc">Bool</span>) -&gt; <span class="nc">Bool</span> {
</li><li>    <span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">list</span> {
</li><li>        <span class="k">if</span> <span class="nv">condition</span>(<span class="nv">item</span>) {
</li><li>            <span class="k">return</span> <span class="k">true</span>
</li><li>        }
</li><li>    }
</li><li>    <span class="k">return</span> <span class="k">false</span>
</li><li>}
</li><li><span class="k">func</span> <span class="nv">lessThanTen</span>(<span class="nv">number</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li>    <span class="k">return</span> <span class="nv">number</span> &lt; <span class="m">10</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">numbers</span> = [<span class="m">20</span>, <span class="m">19</span>, <span class="m">7</span>, <span class="m">12</span>]
</li><li><span class="nv">hasAnyMatches</span>(<span class="nv">list</span>: <span class="nv">numbers</span>, <span class="nv">condition</span>: <span class="nv">lessThanTen</span>)
</li></ol></div></div></div>
<p><span class="enstr">Functions are actually a special case of closures: blocks of code that can be called later. The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions. You can write a closure without a name by surrounding code with braces (<code class="docutils literal notranslate"><span class="pre">{}</span></code>). Use <code class="docutils literal notranslate"><span class="pre">in</span></code> to separate the arguments and return type from the body.</span><!--end_enstr-->
<span class="jpstr">
関数は、実際のところクロージャ：後刻に呼び出されることができるコードのひとまとまり、の特別な場合です。あるクロージャの中のコードは、そのクロージャが作成されたところのスコープ内で利用可能だった変数や関数といったものにアクセスをします、たとえそのクロージャが実行されるときに異なるスコープの中にあってもです ― あなたはこの例を入れ子にされた関数で既に見ました。あなたは、名前なしで波括弧（<code class="docutils literal notranslate"><span class="pre">{}</span></code>）でコードを囲むことによってクロージャを書くことができます。<code class="docutils literal notranslate"><span class="pre">in</span></code>を使って、引数および返す型を本文から切り離してください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">numbers</span>.<span class="nv">map</span>({ (<span class="nv">number</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> <span class="k">in</span>
</li><li>    <span class="k">let</span> <span class="nv">result</span> = <span class="m">3</span> * <span class="nv">number</span>
</li><li>    <span class="k">return</span> <span class="nv">result</span>
</li><li>})
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Rewrite the closure to return zero for all odd numbers.</span><!--end_enstr-->
<span class="jpstr">
このクロージャを、全ての奇数に対してゼロを返すように書き直してください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You have several options for writing closures more concisely. When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both. Single statement closures implicitly return the value of their only statement.</span><!--end_enstr-->
<span class="jpstr">
あなたは、より簡潔にクロージャを書くためにいくつかの選択肢を持ちます。クロージャの型がすでに知られているとき、例えば委任先のためのコールバックなどでは、あなたはそのパラメータの型、その戻り型、あるいは両方を省略することができます。ひとつだけの文のクロージャは、暗黙のうちにそのただ１つの文の値を返します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">mappedNumbers</span> = <span class="nv">numbers</span>.<span class="nv">map</span>({ <span class="nv">number</span> <span class="k">in</span> <span class="m">3</span> * <span class="nv">number</span> })
</li><li><span class="nv">print</span>(<span class="nv">mappedNumbers</span>)
</li><li><span class="c">// Prints "[60, 57, 21, 36]"</span>
</li></ol></div></div></div>
<p><span class="enstr">You can refer to parameters by number instead of by name—this approach is especially useful in very short closures. A closure passed as the last argument to a function can appear immediately after the parentheses. When a closure is the only argument to a function, you can omit the parentheses entirely.</span><!--end_enstr-->
<span class="jpstr">
あなたは、名前によってでなく、数によってパラメータに言及することができます ― この取り組み方は、特に非常に短いクロージャで役立ちます。最後の引数として関数に渡されるクロージャは、丸括弧の直後に現れることができます。ひとつのクロージャが関数の唯一の引数である時、あなたは丸括弧をすっかり省くことができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">sortedNumbers</span> = <span class="nv">numbers</span>.<span class="nv">sorted</span> { <span class="nv">$0</span> &gt; <span class="nv">$1</span> }
</li><li><span class="nv">print</span>(<span class="nv">sortedNumbers</span>)
</li><li><span class="c">// Prints "[20, 19, 12, 7]"</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID464">
<h2><span class="enstr">Objects and Classes<a class="headerlink" href="#ID464" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オブジェクトとクラス<a class="headerlink" href="#ID464" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">class</span></code> followed by the class’s name to create a class. A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class. Likewise, method and function declarations are written the same way.</span><!--end_enstr-->
<span class="jpstr">
あるクラスを作成するために<code class="docutils literal notranslate"><span class="pre">class</span></code>を使ってその後にそのクラスの名前を続けてください。クラスの中のプロパティ宣言は、定数または変数の宣言と同じ方法で書かれます、ただしそれはクラスの前後関係の中にあります。さらにまた、メソッドおよび関数の宣言も同じやり方で書かれます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">numberOfSides</span> = <span class="m">0</span>
</li><li>    <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"A shape with </span>\<span class="p">(</span><span class="nv">numberOfSides</span><span class="p">)</span><span class="s"> sides."</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add a constant property with <code class="docutils literal notranslate"><span class="pre">let</span></code>, and add another method that takes an argument.</span><!--end_enstr-->
<span class="jpstr">
定数プロパティを<code class="docutils literal notranslate"><span class="pre">let</span></code>を使って１つ加えてください、そして１つの引数をとる別のメソッドを加えてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Create an instance of a class by putting parentheses after the class name. Use dot syntax to access the properties and methods of the instance.</span><!--end_enstr-->
<span class="jpstr">
クラス名の後に丸括弧を置くことによって、クラスのインスタンスをつくってください。そのインスタンスのプロパティおよびメソッドにアクセスするためにドット構文を使用してください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">shape</span> = <span class="nv">Shape</span>()
</li><li><span class="nv">shape</span>.<span class="nv">numberOfSides</span> = <span class="m">7</span>
</li><li><span class="k">var</span> <span class="nv">shapeDescription</span> = <span class="nv">shape</span>.<span class="nv">simpleDescription</span>()
</li></ol></div></div></div>
<p><span class="enstr">This version of the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> class is missing something important: an initializer to set up the class when an instance is created. Use <code class="docutils literal notranslate"><span class="pre">init</span></code> to create one.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Shape</span></code>クラスのこの版は、重要なあるもの：インスタンスが作られるときにクラスを設定準備するイニシャライザ（初期化子）、が欠けています。そうしたものをつくるために、<code class="docutils literal notranslate"><span class="pre">init</span></code>を使ってください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">NamedShape</span> {
</li><li>    <span class="k">var</span> <span class="nv">numberOfSides</span>: <span class="nc">Int</span> = <span class="m">0</span>
</li><li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"A shape with </span>\<span class="p">(</span><span class="nv">numberOfSides</span><span class="p">)</span><span class="s"> sides."</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Notice how <code class="docutils literal notranslate"><span class="pre">self</span></code> is used to distinguish the <code class="docutils literal notranslate"><span class="pre">name</span></code> property from the <code class="docutils literal notranslate"><span class="pre">name</span></code> argument to the initializer. The arguments to the initializer are passed like a function call when you create an instance of the class. Every property needs a value assigned—either in its declaration (as with <code class="docutils literal notranslate"><span class="pre">numberOfSides</span></code>) or in the initializer (as with <code class="docutils literal notranslate"><span class="pre">name</span></code>).</span><!--end_enstr-->
<span class="jpstr">
どのように<code class="docutils literal notranslate"><span class="pre">self</span></code>が<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティをイニシャライザのための<code class="docutils literal notranslate"><span class="pre">name</span></code>引数と区別するために使われるかに注意してください。イニシャライザに対する引数は、あなたがクラスのインスタンスをつくるときに関数呼び出しのように渡されます。あらゆるプロパティは、代入される値を必要とします ― その宣言において（<code class="docutils literal notranslate"><span class="pre">numberOfSides</span></code>でのように）またはイニシャライザにおいて（<code class="docutils literal notranslate"><span class="pre">name</span></code>でのように）のどちらでも。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">deinit</span></code> to create a deinitializer if you need to perform some cleanup before the object is deallocated.</span><!--end_enstr-->
<span class="jpstr">
オブジェクトが割り当て解除される前にあなたがいくらかの掃除をする必要があるならば、デイニシャライザをつくるために、<code class="docutils literal notranslate"><span class="pre">deinit</span></code>を使ってください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Subclasses include their superclass name after their class name, separated by a colon. There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</span><!--end_enstr-->
<span class="jpstr">
サブクラスそれらは、それらのクラス名の後に、コロンで区切られた、それらのスーパークラス名を含みます。何らかの標準となるルートクラスのサブクラスであることは、クラスにとって必要条件ではありません、そのためあなたは必要に応じてスーパークラスを含めたり省略したりすることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Methods on a subclass that override the superclass’s implementation are marked with <code class="docutils literal notranslate"><span class="pre">override</span></code>—overriding a method by accident, without <code class="docutils literal notranslate"><span class="pre">override</span></code>, is detected by the compiler as an error. The compiler also detects methods with <code class="docutils literal notranslate"><span class="pre">override</span></code> that don’t actually override any method in the superclass.</span><!--end_enstr-->
<span class="jpstr">
あるサブクラスのメソッドで、そのスーパークラスの実装をオーバーライド（再定義）するものは、<code class="docutils literal notranslate"><span class="pre">override</span></code>で印を付けられます ― <code class="docutils literal notranslate"><span class="pre">override</span></code>なしで、偶然にメソッドをオーバーライドすることは、コンパイラによってエラーとして検出されます。コンパイラはまた、実際にはスーパークラスにおけるメソッドを少しもオーバーライドしない<code class="docutils literal notranslate"><span class="pre">override</span></code>をもつメソッドも検出します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Square</span>: <span class="nc">NamedShape</span> {
</li><li>    <span class="k">var</span> <span class="nv">sideLength</span>: <span class="nc">Double</span>
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">sideLength</span>: <span class="nc">Double</span>, <span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">sideLength</span> = <span class="nv">sideLength</span>
</li><li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>        <span class="nv">numberOfSides</span> = <span class="m">4</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">func</span> <span class="nv">area</span>() -&gt; <span class="nc">Double</span> {
</li><li>        <span class="k">return</span> <span class="nv">sideLength</span> * <span class="nv">sideLength</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">override</span> <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"A square with sides of length </span>\<span class="p">(</span><span class="nv">sideLength</span><span class="p">)</span><span class="s">."</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">test</span> = <span class="nv">Square</span>(<span class="nv">sideLength</span>: <span class="m">5.2</span>, <span class="nv">name</span>: <span class="s">"my test square"</span>)
</li><li><span class="nv">test</span>.<span class="nv">area</span>()
</li><li><span class="nv">test</span>.<span class="nv">simpleDescription</span>()
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Make another subclass of <code class="docutils literal notranslate"><span class="pre">NamedShape</span></code> called <code class="docutils literal notranslate"><span class="pre">Circle</span></code> that takes a radius and a name as arguments to its initializer. Implement an <code class="docutils literal notranslate"><span class="pre">area()</span></code> and a <code class="docutils literal notranslate"><span class="pre">simpleDescription()</span></code> method on the <code class="docutils literal notranslate"><span class="pre">Circle</span></code> class.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">NamedShape</span></code>の別のサブクラス、<code class="docutils literal notranslate"><span class="pre">Circle</span></code>と呼ばれるものを作ってください、それはそのイニシャライザに対する引数として半径と名前をとるものです。<code class="docutils literal notranslate"><span class="pre">area()</span></code>および<code class="docutils literal notranslate"><span class="pre">simpleDescription()</span></code>メソッドを<code class="docutils literal notranslate"><span class="pre">Circle</span></code>クラス上で実装してください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">In addition to simple properties that are stored, properties can have a getter and a setter.</span><!--end_enstr-->
<span class="jpstr">
格納される単純なプロパティに加えて、プロパティはゲッター（取得メソッド）とセッター（設定メソッド）を持つことができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">EquilateralTriangle</span>: <span class="nc">NamedShape</span> {
</li><li>    <span class="k">var</span> <span class="nv">sideLength</span>: <span class="nc">Double</span> = <span class="m">0.0</span>
</li><li>
</li><li>    <span class="k">init</span>(<span class="nv">sideLength</span>: <span class="nc">Double</span>, <span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">sideLength</span> = <span class="nv">sideLength</span>
</li><li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li><li>        <span class="nv">numberOfSides</span> = <span class="m">3</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">var</span> <span class="nv">perimeter</span>: <span class="nc">Double</span> {
</li><li>        <span class="k">get</span> {
</li><li>            <span class="k">return</span> <span class="m">3.0</span> * <span class="nv">sideLength</span>
</li><li>        }
</li><li>        <span class="k">set</span> {
</li><li>            <span class="nv">sideLength</span> = <span class="nv">newValue</span> / <span class="m">3.0</span>
</li><li>        }
</li><li>    }
</li><li>
</li><li>    <span class="k">override</span> <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"An equilateral triangle with sides of length </span>\<span class="p">(</span><span class="nv">sideLength</span><span class="p">)</span><span class="s">."</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">triangle</span> = <span class="nv">EquilateralTriangle</span>(<span class="nv">sideLength</span>: <span class="m">3.1</span>, <span class="nv">name</span>: <span class="s">"a triangle"</span>)
</li><li><span class="nv">print</span>(<span class="nv">triangle</span>.<span class="nv">perimeter</span>)
</li><li><span class="c">// Prints "9.3"</span>
</li><li><span class="nv">triangle</span>.<span class="nv">perimeter</span> = <span class="m">9.9</span>
</li><li><span class="nv">print</span>(<span class="nv">triangle</span>.<span class="nv">sideLength</span>)
</li><li><span class="c">// Prints "3.3000000000000003"</span>
</li></ol></div></div></div>
<p><span class="enstr">In the setter for <code class="docutils literal notranslate"><span class="pre">perimeter</span></code>, the new value has the implicit name <code class="docutils literal notranslate"><span class="pre">newValue</span></code>. You can provide an explicit name in parentheses after <code class="docutils literal notranslate"><span class="pre">set</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">perimeter</span></code>のためのセッターにおいて、新しい値は、隠された名前<code class="docutils literal notranslate"><span class="pre">newValue</span></code>を持ちます。あなたは、<code class="docutils literal notranslate"><span class="pre">set</span></code>の後に括弧の中ではっきりとした名前を提供することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Notice that the initializer for the <code class="docutils literal notranslate"><span class="pre">EquilateralTriangle</span></code> class has three different steps:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">EquilateralTriangle</span></code>クラスのためのイニシャライザが３つの異なる段階を持つことに注意してください：
</span><!--end_jpstr-->
</p>
<ol class="arabic simple">
<li><span class="enstr">Setting the value of properties that the subclass declares.</span><!--end_enstr-->
<span class="jpstr">
サブクラスが宣言するプロパティの値を設定する。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Calling the superclass’s initializer.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスのイニシャライザを呼ぶ。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Changing the value of properties defined by the superclass. Any additional setup work that uses methods, getters, or setters can also be done at this point.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスによって定義されるプロパティの値を変える。メソッド、ゲッター、またはセッターを使うどんな追加の準備作業も、また、この時点で行われることができます。
</span><!--end_jpstr-->
</li>
</ol>
<p><span class="enstr">If you don’t need to compute the property but still need to provide code that is run before and after setting a new value, use <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code>. The code you provide is run any time the value changes outside of an initializer. For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.</span><!--end_enstr-->
<span class="jpstr">
あなたが、プロパティを計算する必要がないにもかかわらず新しい値の設定の前や後で実行されるコードを提供する必要があるならば、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>や<code class="docutils literal notranslate"><span class="pre">didSet</span></code>を使ってください。あなたが提供したコードは、その値がイニシャライザの外側で変化する時はいつでも実行されます。例えば、下のクラスは、その三角形の横の長さが常にその正方形の横の長さと同じものであることを確実にします。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">TriangleAndSquare</span> {
</li><li>    <span class="k">var</span> <span class="nv">triangle</span>: <span class="nc">EquilateralTriangle</span> {
</li><li>        <span class="k">willSet</span> {
</li><li>            <span class="nv">square</span>.<span class="nv">sideLength</span> = <span class="nv">newValue</span>.<span class="nv">sideLength</span>
</li><li>        }
</li><li>    }
</li><li>    <span class="k">var</span> <span class="nv">square</span>: <span class="nc">Square</span> {
</li><li>        <span class="k">willSet</span> {
</li><li>            <span class="nv">triangle</span>.<span class="nv">sideLength</span> = <span class="nv">newValue</span>.<span class="nv">sideLength</span>
</li><li>        }
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">size</span>: <span class="nc">Double</span>, <span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="nv">square</span> = <span class="nv">Square</span>(<span class="nv">sideLength</span>: <span class="nv">size</span>, <span class="nv">name</span>: <span class="nv">name</span>)
</li><li>        <span class="nv">triangle</span> = <span class="nv">EquilateralTriangle</span>(<span class="nv">sideLength</span>: <span class="nv">size</span>, <span class="nv">name</span>: <span class="nv">name</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">triangleAndSquare</span> = <span class="nv">TriangleAndSquare</span>(<span class="nv">size</span>: <span class="m">10</span>, <span class="nv">name</span>: <span class="s">"another test shape"</span>)
</li><li><span class="nv">print</span>(<span class="nv">triangleAndSquare</span>.<span class="nv">square</span>.<span class="nv">sideLength</span>)
</li><li><span class="c">// Prints "10.0"</span>
</li><li><span class="nv">print</span>(<span class="nv">triangleAndSquare</span>.<span class="nv">triangle</span>.<span class="nv">sideLength</span>)
</li><li><span class="c">// Prints "10.0"</span>
</li><li><span class="nv">triangleAndSquare</span>.<span class="nv">square</span> = <span class="nv">Square</span>(<span class="nv">sideLength</span>: <span class="m">50</span>, <span class="nv">name</span>: <span class="s">"larger square"</span>)
</li><li><span class="nv">print</span>(<span class="nv">triangleAndSquare</span>.<span class="nv">triangle</span>.<span class="nv">sideLength</span>)
</li><li><span class="c">// Prints "50.0"</span>
</li></ol></div></div></div>
<p><span class="enstr">When working with optional values, you can write <code class="docutils literal notranslate"><span class="pre">?</span></code> before operations like methods, properties, and subscripting. If the value before the <code class="docutils literal notranslate"><span class="pre">?</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code>, everything after the <code class="docutils literal notranslate"><span class="pre">?</span></code> is ignored and the value of the whole expression is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Otherwise, the optional value is unwrapped, and everything after the <code class="docutils literal notranslate"><span class="pre">?</span></code> acts on the unwrapped value. In both cases, the value of the whole expression is an optional value.</span><!--end_enstr-->
<span class="jpstr">
オプショナルの値を扱うとき、あなたはメソッド、プロパティ、そして添え字指定のような演算の前に<code class="docutils literal notranslate"><span class="pre">?</span></code>を書くことができます。<code class="docutils literal notranslate"><span class="pre">?</span></code>の前の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>ならば、<code class="docutils literal notranslate"><span class="pre">?</span></code>の後のすべてのものは、無視されて、その全体の式の値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。そうでなければ、オプショナルの値は包装を取られます（アンラップされます）、そして<code class="docutils literal notranslate"><span class="pre">?</span></code>の後のすべてのものは包装を取られた値（アンラップ値）に作用します。両方の場合で、その全体の式の値は、オプショナルの値となります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">optionalSquare</span>: <span class="nc">Square</span>? = <span class="nv">Square</span>(<span class="nv">sideLength</span>: <span class="m">2.5</span>, <span class="nv">name</span>: <span class="s">"optional square"</span>)
</li><li><span class="k">let</span> <span class="nv">sideLength</span> = <span class="nv">optionalSquare</span>?.<span class="nv">sideLength</span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID465">
<h2><span class="enstr">Enumerations and Structures<a class="headerlink" href="#ID465" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙と構造体<a class="headerlink" href="#ID465" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">enum</span></code> to create an enumeration. Like classes and all other named types, enumerations can have methods associated with them.</span><!--end_enstr-->
<span class="jpstr">
列挙をつくるために、<code class="docutils literal notranslate"><span class="pre">enum</span></code>を使ってください。クラスや全ての他の名前をつけられた型のように、列挙はそれと結びつけられるメソッドを持つことができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Rank</span>: <span class="nc">Int</span> {
</li><li>    <span class="k">case</span> <span class="nv">ace</span> = <span class="m">1</span>
</li><li>    <span class="k">case</span> <span class="nv">two</span>, <span class="nv">three</span>, <span class="nv">four</span>, <span class="nv">five</span>, <span class="nv">six</span>, <span class="nv">seven</span>, <span class="nv">eight</span>, <span class="nv">nine</span>, <span class="nv">ten</span>
</li><li>    <span class="k">case</span> <span class="nv">jack</span>, <span class="nv">queen</span>, <span class="nv">king</span>
</li><li>
</li><li>    <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">switch</span> <span class="k">self</span> {
</li><li>        <span class="k">case</span> .<span class="nv">ace</span>:
</li><li>            <span class="k">return</span> <span class="s">"ace"</span>
</li><li>        <span class="k">case</span> .<span class="nv">jack</span>:
</li><li>            <span class="k">return</span> <span class="s">"jack"</span>
</li><li>        <span class="k">case</span> .<span class="nv">queen</span>:
</li><li>            <span class="k">return</span> <span class="s">"queen"</span>
</li><li>        <span class="k">case</span> .<span class="nv">king</span>:
</li><li>            <span class="k">return</span> <span class="s">"king"</span>
</li><li>        <span class="k">default</span>:
</li><li>            <span class="k">return</span> <span class="nv">String</span>(<span class="k">self</span>.<span class="nv">rawValue</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">ace</span> = <span class="nv">Rank</span>.<span class="nv">ace</span>
</li><li><span class="k">let</span> <span class="nv">aceRawValue</span> = <span class="nv">ace</span>.<span class="nv">rawValue</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Write a function that compares two <code class="docutils literal notranslate"><span class="pre">Rank</span></code> values by comparing their raw values.</span><!--end_enstr-->
<span class="jpstr">
それらの生の値を比較することによって２つの<code class="docutils literal notranslate"><span class="pre">Rank</span></code>の値を比較する関数を記述してください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values. In the example above, <code class="docutils literal notranslate"><span class="pre">Ace</span></code> is explicitly given a raw value of <code class="docutils literal notranslate"><span class="pre">1</span></code>, and the rest of the raw values are assigned in order. You can also use strings or floating-point numbers as the raw type of an enumeration. Use the <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> property to access the raw value of an enumeration case.</span><!--end_enstr-->
<span class="jpstr">
初期状態で、スウィフトはゼロで開始して毎回１つ増加させながら生の値を割り当てます、しかしあなたは明示的にそれらの値を指定することでこの挙動を変更できます。上の例では、<code class="docutils literal notranslate"><span class="pre">Ace</span></code>は暗黙的に<code class="docutils literal notranslate"><span class="pre">1</span></code>の生の値を与えられます、そして残りの生の値は順に割り当てられます。あなたはまた、列挙の生の型として、文字列または浮動小数点数を使うことができます。<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>プロパティを使用して、列挙ケース節の生の値にアクセスしてください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use the <code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code> initializer to make an instance of an enumeration from a raw value. It returns either the enumeration case matching the raw value or <code class="docutils literal notranslate"><span class="pre">nil</span></code> if there is no matching <code class="docutils literal notranslate"><span class="pre">Rank</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code>イニシャライザを使用して、生の値から列挙のインスタンスを作ってください。それは、その生の値に合致する列挙ケース節、または合致する<code class="docutils literal notranslate"><span class="pre">Rank</span></code>がないならば<code class="docutils literal notranslate"><span class="pre">nil</span></code>のどちらかを返します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">if</span> <span class="k">let</span> <span class="nv">convertedRank</span> = <span class="nv">Rank</span>(<span class="nv">rawValue</span>: <span class="m">3</span>) {
</li><li>    <span class="k">let</span> <span class="nv">threeDescription</span> = <span class="nv">convertedRank</span>.<span class="nv">simpleDescription</span>()
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The case values of an enumeration are actual values, not just another way of writing their raw values. In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</span><!--end_enstr-->
<span class="jpstr">
ある列挙に属するケース節の値は実際の値です、単にそれらの生の値を別のやり方で書くことではありません。実際、意味がある生の値がない状況の場合には、あなたはそれを提供する必要はありません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Suit</span> {
</li><li>    <span class="k">case</span> <span class="nv">spades</span>, <span class="nv">hearts</span>, <span class="nv">diamonds</span>, <span class="nv">clubs</span>
</li><li>
</li><li>    <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">switch</span> <span class="k">self</span> {
</li><li>        <span class="k">case</span> .<span class="nv">spades</span>:
</li><li>            <span class="k">return</span> <span class="s">"spades"</span>
</li><li>        <span class="k">case</span> .<span class="nv">hearts</span>:
</li><li>            <span class="k">return</span> <span class="s">"hearts"</span>
</li><li>        <span class="k">case</span> .<span class="nv">diamonds</span>:
</li><li>            <span class="k">return</span> <span class="s">"diamonds"</span>
</li><li>        <span class="k">case</span> .<span class="nv">clubs</span>:
</li><li>            <span class="k">return</span> <span class="s">"clubs"</span>
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">hearts</span> = <span class="nv">Suit</span>.<span class="nv">hearts</span>
</li><li><span class="k">let</span> <span class="nv">heartsDescription</span> = <span class="nv">hearts</span>.<span class="nv">simpleDescription</span>()
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add a <code class="docutils literal notranslate"><span class="pre">color()</span></code> method to <code class="docutils literal notranslate"><span class="pre">Suit</span></code> that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">color()</span></code>メソッドを<code class="docutils literal notranslate"><span class="pre">Suit</span></code>に加えてください、それはスペードとクラブのために「黒」を、そしてハートとダイヤのために「赤」を返すものです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Notice the two ways that the <code class="docutils literal notranslate"><span class="pre">hearts</span></code> case of the enumeration is referred to above: When assigning a value to the <code class="docutils literal notranslate"><span class="pre">hearts</span></code> constant, the enumeration case <code class="docutils literal notranslate"><span class="pre">Suit.hearts</span></code> is referred to by its full name because the constant doesn’t have an explicit type specified. Inside the switch, the enumeration case is referred to by the abbreviated form <code class="docutils literal notranslate"><span class="pre">.hearts</span></code> because the value of <code class="docutils literal notranslate"><span class="pre">self</span></code> is already known to be a suit. You can use the abbreviated form anytime the value’s type is already known.</span><!--end_enstr-->
<span class="jpstr">
上記で列挙の<code class="docutils literal notranslate"><span class="pre">hearts</span></code>ケース節が参照される２つの方法に注意してください：定数の<code class="docutils literal notranslate"><span class="pre">hearts</span></code>に値を代入するとき、列挙のケース節<code class="docutils literal notranslate"><span class="pre">Suit.hearts</span></code>はそのフルネームによって参照されます、なぜならこの定数には明確に指定される型がないからです。スイッチの内側では、列挙のケース節は省略された形式<code class="docutils literal notranslate"><span class="pre">.hearts</span></code>によって参照されます、なぜなら<code class="docutils literal notranslate"><span class="pre">self</span></code>の値がすでに組み札のひとつ（スペード、クラブ、ハート、ダイヤのどれか）であるということがわかっているからです。あなたは、値の型がすでに知られているときはいつでも省略形を使うことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value. Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case. You can think of the associated values as behaving like stored properties of the enumeration case instance. For example, consider the case of requesting the sunrise and sunset times from a server. The server either responds with the requested information, or it responds with a description of what went wrong.</span><!--end_enstr-->
<span class="jpstr">
ある列挙が生の値を持つならば、それらの値は宣言の一部として決定されます、それはある特定の列挙ケース節のすべてのインスタンスが常に同じ生の値を持つことを意味します。列挙ケース節の別の選択はそのケース節と結びつけられる値を持つことになります — それらの値はあなたがインスタンスを作る時に決定されます、そしてそれらはある列挙ケース節のインスタンスそれぞれで異なることができます。あなたはそれら関連値を、その列挙ケース節インスタンスに属する格納プロパティのように振る舞うものとして考えることができます。例えば、日の出と日没の時間をあるサーバーに要請する場合を考えてください。そのサーバーは要請された情報で応答するか、またはそれは何がうまくいかなかったかの説明で応答するかのどちらかです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ServerResponse</span> {
</li><li>    <span class="k">case</span> <span class="nv">result</span>(<span class="nv">String</span>, <span class="nv">String</span>)
</li><li>    <span class="k">case</span> <span class="nv">failure</span>(<span class="nv">String</span>)
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">success</span> = <span class="nv">ServerResponse</span>.<span class="nv">result</span>(<span class="s">"6:00 am"</span>, <span class="s">"8:09 pm"</span>)
</li><li><span class="k">let</span> <span class="nv">failure</span> = <span class="nv">ServerResponse</span>.<span class="nv">failure</span>(<span class="s">"Out of cheese."</span>)
</li><li>
</li><li><span class="k">switch</span> <span class="nv">success</span> {
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">result</span>(<span class="nv">sunrise</span>, <span class="nv">sunset</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"Sunrise is at </span>\<span class="p">(</span><span class="nv">sunrise</span><span class="p">)</span><span class="s"> and sunset is at </span>\<span class="p">(</span><span class="nv">sunset</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">failure</span>(<span class="nv">message</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"Failure...  </span>\<span class="p">(</span><span class="nv">message</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c">// Prints "Sunrise is at 6:00 am and sunset is at 8:09 pm."</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add a third case to <code class="docutils literal notranslate"><span class="pre">ServerResponse</span></code> and to the switch.</span><!--end_enstr-->
<span class="jpstr">
第３の場合を<code class="docutils literal notranslate"><span class="pre">ServerResponse</span></code>に、そしてスイッチに加えてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Notice how the sunrise and sunset times are extracted from the <code class="docutils literal notranslate"><span class="pre">ServerResponse</span></code> value as part of matching the value against the switch cases.</span><!--end_enstr-->
<span class="jpstr">
どのように日の出と日没の時間が<code class="docutils literal notranslate"><span class="pre">ServerResponse</span></code>の値から、その値をスイッチの各条件と比較することの一環として抽出されるかに注意してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">struct</span></code> to create a structure. Structures support many of the same behaviors as classes, including methods and initializers. One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.</span><!--end_enstr-->
<span class="jpstr">
構造体を作成するために、<code class="docutils literal notranslate"><span class="pre">struct</span></code>を使ってください。構造体は、クラスと同じ挙動の多くを、メソッドとイニシャライザも含めてサポートします。構造体とクラスの間の１つの最も重要な違いは、それらがあなたのコードにおいてあちこち渡されるとき、構造体は常にコピーされるということです、それに対してクラスは参照によって渡されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Card</span> {
</li><li>    <span class="k">var</span> <span class="nv">rank</span>: <span class="nc">Rank</span>
</li><li>    <span class="k">var</span> <span class="nv">suit</span>: <span class="nc">Suit</span>
</li><li>    <span class="k">func</span> <span class="nv">simpleDescription</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"The </span>\<span class="p">(</span><span class="nv">rank</span>.<span class="nv">simpleDescription</span>()<span class="p">)</span><span class="s"> of </span>\<span class="p">(</span><span class="nv">suit</span>.<span class="nv">simpleDescription</span>()<span class="p">)</span><span class="s">"</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">threeOfSpades</span> = <span class="nv">Card</span>(<span class="nv">rank</span>: .<span class="nv">three</span>, <span class="nv">suit</span>: .<span class="nv">spades</span>)
</li><li><span class="k">let</span> <span class="nv">threeOfSpadesDescription</span> = <span class="nv">threeOfSpades</span>.<span class="nv">simpleDescription</span>()
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Write a function that returns an array containing a full deck of cards, with one card of each combination of rank and suit.</span><!--end_enstr-->
<span class="jpstr">
ランク（順位）とスート（記号）の各組合せのカード１枚を持つ、カードの完全なデック（一組）を含んでいる配列を返す関数を書いてください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID466">
<h2><span class="enstr">Protocols and Extensions<a class="headerlink" href="#ID466" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコルと拡張<a class="headerlink" href="#ID466" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">protocol</span></code> to declare a protocol.</span><!--end_enstr-->
<span class="jpstr">
あるプロトコルを宣言するために、<code class="docutils literal notranslate"><span class="pre">protocol</span></code>を使ってください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">ExampleProtocol</span> {
</li><li>    <span class="k">var</span> <span class="nv">simpleDescription</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">adjust</span>()
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Classes, enumerations, and structs can all adopt protocols.</span><!--end_enstr-->
<span class="jpstr">
クラス、列挙、そして構造体は、全てそのようなプロトコルを採用することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SimpleClass</span>: <span class="nc">ExampleProtocol</span> {
</li><li>    <span class="k">var</span> <span class="nv">simpleDescription</span>: <span class="nc">String</span> = <span class="s">"A very simple class."</span>
</li><li>    <span class="k">var</span> <span class="nv">anotherProperty</span>: <span class="nc">Int</span> = <span class="m">69105</span>
</li><li>    <span class="k">func</span> <span class="nv">adjust</span>() {
</li><li>        <span class="nv">simpleDescription</span> += <span class="s">"  Now 100% adjusted."</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">a</span> = <span class="nv">SimpleClass</span>()
</li><li><span class="nv">a</span>.<span class="nv">adjust</span>()
</li><li><span class="k">let</span> <span class="nv">aDescription</span> = <span class="nv">a</span>.<span class="nv">simpleDescription</span>
</li><li>
</li><li><span class="k">struct</span> <span class="nv">SimpleStructure</span>: <span class="nc">ExampleProtocol</span> {
</li><li>    <span class="k">var</span> <span class="nv">simpleDescription</span>: <span class="nc">String</span> = <span class="s">"A simple structure"</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">adjust</span>() {
</li><li>        <span class="nv">simpleDescription</span> += <span class="s">" (adjusted)"</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">b</span> = <span class="nv">SimpleStructure</span>()
</li><li><span class="nv">b</span>.<span class="nv">adjust</span>()
</li><li><span class="k">let</span> <span class="nv">bDescription</span> = <span class="nv">b</span>.<span class="nv">simpleDescription</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add another requirement to <code class="docutils literal notranslate"><span class="pre">ExampleProtocol</span></code>. What changes do you need to make to <code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code> and <code class="docutils literal notranslate"><span class="pre">SimpleStructure</span></code> so that they still conform to the protocol?</span><!--end_enstr-->
<span class="jpstr">
別の要件を<code class="docutils literal notranslate"><span class="pre">ExampleProtocol</span></code>に加えてください。どんな変更をあなたは<code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code>と<code class="docutils literal notranslate"><span class="pre">SimpleStructure</span></code>にする必要があるでしょうか、それらが依然としてそのプロトコルに準拠するためには？
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Notice the use of the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword in the declaration of <code class="docutils literal notranslate"><span class="pre">SimpleStructure</span></code> to mark a method that modifies the structure. The declaration of <code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code> doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">SimpleStructure</span></code>の宣言における<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードに注意してください、それはその構造体を修正するメソッドに印を付けるためのものです。<code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code>の宣言はそのメソッドのどれも変化させるとして印される必要はありません、なぜならあるクラスに属するメソッドは常にそのクラスを修正できるからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">extension</span></code> to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</span><!--end_enstr-->
<span class="jpstr">
機能性、例えば新しいメソッドや計算プロパティなどを、既存の型に加えるために、<code class="docutils literal notranslate"><span class="pre">extension</span></code>を使ってください。あなたは１つの拡張を使用することで、どこかほかで宣言される型に、またはあなたがライブラリやフレームワークからインポートした型にさえもプロトコル準拠を加えることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span>: <span class="nc">ExampleProtocol</span> {
</li><li>    <span class="k">var</span> <span class="nv">simpleDescription</span>: <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="s">"The number </span>\<span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="s">"</span>
</li><li>    }
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">adjust</span>() {
</li><li>        <span class="k">self</span> += <span class="m">42</span>
</li><li>    }
</li><li>}
</li><li><span class="nv">print</span>(<span class="m">7</span>.<span class="nv">simpleDescription</span>)
</li><li><span class="c">// Prints "The number 7"</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Write an extension for the <code class="docutils literal notranslate"><span class="pre">Double</span></code> type that adds an <code class="docutils literal notranslate"><span class="pre">absoluteValue</span></code> property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Double</span></code>型のために拡張をひとつ書いてください、それは<code class="docutils literal notranslate"><span class="pre">absoluteValue</span></code>プロパティを加えるものです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</span><!--end_enstr-->
<span class="jpstr">
あなたは、何かほかの名前付きの型のようにプロトコル名を使用することができます ― 例えば、それぞれ異なる型を持つが全てがただ１つのプロトコルに準拠するオブジェクトいくつかのコレクションをつくるためなど。その型があるプロトコル型である値をあなたが扱うとき、そのプロトコル定義の外部のメソッドは利用できません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">protocolValue</span>: <span class="nc">ExampleProtocol</span> = <span class="nv">a</span>
</li><li><span class="nv">print</span>(<span class="nv">protocolValue</span>.<span class="nv">simpleDescription</span>)
</li><li><span class="c">// Prints "A very simple class.  Now 100% adjusted."</span>
</li><li><span class="c"><span class="enstr">// print(protocolValue.anotherProperty)  // Uncomment to see the error</span><!--end_enstr--><span class="jpstr">// print(protocolValue.anotherProperty)  // コメントを外すとエラー</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Even though the variable <code class="docutils literal notranslate"><span class="pre">protocolValue</span></code> has a runtime type of <code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code>, the compiler treats it as the given type of <code class="docutils literal notranslate"><span class="pre">ExampleProtocol</span></code>. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</span><!--end_enstr-->
<span class="jpstr">
たとえ変数<code class="docutils literal notranslate"><span class="pre">protocolValue</span></code>が実行時の型として<code class="docutils literal notranslate"><span class="pre">SimpleClass</span></code>を持つとしても、コンパイラはそれを与えられた型<code class="docutils literal notranslate"><span class="pre">ExampleProtocol</span></code>とみなします。これは、クラスがそれのプロトコル準拠にさらに加えて実装するメソッドやプロパティにあなたが偶然にアクセスすることができないことを意味します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID623">
<h2><span class="enstr">Error Handling<a class="headerlink" href="#ID623" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
エラーの処理<a class="headerlink" href="#ID623" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You represent errors using any type that adopts the <code class="docutils literal notranslate"><span class="pre">Error</span></code> protocol.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">Error</span></code>プロトコルを採用するどんな型でも使用してエラーを表します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">PrinterError</span>: <span class="nc">Error</span> {
</li><li>    <span class="k">case</span> <span class="nv">outOfPaper</span>
</li><li>    <span class="k">case</span> <span class="nv">noToner</span>
</li><li>    <span class="k">case</span> <span class="nv">onFire</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">throw</span></code> to throw an error and <code class="docutils literal notranslate"><span class="pre">throws</span></code> to mark a function that can throw an error. If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</span><!--end_enstr-->
<span class="jpstr">
あるエラーをスローする（投げかける）ために<code class="docutils literal notranslate"><span class="pre">throw</span></code>を、そしてエラーをスローできる関数に印をつけるために<code class="docutils literal notranslate"><span class="pre">throws</span></code>を使ってください。あなたが関数においてエラーをスローするならば、その関数は直ちに返ります、そして関数を呼んだコードがエラーを取り扱います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">send</span>(<span class="nv">job</span>: <span class="nc">Int</span>, <span class="nv">toPrinter</span> <span class="nv">printerName</span>: <span class="nc">String</span>) <span class="k">throws</span> -&gt; <span class="nc">String</span> {
</li><li>    <span class="k">if</span> <span class="nv">printerName</span> == <span class="s">"Never Has Toner"</span> {
</li><li>        <span class="k">throw</span> <span class="nv">PrinterError</span>.<span class="nv">noToner</span>
</li><li>    }
</li><li>    <span class="k">return</span> <span class="s">"Job sent"</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">There are several ways to handle errors. One way is to use <code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code>. Inside the <code class="docutils literal notranslate"><span class="pre">do</span></code> block, you mark code that can throw an error by writing <code class="docutils literal notranslate"><span class="pre">try</span></code> in front of it. Inside the <code class="docutils literal notranslate"><span class="pre">catch</span></code> block, the error is automatically given the name <code class="docutils literal notranslate"><span class="pre">error</span></code> unless you give it a different name.</span><!--end_enstr-->
<span class="jpstr">
いくつかの方法がエラーを取り扱うためにはあります。１つの方法は、<code class="docutils literal notranslate"><span class="pre">do</span></code>-<code class="docutils literal notranslate"><span class="pre">catch</span></code>を使うことです。<code class="docutils literal notranslate"><span class="pre">do</span></code>ブロックの内部で、あなたはエラーをスローできるコードを、それの前に<code class="docutils literal notranslate"><span class="pre">try</span></code>を書くことによって印します。<code class="docutils literal notranslate"><span class="pre">catch</span></code>ブロック内部で、エラーは、あなたがそれに別の名前を与えるのでない限り、自動的に名前<code class="docutils literal notranslate"><span class="pre">error</span></code>を与えられます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">do</span> {
</li><li>    <span class="k">let</span> <span class="nv">printerResponse</span> = <span class="k">try</span> <span class="nv">send</span>(<span class="nv">job</span>: <span class="m">1040</span>, <span class="nv">toPrinter</span>: <span class="s">"Bi Sheng"</span>)
</li><li>    <span class="nv">print</span>(<span class="nv">printerResponse</span>)
</li><li>} <span class="k">catch</span> {
</li><li>    <span class="nv">print</span>(<span class="nv">error</span>)
</li><li>}
</li><li><span class="c">// Prints "Job sent"</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Change the printer name to <code class="docutils literal notranslate"><span class="pre">"Never</span> <span class="pre">Has</span> <span class="pre">Toner"</span></code>, so that the <code class="docutils literal notranslate"><span class="pre">send(job:toPrinter:)</span></code> function throws an error.</span><!--end_enstr-->
<span class="jpstr">
プリンタ名を<code class="docutils literal notranslate"><span class="pre">"Never</span> <span class="pre">Has</span> <span class="pre">Toner"</span></code>に変更してください、そうすると<code class="docutils literal notranslate"><span class="pre">send(job:toPrinter:)</span></code>関数はエラーをスローします。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can provide multiple <code class="docutils literal notranslate"><span class="pre">catch</span></code> blocks that handle specific errors. You write a pattern after <code class="docutils literal notranslate"><span class="pre">catch</span></code> just as you do after <code class="docutils literal notranslate"><span class="pre">case</span></code> in a switch.</span><!--end_enstr-->
<span class="jpstr">
あなたは、それぞれが特定のエラーを取り扱う複数の<code class="docutils literal notranslate"><span class="pre">catch</span></code>ブロックを提供することができます。あなたは、まさにあなたがスイッチにおいて<code class="docutils literal notranslate"><span class="pre">case</span></code>の後にするように、<code class="docutils literal notranslate"><span class="pre">catch</span></code>の後にひとつのパターンを書きます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">do</span> {
</li><li>    <span class="k">let</span> <span class="nv">printerResponse</span> = <span class="k">try</span> <span class="nv">send</span>(<span class="nv">job</span>: <span class="m">1440</span>, <span class="nv">toPrinter</span>: <span class="s">"Gutenberg"</span>)
</li><li>    <span class="nv">print</span>(<span class="nv">printerResponse</span>)
</li><li>} <span class="k">catch</span> <span class="nv">PrinterError</span>.<span class="nv">onFire</span> {
</li><li>    <span class="nv">print</span>(<span class="s">"I'll just put this over here, with the rest of the fire."</span>)
</li><li>} <span class="k">catch</span> <span class="k">let</span> <span class="nv">printerError</span> <span class="k">as</span> <span class="nc">PrinterError</span> {
</li><li>    <span class="nv">print</span>(<span class="s">"Printer error: </span>\<span class="p">(</span><span class="nv">printerError</span><span class="p">)</span><span class="s">."</span>)
</li><li>} <span class="k">catch</span> {
</li><li>    <span class="nv">print</span>(<span class="nv">error</span>)
</li><li>}
</li><li><span class="c">// Prints "Job sent"</span>
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Add code to throw an error inside the <code class="docutils literal notranslate"><span class="pre">do</span></code> block. What kind of error do you need to throw so that the error is handled by the first <code class="docutils literal notranslate"><span class="pre">catch</span></code> block? What about the second and third blocks?</span><!--end_enstr-->
<span class="jpstr">
コードを加えてエラーを<code class="docutils literal notranslate"><span class="pre">do</span></code>ブロック内部でスローしてください。エラーが最初の<code class="docutils literal notranslate"><span class="pre">catch</span></code>ブロックによって取り扱われるためには、どんな種類のエラーをあなたはスローする必要があるでしょう。２番目と３番目のブロックはどうですか？
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Another way to handle errors is to use <code class="docutils literal notranslate"><span class="pre">try?</span></code> to convert the result to an optional. If the function throws an error, the specific error is discarded and the result is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Otherwise, the result is an optional containing the value that the function returned.</span><!--end_enstr-->
<span class="jpstr">
エラーを取り扱う別の方法は、<code class="docutils literal notranslate"><span class="pre">try?</span></code>を使って結果をオプショナルに変換することです。関数がエラーをスローするならば、その具体的なエラーは廃棄されます、そしてその結果は<code class="docutils literal notranslate"><span class="pre">nil</span></code>になります。そうでなければ、結果は関数が返した値を含んでいるオプショナルです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">printerSuccess</span> = <span class="k">try</span>? <span class="nv">send</span>(<span class="nv">job</span>: <span class="m">1884</span>, <span class="nv">toPrinter</span>: <span class="s">"Mergenthaler"</span>)
</li><li><span class="k">let</span> <span class="nv">printerFailure</span> = <span class="k">try</span>? <span class="nv">send</span>(<span class="nv">job</span>: <span class="m">1885</span>, <span class="nv">toPrinter</span>: <span class="s">"Never Has Toner"</span>)
</li></ol></div></div></div>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">defer</span></code> to write a block of code that is executed after all other code in the function, just before the function returns. The code is executed regardless of whether the function throws an error. You can use <code class="docutils literal notranslate"><span class="pre">defer</span></code> to write setup and cleanup code next to each other, even though they need to be executed at different times.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">defer</span></code>を使って関数の中の全ての他のコードの後で、その関数が返る直前に実行されるひとかたまりのコードを書いてください。そのコードは、関数がエラーをスローするかどうかに関係なく実行されます。あなたは、<code class="docutils literal notranslate"><span class="pre">defer</span></code>を使うことでセットアップおよびクリーンアップコードを隣り合わせに書くことができます、たとえそれらが異なる時に実行される必要があるにしても。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">fridgeIsOpen</span> = <span class="k">false</span>
</li><li><span class="k">let</span> <span class="nv">fridgeContent</span> = [<span class="s">"milk"</span>, <span class="s">"eggs"</span>, <span class="s">"leftovers"</span>]
</li><li>
</li><li><span class="k">func</span> <span class="nv">fridgeContains</span>(<span class="k">_</span> <span class="nv">food</span>: <span class="nc">String</span>) -&gt; <span class="nc">Bool</span> {
</li><li>    <span class="nv">fridgeIsOpen</span> = <span class="k">true</span>
</li><li>    <span class="k">defer</span> {
</li><li>        <span class="nv">fridgeIsOpen</span> = <span class="k">false</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">let</span> <span class="nv">result</span> = <span class="nv">fridgeContent</span>.<span class="nv">contains</span>(<span class="nv">food</span>)
</li><li>    <span class="k">return</span> <span class="nv">result</span>
</li><li>}
</li><li><span class="nv">fridgeContains</span>(<span class="s">"banana"</span>)
</li><li><span class="nv">print</span>(<span class="nv">fridgeIsOpen</span>)
</li><li><span class="c"><span class="enstr">// Prints "false"</span><!--end_enstr--><span class="jpstr">（「false」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID624">
<h2><span class="enstr">Generics<a class="headerlink" href="#ID624" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
総称体<a class="headerlink" href="#ID624" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Write a name inside angle brackets to make a generic function or type.</span><!--end_enstr-->
<span class="jpstr">
総称体である関数や型を作るためには、その名前を山形括弧の中に書いてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeArray</span>&lt;<span class="nv">Item</span>&gt;(<span class="nv">repeating</span> <span class="nv">item</span>: <span class="nc">Item</span>, <span class="nv">numberOfTimes</span>: <span class="nc">Int</span>) -&gt; [<span class="nc">Item</span>] {
</li><li>    <span class="k">var</span> <span class="nv">result</span> = [<span class="nc">Item</span>]()
</li><li>    <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">numberOfTimes</span> {
</li><li>        <span class="nv">result</span>.<span class="nv">append</span>(<span class="nv">item</span>)
</li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">result</span>
</li><li>}
</li><li><span class="nv">makeArray</span>(<span class="nv">repeating</span>: <span class="s">"knock"</span>, <span class="nv">numberOfTimes</span>: <span class="m">4</span>)
</li></ol></div></div></div>
<p><span class="enstr">You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</span><!--end_enstr-->
<span class="jpstr">
あなたは関数やメソッドだけでなく、クラス、列挙、そして構造体も総称体の形式にすることができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c"><span class="enstr">// Reimplement the Swift standard library's optional type</span><!--end_enstr--><span class="jpstr">（スウィフト標準ライブラリのオプショナル型の再実装）</span><!--end_jpstr--></span>
</li><li><span class="k">enum</span> <span class="nv">OptionalValue</span>&lt;<span class="nv">Wrapped</span>&gt; {
</li><li>    <span class="k">case</span> <span class="nv">none</span>
</li><li>    <span class="k">case</span> <span class="nv">some</span>(<span class="nv">Wrapped</span>)
</li><li>}
</li><li><span class="k">var</span> <span class="nv">possibleInteger</span>: <span class="nc">OptionalValue</span>&lt;<span class="nc">Int</span>&gt; = .<span class="nv">none</span>
</li><li><span class="nv">possibleInteger</span> = .<span class="nv">some</span>(<span class="m">100</span>)
</li></ol></div></div></div>
<p><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">where</span></code> right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</span><!--end_enstr-->
<span class="jpstr">
本文のまさに前に、必要なことのリストを指定するために<code class="docutils literal notranslate"><span class="pre">where</span></code>を使ってください ― 例えば、型があるプロトコルを実装することを要求するために、２つの型が同じものであることを要求するために、またはあるクラスがある特定のスーパークラスを持つことを要求するために。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">anyCommonElements</span>&lt;<span class="nv">T</span>: <span class="nc">Sequence</span>, <span class="nv">U</span>: <span class="nc">Sequence</span>&gt;(<span class="k">_</span> <span class="nv">lhs</span>: <span class="nc">T</span>, <span class="k">_</span> <span class="nv">rhs</span>: <span class="nc">U</span>) -&gt; <span class="nc">Bool</span>
</li><li>    <span class="k">where</span> <span class="nc">T</span>.<span class="nc">Element</span>: <span class="nc">Equatable</span>, <span class="nc">T</span>.<span class="nc">Element</span> == <span class="nc">U</span>.<span class="nc">Element</span>
</li><li>{
</li><li>    <span class="k">for</span> <span class="nv">lhsItem</span> <span class="k">in</span> <span class="nv">lhs</span> {
</li><li>        <span class="k">for</span> <span class="nv">rhsItem</span> <span class="k">in</span> <span class="nv">rhs</span> {
</li><li>            <span class="k">if</span> <span class="nv">lhsItem</span> == <span class="nv">rhsItem</span> {
</li><li>                <span class="k">return</span> <span class="k">true</span>
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>    <span class="k">return</span> <span class="k">false</span>
</li><li>}
</li><li><span class="nv">anyCommonElements</span>([<span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>], [<span class="m">3</span>])
</li></ol></div></div></div>
<div class="admonition-experiment admonition">
<p class="first admonition-title"><span class="enstr">Experiment</span><!--end_enstr-->
<span class="jpstr">
試してください
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Modify the <code class="docutils literal notranslate"><span class="pre">anyCommonElements(_:_:)</span></code> function to make a function that returns an array of the elements that any two sequences have in common.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">anyCommonElements(_:_:)</span></code>関数を修正して、何らかの２つのシーケンスが共通に持つ要素それらからなるある配列を返す関数を作ってください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Writing <code class="docutils literal notranslate"><span class="pre">&lt;T:</span> <span class="pre">Equatable&gt;</span></code> is the same as writing <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span> <span class="pre">...</span> <span class="pre">where</span> <span class="pre">T:</span> <span class="pre">Equatable</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">&lt;T:</span> <span class="pre">Equatable&gt;</span></code>と書くことは、<code class="docutils literal notranslate"><span class="pre">&lt;T&gt;</span> <span class="pre">...</span> <span class="pre">where</span> <span class="pre">T:</span> <span class="pre">Equatable</span></code>と書くことと同じです。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Compatibility.html"><span class="enstr">Version Compatibility</span><!--end_enstr-->
<span class="jpstr">
バージョン互換性
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="../LanguageGuide/TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2020 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
